$VAR1 = [
          [
            1,
            '[ap 04:51] The Robert C. Martin Clean Code Collection - Robert C. Martin.epub (The_Robert_C._Martin_Clean_Code_split_001.html) - 9-to-5',
            "In this collection, Robert C. Martin, also known as \x{201c}Uncle Bob,\x{201d} provides a pragmatic method for writing better code from the start. He reveals the disciplines, techniques, tools, and practices that separate software craftsmen from mere \x{201c}<<9-to-5|10a:0>>\x{201d} programmers. Within this collection are the tools and methods you need to become a true software professional.",
          ],
          [
            1,
            '[~ 19:51] The Robert C. Martin Clean Code Collection - Robert C. Martin.epub (The_Robert_C._Martin_Clean_Code_split_007.html) - about 1951',
            "In <<about 1951|18:0>>, a quality approach called Total Productive Maintenance (TPM) came on the Japanese scene. Its focus is on maintenance rather than on production. One of the major pillars of TPM is the set of so-called 5S principles. 5S is a set of disciplines\x{2014}and here I use the term \x{201c}discipline\x{201d} instructively. These 5S principles are in fact at the foundations of Lean\x{2014}another buzzword on the Western scene, and an increasingly prominent buzzword in software circles. These principles are not an option. As Uncle Bob relates in his front matter, good software practice requires such discipline: focus, presence of mind, and thinking. It is not always just about doing, about pushing the factory equipment to produce at the optimal velocity. The 5S philosophy comprises these concepts:",
          ],
          [
            1,
            '[~ 20:00] The Robert C. Martin Clean Code Collection - Robert C. Martin.epub (The_Robert_C._Martin_Clean_Code_split_007.html) - around 1960',
            "If you take up the challenge\x{2014}yes, the challenge\x{2014}of reading and applying this book, you\x{2019}ll come to understand and appreciate the last point. Here, we are finally driving to the roots of responsible professionalism in a profession that should be concerned with the life cycle of a product. As we maintain automobiles and other machines under TPM, breakdown maintenance\x{2014}waiting for bugs to surface\x{2014}is the exception. Instead, we go up a level: inspect the machines every day and fix wearing parts before they break, or do the equivalent of the proverbial 10,000-mile oil change to forestall wear and tear. In code, refactor mercilessly. You can improve yet one level further, as the TPM movement innovated over 50 years ago: build machines that are more maintainable in the first place. Making your code readable is as important as making it executable. The ultimate practice, introduced in TPM circles <<around 1960|18:1>>, is to focus on introducing entire new machines or replacing old ones. As Fred Brooks admonishes us, we should probably re-do major software chunks from scratch every seven years or so to sweep away creeping cruft. Perhaps we should update Brooks\x{2019} time constant to an order of weeks, days or hours instead of years. That\x{2019}s where detail lies.",
          ],
          [
            1,
            '[22:18] The Robert C. Martin Clean Code Collection - Robert C. Martin.epub (The_Robert_C._Martin_Clean_Code_split_013.html) - 22:18',
            "MockRequest request;
private final String HTTP_DATE_REGEXP =
\x{201c}[SMTWF][a-z]{2}\\\\,\\\\s[0-9]{2}\\\\s[JFMASOND][a-z]{2}\\\\s\x{201d}+
\x{201c}[0-9]{4}\\\\s[0-9]{2}\\\\:[0-9]{2}\\\\:[0-9]{2}\\\\sGMT\x{201d};
private Response response;
private FitNesseContext context;
private FileResponder responder;
private Locale saveLocale;
// Example: \x{201d}Tue, 02 Apr 2003 <<22:18|1a>>:49 GMT\x{201d}",
          ],
          [
            1,
            '[ap 02:00] The Robert C. Martin Clean Code Collection - Robert C. Martin.epub (The_Robert_C._Martin_Clean_Code_split_013.html) - 2',
            '/**
* This class Generates prime numbers up to a user specified
* maximum. The algorithm used is the Sieve of Eratosthenes.
* <p>
* Eratosthenes of Cyrene, b. c. 276 BC, Cyrene, Libya --
* d. c. 194, Alexandria. The first man to calculate the
* circumference of the Earth. Also known for working on
* calendars with leap years and ran the library at Alexandria.
* <p>
* The algorithm is quite simple. Given an array of integers
* starting at <<2|9g>>. Cross out all multiples of 2. Find the next
* uncrossed integer, and cross out all of its multiples.
* Repeat untilyou have passed the square root of the maximum
* value.
*
* @author Alphonse
* @version 13 Feb 2002 atp
*/
import java.util.*;
public class GeneratePrimes
{
/**
* @param maxValue is the generation limit.
*/
public static int[] generatePrimes(int maxValue)
{
if (maxValue >= 2) // the only valid case
{
// declarations
int s = maxValue + 1; // size of array
boolean[] f = new boolean[s];
int i;
// initialize array to true.
for (i = 0; i < s; i++)
f[i] = true;
// get rid of known non-primes
f[0] = f[1] = false;
// sieve
int j;
for (i = 2; i < Math.sqrt(s) + 1; i++)
{
if (f[i]) // if i is uncrossed, cross its multiples.
{
for (j = 2 * i; j < s; j += i)
f[j] = false; // multiple is not prime
}
}
// how many primes are there?
int count = 0;
for (i = 0; i < s; i++)
{
if (f[i])
count++; // bump count.
}
int[] primes = new int[count];
// move the primes into the result
for (i = 0, j = 0; i < s; i++)
{
if (f[i]) // if prime
primes[j++] = i;
}
return primes; // return the primes
}
else // maxValue < 2
return new int[0]; // return null array if bad input.
}
}',
          ],
          [
            1,
            '[ap 02:00] The Robert C. Martin Clean Code Collection - Robert C. Martin.epub (The_Robert_C._Martin_Clean_Code_split_013.html) - 2',
            "/**
* This class Generates prime numbers up to a user specified
* maximum. The algorithm used is the Sieve of Eratosthenes.
* Given an array of integers starting at <<2|9g>>:
* Find the first uncrossed integer, and cross out all its
* multiples. Repeat until there are no more multiples
* in the array.
*/
public class PrimeGenerator
{
private static boolean[] crossedOut;
private static int[] result;
public static int[] generatePrimes(int maxValue)
{
if (maxValue < 2)
return new int[0];
else
{
uncrossIntegersUpTo(maxValue);
crossOutMultiples();
putUncrossedIntegersIntoResult();
return result;
}
}
private static void uncrossIntegersUpTo(int maxValue)
{
crossedOut = new boolean[maxValue + 1];
for (int i = 2; i < crossedOut.length; i++)
crossedOut[i] = false;
}
private static void crossOutMultiples()
{
int limit = determineIterationLimit();
for (int i = 2; i <= limit; i++)
if (notCrossed(i))
crossOutMultiplesOf(i);
}
private static int determineIterationLimit()
{
// Every multiple in the array has a prime factor that
// is less than or equal to the root of the array size,
// so we don\x{2019}t have to cross out multiples of numbers
// larger than that root.
double iterationLimit = Math.sqrt(crossedOut.length);
return (int) iterationLimit;
}
private static void crossOutMultiplesOf(int i)
{
for (int multiple = 2*i;
multiple < crossedOut.length;
multiple += i)
crossedOut[multiple] = true;
}
private static boolean notCrossed(int i)
{
return crossedOut[i] == false;
}
private static void putUncrossedIntegersIntoResult()
{
result = new int[numberOfUncrossedIntegers()];
for (int j = 0, i = 2; i < crossedOut.length; i++)
if (notCrossed(i))
result[j++] = i;
}
private static int numberOfUncrossedIntegers()
{
int count = 0;
for (int i = 2; i < crossedOut.length; i++)
if (notCrossed(i))
count++;
return count;
}
}",
          ],
          [
            1,
            '[ap 01:20] The Robert C. Martin Clean Code Collection - Robert C. Martin.epub (The_Robert_C._Martin_Clean_Code_split_014.html) - 120',
            "I used to follow the rule that you should never have to scroll to the right. But monitors are too wide for that nowadays, and younger programmers can shrink the font so small that they can get 200 characters across the screen. Don\x{2019}t do that. I personally set my limit at <<120|9c:0>>.",
          ],
          [
            1,
            '[ap 10:10] The Robert C. Martin Clean Code Collection - Robert C. Martin.epub (The_Robert_C._Martin_Clean_Code_split_019.html) - 10-10',
            'What if we considered a solution like that in Listing <<10-10|5a:0>>? Each public interface method defined in the previous Sql from Listing 10-9 is refactored out to its own derivative of the Sql class. Note that the private methods, such as valuesList, move directly where they are needed. The common private behavior is isolated to a pair of utility classes, Where and ColumnList.',
          ],
          [
            1,
            '[ap 10:10] The Robert C. Martin Clean Code Collection - Robert C. Martin.epub (The_Robert_C._Martin_Clean_Code_split_019.html) - 10-10',
            'What if we considered a solution like that in Listing <<10-10|5a:0>>? Each public interface method defined in the previous Sql from Listing 10-9 is refactored out to its own derivative of the Sql class. Note that the private methods, such as valuesList, move directly where they are needed. The common private behavior is isolated to a pair of utility classes, Where and ColumnList.
Listing <<10-10|5a:0>> A set of closed classes
abstract public class Sql {
public Sql(String table, Column[] columns)
abstract public String generate();
}
public class CreateSql extends Sql {
public CreateSql(String table, Column[] columns)
@Override public String generate()
}
public class SelectSql extends Sql {
public SelectSql(String table, Column[] columns)
@Override public String generate()
}
public class InsertSql extends Sql {
public InsertSql(String table, Column[] columns, Object[] fields)
@Override public String generate()
private String valuesList(Object[] fields, final Column[] columns)
}
public class SelectWithCriteriaSql extends Sql {
public SelectWithCriteriaSql(
String table, Column[] columns, Criteria criteria)
@Override public String generate()
}
public class SelectWithMatchSql extends Sql {
public SelectWithMatchSql(
String table, Column[] columns, Column column, String pattern)
@Override public String generate()
}
public class FindByKeySql extends Sql
public FindByKeySql(
String table, Column[] columns, String keyColumn, String keyValue)
@Override public String generate()
}
public class PreparedInsertSql extends Sql {
public PreparedInsertSql(String table, Column[] columns)
@Override public String generate() {
private String placeholderList(Column[] columns)
}
public class Where {
public Where(String criteria)
public String generate()
}
public class ColumnList {
public ColumnList(Column[] columns)
public String generate()
}',
          ],
          [
            1,
            '[14:10] The Robert C. Martin Clean Code Collection - Robert C. Martin.epub (The_Robert_C._Martin_Clean_Code_split_023.html) - 14-10',
            "I added the two argument types incrementally. First, I added the String argument, which yielded this:
Listing <<14-10|5a:0>> Args.java (Boolean and String)
package com.objectmentor.utilities.getopts;
import java.text.ParseException;
import java.util.*;
public class Args {
private String schema;
private String[] args;
private boolean valid = true;
private Set<Character> unexpectedArguments = new TreeSet<Character>();
private Map<Character, Boolean> booleanArgs =
new HashMap<Character, Boolean>();
private Map<Character, String> stringArgs =
new HashMap<Character, String>();
private Set<Character> argsFound = new HashSet<Character>();
private int currentArgument;
private char errorArgument = '\\0';
enum ErrorCode {
OK, MISSING_STRING}
private ErrorCode errorCode = ErrorCode.OK;
public Args(String schema, String[] args) throws ParseException {
this.schema = schema;
this.args = args;
valid = parse();
}
private boolean parse() throws ParseException {
if (schema.length() == 0 && args.length == 0)
return true;
parseSchema();
parseArguments();
return valid;
}
private boolean parseSchema() throws ParseException {
for (String element : schema.split(\x{201c},\x{201d})) {
if (element.length() > 0) {
String trimmedElement = element.trim();
parseSchemaElement(trimmedElement);
}
}
return true;
}
private void parseSchemaElement(String element) throws ParseException {
char elementId = element.charAt(0);
String elementTail = element.substring(1);
validateSchemaElementId(elementId);
if (isBooleanSchemaElement(elementTail))
parseBooleanSchemaElement(elementId);
else if (isStringSchemaElement(elementTail))
parseStringSchemaElement(elementId);
}
private void validateSchemaElementId(char elementId) throws ParseException {
if (!Character.isLetter(elementId)) {
throw new ParseException(
\x{201c}Bad character:\x{201d} + elementId + \x{201c}in Args format: \x{201d} + schema, 0);
}
}
private void parseStringSchemaElement(char elementId) {
stringArgs.put(elementId, \x{201c} \x{201d});
}
private boolean isStringSchemaElement(String elementTail) {
return elementTail.equals(\x{201c}*\x{201d});
}
private boolean isBooleanSchemaElement(String elementTail) {
return elementTail.length() == 0;
}
private void parseBooleanSchemaElement(char elementId) {
booleanArgs.put(elementId, false);
}
private boolean parseArguments() {
for (currentArgument = 0; currentArgument < args.length; currentArgument++)
{
String arg = args[currentArgument];
parseArgument(arg);
}
return true;
}
private void parseArgument(String arg) {
if (arg.startsWith(\x{201c}-\x{201d}))
parseElements(arg);
}
private void parseElements(String arg) {
for (int i = 1; i < arg.length(); i++)
parseElement(arg.charAt(i));
}
private void parseElement(char argChar) {
if (setArgument(argChar))
argsFound.add(argChar);
else {
unexpectedArguments.add(argChar);
valid = false;
}
}
private boolean setArgument(char argChar) {
boolean set = true;
if (isBoolean(argChar))
setBooleanArg(argChar, true);
else if (isString(argChar))
setStringArg(argChar, \x{201c} \x{201d});
else
set = false;
return set;
}
private void setStringArg(char argChar, String s) {
currentArgument++;
try {
stringArgs.put(argChar, args[currentArgument]);
} catch (ArrayIndexOutOfBoundsException e) {
valid = false;
errorArgument = argChar;
errorCode = ErrorCode.MISSING_STRING;
}
}
private boolean isString(char argChar) {
return stringArgs.containsKey(argChar);
}
private void setBooleanArg(char argChar, boolean value) {
booleanArgs.put(argChar, value);
}
private boolean isBoolean(char argChar) {
return booleanArgs.containsKey(argChar);
}
public int cardinality() {
return argsFound.size();
}
public String usage() {
if (schema.length() > 0)
return \x{201c}-[\x{201c} + schema + \x{201d}]\x{201d};
else
return \x{201c} \x{201d};
}
public String errorMessage() throws Exception {
if (unexpectedArguments.size() > 0) {
return unexpectedArgumentMessage();
} else
switch (errorCode) {
case MISSING_STRING:
return String.format(\x{201c}Could not find string parameter for -%c.\x{201d}, errorArgument);
case OK:
throw new Exception(\x{201c}TILT: Should not get here.\x{201d});
}
return \x{201c} \x{201d};
}
private String unexpectedArgumentMessage() {
StringBuffer message = new StringBuffer(\x{201c}Argument(s) -\x{201d});
for (char c : unexpectedArguments) {
message.append(c);
}
message.append(\x{201c} unexpected.\x{201d});
return message.toString();
}
public boolean getBoolean(char arg) {
return falseIfNull(booleanArgs.get(arg));
}
private boolean falseIfNull(Boolean b) {
return b == null ? false : b;
}
public String getString(char arg) {
return blankIfNull(stringArgs.get(arg));
}
private String blankIfNull(String s) {
return s == null ? \x{201c} \x{201d} : s;
}
public boolean has(char arg) {
return argsFound.contains(arg);
}
public boolean isValid() {
return valid;
}
}",
          ],
          [
            1,
            '[14:11] The Robert C. Martin Clean Code Collection - Robert C. Martin.epub (The_Robert_C._Martin_Clean_Code_split_023.html) - 14-11',
            'So I proceeded to make a large number of very tiny changes. Each change moved the structure of the system toward the ArgumentMarshaler concept. And yet each change kept the system working. The first change I made was to add the skeleton of the ArgumentMarshaller to the end of the festering pile (Listing <<14-11|5a:0>>).',
          ],
          [
            1,
            '[14:11] The Robert C. Martin Clean Code Collection - Robert C. Martin.epub (The_Robert_C._Martin_Clean_Code_split_023.html) - 14-11',
            'So I proceeded to make a large number of very tiny changes. Each change moved the structure of the system toward the ArgumentMarshaler concept. And yet each change kept the system working. The first change I made was to add the skeleton of the ArgumentMarshaller to the end of the festering pile (Listing <<14-11|5a:0>>).
Listing <<14-11|5a:0>> ArgumentMarshaller appended to Args.java
private class ArgumentMarshaler }
private boolean booleanValue = false;
public void setBoolean(boolean value) {
booleanValue = value;
}
public boolean getBoolean() {return booleanValue;}
}
private class BooleanArgumentMarshaler extends ArgumentMarshaler {
}
private class StringArgumentMarshaler extends ArgumentMarshaler {
}
private class IntegerArgumentMarshaler extends ArgumentMarshaler {
}
}',
          ],
          [
            1,
            '[14:12] The Robert C. Martin Clean Code Collection - Robert C. Martin.epub (The_Robert_C._Martin_Clean_Code_split_023.html) - 14-12',
            "Okay, so now let\x{2019}s look at the whole picture again. Listing <<14-12|5a:0>> shows the current form of the Args class.",
          ],
          [
            1,
            '[14:12] The Robert C. Martin Clean Code Collection - Robert C. Martin.epub (The_Robert_C._Martin_Clean_Code_split_023.html) - 14-12',
            "Okay, so now let\x{2019}s look at the whole picture again. Listing <<14-12|5a:0>> shows the current form of the Args class.
Listing <<14-12|5a:0>> Args.java (After first refactoring)
package com.objectmentor.utilities.getopts;
import java.text.ParseException;
import java.util.*;
public class Args {
private String schema;
private String[] args;
private boolean valid = true;
private Set<Character> unexpectedArguments = new TreeSet<Character>();
private Map<Character, ArgumentMarshaler> marshalers =
new HashMap<Character, ArgumentMarshaler>();
private Set<Character> argsFound = new HashSet<Character>();
private int currentArgument;
private char errorArgumentId = '\\0';
private String errorParameter = \x{201c}TILT\x{201d};
private ErrorCode errorCode = ErrorCode.OK;
private enum ErrorCode {
OK, MISSING_STRING, MISSING_INTEGER, INVALID_INTEGER,
UNEXPECTED_ARGUMENT}
public Args(String schema, String[] args) throws ParseException {
this.schema = schema;
this.args = args;
valid = parse();
}
private boolean parse() throws ParseException {
if (schema.length() == 0 && args.length == 0)
return true;
parseSchema();
try {
parseArguments();
} catch (ArgsException e) {
}
return valid;
}
private boolean parseSchema() throws ParseException {
for (String element : schema.split(\x{201c},\x{201d})) {
if (element.length() > 0) {
String trimmedElement = element.trim();
parseSchemaElement(trimmedElement);
}
}
return true;
}
private void parseSchemaElement(String element) throws ParseException {
char elementId = element.charAt(0);
String elementTail = element.substring(1);
validateSchemaElementId(elementId);
if (isBooleanSchemaElement(elementTail))
marshalers.put(elementId, new BooleanArgumentMarshaler());
else if (isStringSchemaElement(elementTail))
marshalers.put(elementId, new StringArgumentMarshaler());
else if (isIntegerSchemaElement(elementTail)) {
marshalers.put(elementId, new IntegerArgumentMarshaler());
} else {
throw new ParseException(String.format(
\x{201c}Argument: %c has invalid format: %s.\x{201d}, elementId, elementTail), 0);
}
}
private void validateSchemaElementId(char elementId) throws ParseException {
if (!Character.isLetter(elementId)) {
throw new ParseException(
\x{201c}Bad character:\x{201d} + elementId + \x{201c}in Args format: \x{201d} + schema, 0);
}
}
private boolean isStringSchemaElement(String elementTail) {
return elementTail.equals(\x{201c}*\x{201d});
}
private boolean isBooleanSchemaElement(String elementTail) {
return elementTail.length() == 0;
}
private boolean isIntegerSchemaElement(String elementTail) {
return elementTail.equals(\x{201c}-\x{201d});
}
private boolean parseArguments() throws ArgsException {
for (currentArgument=0; currentArgument<args.length; currentArgument++) {
String arg = args[currentArgument];
parseArgument(arg);
}
return true;
}
private void parseArgument(String arg) throws ArgsException {
if (arg.startsWith(\x{201c}-\x{201d}))
parseElements(arg);
}
private void parseElements(String arg) throws ArgsException {
for (int i = 1; i < arg.length(); i++)
parseElement(arg.charAt(i));
}
private void parseElement(char argChar) throws ArgsException {
if (setArgument(argChar))
argsFound.add(argChar);
else {
unexpectedArguments.add(argChar);
errorCode = ErrorCode.UNEXPECTED_ARGUMENT;
valid = false;
}
}
private boolean setArgument(char argChar) throws ArgsException {
ArgumentMarshaler m = marshalers.get(argChar);
try {
if (m instanceof BooleanArgumentMarshaler)
setBooleanArg(m);
else if (m instanceof StringArgumentMarshaler)
setStringArg(m);
else if (m instanceof IntegerArgumentMarshaler)
setIntArg(m);
else
return false;
} catch (ArgsException e) {
valid = false;
errorArgumentId = argChar;
throw e;
}
return true;
}
private void setIntArg(ArgumentMarshaler m) throws ArgsException {
currentArgument++;
String parameter = null;
try {
parameter = args[currentArgument];
m.set(parameter);
} catch (ArrayIndexOutOfBoundsException e) {
errorCode = ErrorCode.MISSING_INTEGER;
throw new ArgsException();
} catch (ArgsException e) {
errorParameter = parameter;
errorCode = ErrorCode.INVALID_INTEGER;
throw e;
}
}
private void setStringArg(ArgumentMarshaler m) throws ArgsException {
currentArgument++;
try {
m.set(args[currentArgument]);
} catch (ArrayIndexOutOfBoundsException e) {
errorCode = ErrorCode.MISSING_STRING;
throw new ArgsException();
}
}
private void setBooleanArg(ArgumentMarshaler m) {
try {
m.set(\x{201c}true\x{201d});
} catch (ArgsException e) {
}
}
public int cardinality() {
return argsFound.size();
}
public String usage() {
if (schema.length() > 0)
return \x{201c}-[\x{201c} + schema + \x{201d}]\x{201d};
else
return \x{201c} \x{201d};
}
public String errorMessage() throws Exception {
switch (errorCode) {
case OK:
throw new Exception(\x{201c}TILT: Should not get here.\x{201d});
case UNEXPECTED_ARGUMENT:
return unexpectedArgumentMessage();
case MISSING_STRING:
return String.format(\x{201c}Could not find string parameter for -%c.\x{201d},
errorArgumentId);
case INVALID_INTEGER:
return String.format(\x{201c}Argument -%c expects an integer but was '%s'.\x{201d},
errorArgumentId, errorParameter);
case MISSING_INTEGER:
return String.format(\x{201c}Could not find integer parameter for -%c.\x{201d},
errorArgumentId);
}
return \x{201c} \x{201d};
}
private String unexpectedArgumentMessage() {
StringBuffer message = new StringBuffer(\x{201c}Argument(s) -\x{201d});
for (char c : unexpectedArguments) {
message.append(c);
}
message.append(\x{201c} unexpected.\x{201d});
return message.toString();
}
public boolean getBoolean(char arg) {
Args.ArgumentMarshaler am = marshalers.get(arg);
boolean b = false;
try {
b = am != null && (Boolean) am.get();
} catch (ClassCastException e) {
b = false;
}
return b;
}
public String getString(char arg) {
Args.ArgumentMarshaler am = marshalers.get(arg);
try {
return am == null ? \x{201c} \x{201d} : (String) am.get();
} catch (ClassCastException e) {
return \x{201c} \x{201d};
}
}
public int getInt(char arg) {
Args.ArgumentMarshaler am = marshalers.get(arg);
try {
return am == null ? 0 : (Integer) am.get();
} catch (Exception e) {
return 0;
}
}
public boolean has(char arg) {
return argsFound.contains(arg);
}
public boolean isValid() {
return valid;
}
private class ArgsException extends Exception {
}
private abstract class ArgumentMarshaler {
public abstract void set(String s) throws ArgsException;
public abstract Object get();
}
private class BooleanArgumentMarshaler extends ArgumentMarshaler {
private boolean booleanValue = false;
public void set(String s) {
booleanValue = true;
}
public Object get() {
return booleanValue;
}
}
private class StringArgumentMarshaler extends ArgumentMarshaler {
private String stringValue = \x{201c} \x{201d};
public void set(String s) {
stringValue = s;
}
public Object get() {
return stringValue;
}
}
private class IntegerArgumentMarshaler extends ArgumentMarshaler {
private int intValue = 0;
public void set(String s) throws ArgsException {
try {
intValue = Integer.parseInt(s);
} catch (NumberFormatException e) {
throw new ArgsException();
}
}
public Object get() {
return intValue;
}
}
}",
          ],
          [
            1,
            '[14:13] The Robert C. Martin Clean Code Collection - Robert C. Martin.epub (The_Robert_C._Martin_Clean_Code_split_023.html) - 14-13',
            'So now we have completely separated the exception and error code from the Args module. (See Listing <<14-13|5a:0>> through Listing <<14-16|5a:0>>.) This was achieved through a series of about 30 tiny steps, keeping the tests passing between each step.',
          ],
          [
            1,
            '[14:13] The Robert C. Martin Clean Code Collection - Robert C. Martin.epub (The_Robert_C._Martin_Clean_Code_split_023.html) - 14-13',
            "So now we have completely separated the exception and error code from the Args module. (See Listing <<14-13|5a:0>> through Listing <<14-16|5a:0>>.) This was achieved through a series of about 30 tiny steps, keeping the tests passing between each step.
Listing <<14-13|5a:0>> ArgsTest.java
package com.objectmentor.utilities.args;
import junit.framework.TestCase;
public class ArgsTest extends TestCase {
public void testCreateWithNoSchemaOrArguments() throws Exception {
Args args = new Args(\x{201c}\x{201d}, new String[0]);
assertEquals(0, args.cardinality());
}
public void testWithNoSchemaButWithOneArgument() throws Exception {
try {
new Args(\x{201c}\x{201d}, new String[]{\x{201c}-x\x{201d}});
fail();
} catch (ArgsException e) {
assertEquals(ArgsException.ErrorCode.UNEXPECTED_ARGUMENT,
e.getErrorCode());
assertEquals(\x{2018}x\x{2019}, e.getErrorArgumentId());
}
}
public void testWithNoSchemaButWithMultipleArguments() throws Exception {
try {
new Args(\x{201c}\x{201d}, new String[]{\x{201c}-x\x{201d}, \x{201c}-y\x{201d}});
fail();
} catch (ArgsException e) {
assertEquals(ArgsException.ErrorCode.UNEXPECTED_ARGUMENT,
e.getErrorCode());
assertEquals(\x{2018}x\x{2019}, e.getErrorArgumentId());
}
}
public void testNonLetterSchema() throws Exception {
try {
new Args(\x{201c}*\x{201d}, new String[]{});
fail(\x{201c}Args constructor should have thrown exception\x{201d});
} catch (ArgsException e) {
assertEquals(ArgsException.ErrorCode.INVALID_ARGUMENT_NAME,
e.getErrorCode());
assertEquals(\x{2018}*\x{2019}, e.getErrorArgumentId());
}
}
public void testInvalidArgumentFormat() throws Exception {
try {
new Args(\x{201c}f~\x{201d}, new String[]{});
fail(\x{201c}Args constructor should have throws exception\x{201d});
} catch (ArgsException e) {
assertEquals(ArgsException.ErrorCode.INVALID_FORMAT, e.getErrorCode());
assertEquals(\x{2018}f\x{2019}, e.getErrorArgumentId());
}
}
public void testSimpleBooleanPresent() throws Exception {
Args args = new Args(\x{201c}x\x{201d}, new String[]{\x{201c}-x\x{201d}});
assertEquals(1, args.cardinality());
assertEquals(true, args.getBoolean(\x{2018}x\x{2019}));
}
public void testSimpleStringPresent() throws Exception {
Args args = new Args(\x{201c}x*\x{201d}, new String[]{\x{201c}-x\x{201d}, \x{201c}param\x{201d}});
assertEquals(1, args.cardinality());
assertTrue(args.has(\x{2018}x\x{2019}));
assertEquals(\x{201c}param\x{201d}, args.getString(\x{2018}x\x{2019}));
}
public void testMissingStringArgument() throws Exception {
try {
new Args(\x{201c}x*\x{201d}, new String[]{\x{201c}-x\x{201d}});
fail();
} catch (ArgsException e) {
assertEquals(ArgsException.ErrorCode.MISSING_STRING, e.getErrorCode());
assertEquals(\x{2018}x\x{2019}, e.getErrorArgumentId());
}
}
public void testSpacesInFormat() throws Exception {
Args args = new Args(\x{201c}x, y\x{201d}, new String[]{\x{201c}-xy\x{201d}});
assertEquals(2, args.cardinality());
assertTrue(args.has(\x{2018}x\x{2019}));
assertTrue(args.has(\x{2018}y\x{2019}));
}
public void testSimpleIntPresent() throws Exception {
Args args = new Args(\x{201c}x#\x{201d}, new String[]{\x{201c}-x\x{201d}, \x{201c}42\x{201d}});
assertEquals(1, args.cardinality());
assertTrue(args.has(\x{2018}x\x{2019}));
assertEquals(42, args.getInt(\x{2018}x\x{2019}));
}
public void testInvalidInteger() throws Exception {
try {
new Args(\x{201c}x#\x{201d}, new String[]{\x{201c}-x\x{201d}, \x{201c}Forty two\x{201d}});
fail();
} catch (ArgsException e) {
assertEquals(ArgsException.ErrorCode.INVALID_INTEGER, e.getErrorCode());
assertEquals(\x{2018}x\x{2019}, e.getErrorArgumentId());
assertEquals(\x{201d}Forty two\x{201d}, e.getErrorParameter());
}
}
public void testMissingInteger() throws Exception {
try {
new Args(\x{201c}x#\x{201d}, new String[]{\x{201c}-x\x{201d}});
fail();
} catch (ArgsException e) {
assertEquals(ArgsException.ErrorCode.MISSING_INTEGER, e.getErrorCode());
assertEquals(\x{2018}x\x{2019}, e.getErrorArgumentId());
}
}
public void testSimpleDoublePresent() throws Exception {
Args args = new Args(\x{201c}x##\x{201d}, new String[]{\x{201c}-x\x{201d}, \x{201c}42.3\x{201d}});
assertEquals(1, args.cardinality());
assertTrue(args.has(\x{2018}x\x{2019}));
assertEquals(42.3, args.getDouble(\x{2018}x\x{2019}), .001);
}
public void testInvalidDouble() throws Exception {
try {
new Args(\x{201c}x##\x{201d}, new String[]{\x{201c}-x\x{201d}, \x{201c}Forty two\x{201d}});
fail();
} catch (ArgsException e) {
assertEquals(ArgsException.ErrorCode.INVALID_DOUBLE, e.getErrorCode());
assertEquals(\x{2018}x\x{2019}, e.getErrorArgumentId());
assertEquals(\x{201c}Forty two\x{201d}, e.getErrorParameter());
}
}
public void testMissingDouble() throws Exception {
try {
new Args(\x{201c}x##\x{201d}, new String[]{\x{201c}-x\x{201d}});
fail();
} catch (ArgsException e) {
assertEquals(ArgsException.ErrorCode.MISSING_DOUBLE, e.getErrorCode());
assertEquals(\x{2018}x\x{2019}, e.getErrorArgumentId());
}
}
}",
          ],
          [
            1,
            '[14:14] The Robert C. Martin Clean Code Collection - Robert C. Martin.epub (The_Robert_C._Martin_Clean_Code_split_023.html) - 14-14',
            "package com.objectmentor.utilities.args;
import junit.framework.TestCase;
public class ArgsTest extends TestCase {
public void testCreateWithNoSchemaOrArguments() throws Exception {
Args args = new Args(\x{201c}\x{201d}, new String[0]);
assertEquals(0, args.cardinality());
}
public void testWithNoSchemaButWithOneArgument() throws Exception {
try {
new Args(\x{201c}\x{201d}, new String[]{\x{201c}-x\x{201d}});
fail();
} catch (ArgsException e) {
assertEquals(ArgsException.ErrorCode.UNEXPECTED_ARGUMENT,
e.getErrorCode());
assertEquals(\x{2018}x\x{2019}, e.getErrorArgumentId());
}
}
public void testWithNoSchemaButWithMultipleArguments() throws Exception {
try {
new Args(\x{201c}\x{201d}, new String[]{\x{201c}-x\x{201d}, \x{201c}-y\x{201d}});
fail();
} catch (ArgsException e) {
assertEquals(ArgsException.ErrorCode.UNEXPECTED_ARGUMENT,
e.getErrorCode());
assertEquals(\x{2018}x\x{2019}, e.getErrorArgumentId());
}
}
public void testNonLetterSchema() throws Exception {
try {
new Args(\x{201c}*\x{201d}, new String[]{});
fail(\x{201c}Args constructor should have thrown exception\x{201d});
} catch (ArgsException e) {
assertEquals(ArgsException.ErrorCode.INVALID_ARGUMENT_NAME,
e.getErrorCode());
assertEquals(\x{2018}*\x{2019}, e.getErrorArgumentId());
}
}
public void testInvalidArgumentFormat() throws Exception {
try {
new Args(\x{201c}f~\x{201d}, new String[]{});
fail(\x{201c}Args constructor should have throws exception\x{201d});
} catch (ArgsException e) {
assertEquals(ArgsException.ErrorCode.INVALID_FORMAT, e.getErrorCode());
assertEquals(\x{2018}f\x{2019}, e.getErrorArgumentId());
}
}
public void testSimpleBooleanPresent() throws Exception {
Args args = new Args(\x{201c}x\x{201d}, new String[]{\x{201c}-x\x{201d}});
assertEquals(1, args.cardinality());
assertEquals(true, args.getBoolean(\x{2018}x\x{2019}));
}
public void testSimpleStringPresent() throws Exception {
Args args = new Args(\x{201c}x*\x{201d}, new String[]{\x{201c}-x\x{201d}, \x{201c}param\x{201d}});
assertEquals(1, args.cardinality());
assertTrue(args.has(\x{2018}x\x{2019}));
assertEquals(\x{201c}param\x{201d}, args.getString(\x{2018}x\x{2019}));
}
public void testMissingStringArgument() throws Exception {
try {
new Args(\x{201c}x*\x{201d}, new String[]{\x{201c}-x\x{201d}});
fail();
} catch (ArgsException e) {
assertEquals(ArgsException.ErrorCode.MISSING_STRING, e.getErrorCode());
assertEquals(\x{2018}x\x{2019}, e.getErrorArgumentId());
}
}
public void testSpacesInFormat() throws Exception {
Args args = new Args(\x{201c}x, y\x{201d}, new String[]{\x{201c}-xy\x{201d}});
assertEquals(2, args.cardinality());
assertTrue(args.has(\x{2018}x\x{2019}));
assertTrue(args.has(\x{2018}y\x{2019}));
}
public void testSimpleIntPresent() throws Exception {
Args args = new Args(\x{201c}x#\x{201d}, new String[]{\x{201c}-x\x{201d}, \x{201c}42\x{201d}});
assertEquals(1, args.cardinality());
assertTrue(args.has(\x{2018}x\x{2019}));
assertEquals(42, args.getInt(\x{2018}x\x{2019}));
}
public void testInvalidInteger() throws Exception {
try {
new Args(\x{201c}x#\x{201d}, new String[]{\x{201c}-x\x{201d}, \x{201c}Forty two\x{201d}});
fail();
} catch (ArgsException e) {
assertEquals(ArgsException.ErrorCode.INVALID_INTEGER, e.getErrorCode());
assertEquals(\x{2018}x\x{2019}, e.getErrorArgumentId());
assertEquals(\x{201d}Forty two\x{201d}, e.getErrorParameter());
}
}
public void testMissingInteger() throws Exception {
try {
new Args(\x{201c}x#\x{201d}, new String[]{\x{201c}-x\x{201d}});
fail();
} catch (ArgsException e) {
assertEquals(ArgsException.ErrorCode.MISSING_INTEGER, e.getErrorCode());
assertEquals(\x{2018}x\x{2019}, e.getErrorArgumentId());
}
}
public void testSimpleDoublePresent() throws Exception {
Args args = new Args(\x{201c}x##\x{201d}, new String[]{\x{201c}-x\x{201d}, \x{201c}42.3\x{201d}});
assertEquals(1, args.cardinality());
assertTrue(args.has(\x{2018}x\x{2019}));
assertEquals(42.3, args.getDouble(\x{2018}x\x{2019}), .001);
}
public void testInvalidDouble() throws Exception {
try {
new Args(\x{201c}x##\x{201d}, new String[]{\x{201c}-x\x{201d}, \x{201c}Forty two\x{201d}});
fail();
} catch (ArgsException e) {
assertEquals(ArgsException.ErrorCode.INVALID_DOUBLE, e.getErrorCode());
assertEquals(\x{2018}x\x{2019}, e.getErrorArgumentId());
assertEquals(\x{201c}Forty two\x{201d}, e.getErrorParameter());
}
}
public void testMissingDouble() throws Exception {
try {
new Args(\x{201c}x##\x{201d}, new String[]{\x{201c}-x\x{201d}});
fail();
} catch (ArgsException e) {
assertEquals(ArgsException.ErrorCode.MISSING_DOUBLE, e.getErrorCode());
assertEquals(\x{2018}x\x{2019}, e.getErrorArgumentId());
}
}
}
Listing <<14-14|5a:0>> ArgsExceptionTest.java
public class ArgsExceptionTest extends TestCase {
public void testUnexpectedMessage() throws Exception {
ArgsException e =
new ArgsException(ArgsException.ErrorCode.UNEXPECTED_ARGUMENT,
\x{2018}x\x{2019}, null);
assertEquals(\x{201c}Argument -x unexpected.\x{201d}, e.errorMessage());
}
public void testMissingStringMessage() throws Exception {
ArgsException e = new ArgsException(ArgsException.ErrorCode.MISSING_STRING,
\x{2018}x\x{2019}, null);
assertEquals(\x{201c}Could not find string parameter for -x.\x{201d}, e.errorMessage());
}
public void testInvalidIntegerMessage() throws Exception {
ArgsException e =
new ArgsException(ArgsException.ErrorCode.INVALID_INTEGER,
\x{2018}x\x{2019}, \x{201c}Forty two\x{201d});
assertEquals(\x{201c}Argument -x expects an integer but was \x{2018}Forty two\x{2019}.\x{201c},
e.errorMessage());
}
public void testMissingIntegerMessage() throws Exception {
ArgsException e =
new ArgsException(ArgsException.ErrorCode.MISSING_INTEGER, \x{2018}x\x{2019}, null);
assertEquals(\x{201c}Could not find integer parameter for -x.\x{201d}, e.errorMessage());
}
public void testInvalidDoubleMessage() throws Exception {
ArgsException e = new ArgsException(ArgsException.ErrorCode.INVALID_DOUBLE,
\x{2018}x\x{2019}, \x{201c}Forty two\x{201d});
assertEquals(\x{201c}Argument -x expects a double but was \x{2018}Forty two\x{2019}.\x{201d},
e.errorMessage());
}
public void testMissingDoubleMessage() throws Exception {
ArgsException e = new ArgsException(ArgsException.ErrorCode.MISSING_DOUBLE,
\x{2018}x\x{2019}, null);
assertEquals(\x{201c}Could not find double parameter for -x.\x{201d}, e.errorMessage());
}
}",
          ],
          [
            1,
            '[14:15] The Robert C. Martin Clean Code Collection - Robert C. Martin.epub (The_Robert_C._Martin_Clean_Code_split_023.html) - 14-15',
            "public class ArgsExceptionTest extends TestCase {
public void testUnexpectedMessage() throws Exception {
ArgsException e =
new ArgsException(ArgsException.ErrorCode.UNEXPECTED_ARGUMENT,
\x{2018}x\x{2019}, null);
assertEquals(\x{201c}Argument -x unexpected.\x{201d}, e.errorMessage());
}
public void testMissingStringMessage() throws Exception {
ArgsException e = new ArgsException(ArgsException.ErrorCode.MISSING_STRING,
\x{2018}x\x{2019}, null);
assertEquals(\x{201c}Could not find string parameter for -x.\x{201d}, e.errorMessage());
}
public void testInvalidIntegerMessage() throws Exception {
ArgsException e =
new ArgsException(ArgsException.ErrorCode.INVALID_INTEGER,
\x{2018}x\x{2019}, \x{201c}Forty two\x{201d});
assertEquals(\x{201c}Argument -x expects an integer but was \x{2018}Forty two\x{2019}.\x{201c},
e.errorMessage());
}
public void testMissingIntegerMessage() throws Exception {
ArgsException e =
new ArgsException(ArgsException.ErrorCode.MISSING_INTEGER, \x{2018}x\x{2019}, null);
assertEquals(\x{201c}Could not find integer parameter for -x.\x{201d}, e.errorMessage());
}
public void testInvalidDoubleMessage() throws Exception {
ArgsException e = new ArgsException(ArgsException.ErrorCode.INVALID_DOUBLE,
\x{2018}x\x{2019}, \x{201c}Forty two\x{201d});
assertEquals(\x{201c}Argument -x expects a double but was \x{2018}Forty two\x{2019}.\x{201d},
e.errorMessage());
}
public void testMissingDoubleMessage() throws Exception {
ArgsException e = new ArgsException(ArgsException.ErrorCode.MISSING_DOUBLE,
\x{2018}x\x{2019}, null);
assertEquals(\x{201c}Could not find double parameter for -x.\x{201d}, e.errorMessage());
}
}
Listing <<14-15|5a:0>> ArgsException.java
public class ArgsException extends Exception {
private char errorArgumentId = \x{2018}\\0\x{2019};
private String errorParameter = \x{201c}TILT\x{201d};
private ErrorCode errorCode = ErrorCode.OK;
public ArgsException() {}
public ArgsException(String message) {super(message);}
public ArgsException(ErrorCode errorCode) {
this.errorCode = errorCode;
}
public ArgsException(ErrorCode errorCode, String errorParameter) {
this.errorCode = errorCode;
this.errorParameter = errorParameter;
}
public ArgsException(ErrorCode errorCode, char errorArgumentId,
String errorParameter) {
this.errorCode = errorCode;
this.errorParameter = errorParameter;
this.errorArgumentId = errorArgumentId;
}
public char getErrorArgumentId() {
return errorArgumentId;
}
public void setErrorArgumentId(char errorArgumentId) {
this.errorArgumentId = errorArgumentId;
}
public String getErrorParameter() {
return errorParameter;
}
public void setErrorParameter(String errorParameter) {
this.errorParameter = errorParameter;
}
public ErrorCode getErrorCode() {
return errorCode;
}
public void setErrorCode(ErrorCode errorCode) {
this.errorCode = errorCode;
}
public String errorMessage() throws Exception {
switch (errorCode) {
case OK:
throw new Exception(\x{201c}TILT: Should not get here.\x{201d});
case UNEXPECTED_ARGUMENT:
return String.format(\x{201c}Argument -%c unexpected.\x{201d}, errorArgumentId);
case MISSING_STRING:
return String.format(\x{201c}Could not find string parameter for -%c.\x{201d},
errorArgumentId);
case INVALID_INTEGER:
return String.format(\x{201c}Argument -%c expects an integer but was \x{2018}%s\x{2019}.\x{201d},
errorArgumentId, errorParameter);
case MISSING_INTEGER:
return String.format(\x{201c}Could not find integer parameter for -%c.\x{201d},
errorArgumentId);
case INVALID_DOUBLE:
return String.format(\x{201c}Argument -%c expects a double but was \x{2018}%s\x{2019}.\x{201d},
errorArgumentId, errorParameter);
case MISSING_DOUBLE:
return String.format(\x{201c}Could not find double parameter for -%c.\x{201d},
errorArgumentId);
}
return \x{201c}\x{201d};
}
public enum ErrorCode {
OK, INVALID_FORMAT, UNEXPECTED_ARGUMENT, INVALID_ARGUMENT_NAME,
MISSING_STRING,
MISSING_INTEGER, INVALID_INTEGER,
MISSING_DOUBLE, INVALID_DOUBLE}
}",
          ],
          [
            1,
            '[14:16] The Robert C. Martin Clean Code Collection - Robert C. Martin.epub (The_Robert_C._Martin_Clean_Code_split_023.html) - 14-16',
            "public class ArgsException extends Exception {
private char errorArgumentId = \x{2018}\\0\x{2019};
private String errorParameter = \x{201c}TILT\x{201d};
private ErrorCode errorCode = ErrorCode.OK;
public ArgsException() {}
public ArgsException(String message) {super(message);}
public ArgsException(ErrorCode errorCode) {
this.errorCode = errorCode;
}
public ArgsException(ErrorCode errorCode, String errorParameter) {
this.errorCode = errorCode;
this.errorParameter = errorParameter;
}
public ArgsException(ErrorCode errorCode, char errorArgumentId,
String errorParameter) {
this.errorCode = errorCode;
this.errorParameter = errorParameter;
this.errorArgumentId = errorArgumentId;
}
public char getErrorArgumentId() {
return errorArgumentId;
}
public void setErrorArgumentId(char errorArgumentId) {
this.errorArgumentId = errorArgumentId;
}
public String getErrorParameter() {
return errorParameter;
}
public void setErrorParameter(String errorParameter) {
this.errorParameter = errorParameter;
}
public ErrorCode getErrorCode() {
return errorCode;
}
public void setErrorCode(ErrorCode errorCode) {
this.errorCode = errorCode;
}
public String errorMessage() throws Exception {
switch (errorCode) {
case OK:
throw new Exception(\x{201c}TILT: Should not get here.\x{201d});
case UNEXPECTED_ARGUMENT:
return String.format(\x{201c}Argument -%c unexpected.\x{201d}, errorArgumentId);
case MISSING_STRING:
return String.format(\x{201c}Could not find string parameter for -%c.\x{201d},
errorArgumentId);
case INVALID_INTEGER:
return String.format(\x{201c}Argument -%c expects an integer but was \x{2018}%s\x{2019}.\x{201d},
errorArgumentId, errorParameter);
case MISSING_INTEGER:
return String.format(\x{201c}Could not find integer parameter for -%c.\x{201d},
errorArgumentId);
case INVALID_DOUBLE:
return String.format(\x{201c}Argument -%c expects a double but was \x{2018}%s\x{2019}.\x{201d},
errorArgumentId, errorParameter);
case MISSING_DOUBLE:
return String.format(\x{201c}Could not find double parameter for -%c.\x{201d},
errorArgumentId);
}
return \x{201c}\x{201d};
}
public enum ErrorCode {
OK, INVALID_FORMAT, UNEXPECTED_ARGUMENT, INVALID_ARGUMENT_NAME,
MISSING_STRING,
MISSING_INTEGER, INVALID_INTEGER,
MISSING_DOUBLE, INVALID_DOUBLE}
}
Listing <<14-16|5a:0>> Args.java
public class Args {
private String schema;
private Map<Character, ArgumentMarshaler> marshalers =
new HashMap<Character, ArgumentMarshaler>();
private Set<Character> argsFound = new HashSet<Character>();
private Iterator<String> currentArgument;
private List<String> argsList;
public Args(String schema, String[] args) throws ArgsException {
this.schema = schema;
argsList = Arrays.asList(args);
parse();
}
private void parse() throws ArgsException {
parseSchema();
parseArguments();
}
private boolean parseSchema() throws ArgsException {
for (String element : schema.split(\x{201c},\x{201d})) {
if (element.length() > 0) {
parseSchemaElement(element.trim());
}
}
return true;
}
private void parseSchemaElement(String element) throws ArgsException {
char elementId = element.charAt(0);
String elementTail = element.substring(1);
validateSchemaElementId(elementId);
if (elementTail.length() == 0)
marshalers.put(elementId, new BooleanArgumentMarshaler());
else if (elementTail.equals(\x{201c}*\x{201d}))
marshalers.put(elementId, new StringArgumentMarshaler());
else if (elementTail.equals(\x{201c}#\x{201d}))
marshalers.put(elementId, new IntegerArgumentMarshaler());
else if (elementTail.equals(\x{201c}##\x{201d}))
marshalers.put(elementId, new DoubleArgumentMarshaler());
else
throw new ArgsException(ArgsException.ErrorCode.INVALID_FORMAT,
elementId, elementTail);
}
private void validateSchemaElementId(char elementId) throws ArgsException {
if (!Character.isLetter(elementId)) {
throw new ArgsException(ArgsException.ErrorCode.INVALID_ARGUMENT_NAME,
elementId, null);
}
}
private void parseArguments() throws ArgsException {
for (currentArgument = argsList.iterator(); currentArgument.hasNext();) {
String arg = currentArgument.next();
parseArgument(arg);
}
}
private void parseArgument(String arg) throws ArgsException {
if (arg.startsWith(\x{201c}-\x{201d}))
parseElements(arg);
}
private void parseElements(String arg) throws ArgsException {
for (int i = 1; i < arg.length(); i++)
parseElement(arg.charAt(i));
}
private void parseElement(char argChar) throws ArgsException {
if (setArgument(argChar))
argsFound.add(argChar);
else {
throw new ArgsException(ArgsException.ErrorCode.UNEXPECTED_ARGUMENT,
argChar, null);
}
}
private boolean setArgument(char argChar) throws ArgsException {
ArgumentMarshaler m = marshalers.get(argChar);
if (m == null)
return false;
try {
m.set(currentArgument);
return true;
} catch (ArgsException e) {
e.setErrorArgumentId(argChar);
throw e;
}
}
public int cardinality() {
return argsFound.size();
}
public String usage() {
if (schema.length() > 0)
return \x{201c}-[\x{201d} + schema + \x{201c}]\x{201d};
else
return \x{201c}\x{201d};
}
public boolean getBoolean(char arg) {
ArgumentMarshaler am = marshalers.get(arg);
boolean b = false;
try {
b = am != null && (Boolean) am.get();
} catch (ClassCastException e) {
b = false;
}
return b;
}
public String getString(char arg) {
ArgumentMarshaler am = marshalers.get(arg);
try {
return am == null ? \x{201c}\x{201d} : (String) am.get();
} catch (ClassCastException e) {
return \x{201c}\x{201d};
}
}
public int getInt(char arg) {
ArgumentMarshaler am = marshalers.get(arg);
try {
return am == null ? 0 : (Integer) am.get();
} catch (Exception e) {
return 0;
}
}
public double getDouble(char arg) {
ArgumentMarshaler am = marshalers.get(arg);
try {
return am == null ? 0 : (Double) am.get();
} catch (Exception e) {
return 0.0;
}
}
public boolean has(char arg) {
return argsFound.contains(arg);
}
}",
          ],
          [
            1,
            '[ap 03:14] The Robert C. Martin Clean Code Collection - Robert C. Martin.epub (The_Robert_C._Martin_Clean_Code_split_026.html) - 3.14',
            "Constants like 3.141592653589793 are also very well known and easily recognizable. However, the chance for error is too great to leave them raw. Every time someone sees 3.1415927535890793, they know that it is \x{3c0}, and so they fail to scrutinize it. (Did you catch the single-digit error?) We also don\x{2019}t want people using <<3.14|5a:0>>, 3.14159, 3.142, and so forth. Therefore, it is a good thing that Math.PI has already been defined for us.",
          ],
          [
            1,
            '[00:00] The Robert C. Martin Clean Code Collection - Robert C. Martin.epub (The_Robert_C._Martin_Clean_Code_split_027.html) - midnight',
            "Sometimes you can set things up such that the failure causes no harm. For example, the above client could catch the exception and clean up. Frankly, this is a bit sloppy. It\x{2019}s rather like cleaning up memory leaks by rebooting at <<midnight|13>>.",
          ],
          [
            1,
            "[13:14] The Robert C. Martin Clean Code Collection - Robert C. Martin.epub (The_Robert_C._Martin_Clean_Code_split_031.html) - 13\x{2013}14",
            "authors of JUnit, 252
programmers as, <<13\x{2013}14|5a:0>>
authorship statements, 55",
          ],
          [
            1,
            '[ap 01:32] The Robert C. Martin Clean Code Collection - Robert C. Martin.epub (The_Robert_C._Martin_Clean_Code_split_031.html) - 132',
            'boolean arguments, 194, 288
boolean map, deleting, 224
boolean output, of tests, <<132|9l:0>>',
          ],
          [
            1,
            "[14:15] The Robert C. Martin Clean Code Collection - Robert C. Martin.epub (The_Robert_C._Martin_Clean_Code_split_031.html) - 14\x{2013}15",
            "boundary tests, easing a migration, 118 \x{201c}Bowling Game\x{201d}, 312
Boy Scout Rule, <<14\x{2013}15|5a:0>>, 257
following, 284",
          ],
          [
            1,
            "[ap 07:12] The Robert C. Martin Clean Code Collection - Robert C. Martin.epub (The_Robert_C._Martin_Clean_Code_split_031.html) - 7\x{2013}12",
            "art of, 6\x{2013}7
described, <<7\x{2013}12|5a:0>>
writing, 6\x{2013}7",
          ],
          [
            1,
            "[14:15] The Robert C. Martin Clean Code Collection - Robert C. Martin.epub (The_Robert_C._Martin_Clean_Code_split_031.html) - 14\x{2013}15",
            "tied to tests, 9
cleanup, of code, <<14\x{2013}15|5a:0>>
clever names, 26",
          ],
          [
            1,
            "[18:19] The Robert C. Martin Clean Code Collection - Robert C. Martin.epub (The_Robert_C._Martin_Clean_Code_split_031.html) - 18\x{2013}19",
            "formatting of, 76
implicity of, <<18\x{2013}19|5a:0>>
instrumenting, 188, 342",
          ],
          [
            1,
            "[ap 11:12] The Robert C. Martin Clean Code Collection - Robert C. Martin.epub (The_Robert_C._Martin_Clean_Code_split_031.html) - 11\x{2013}12",
            "cross-cutting concerns, 160
Cunningham, Ward, <<11\x{2013}12|5a:0>>
cuteness, in code, 26",
          ],
          [
            1,
            "[19:20] The Robert C. Martin Clean Code Collection - Robert C. Martin.epub (The_Robert_C._Martin_Clean_Code_split_031.html) - 19\x{2013}20",
            "dirty tests, 123
disinformation, avoiding, <<19\x{2013}20|5a:0>>
distance, vertical in code, 80\x{2013}84",
          ],
          [
            1,
            "[20:21] The Robert C. Martin Clean Code Collection - Robert C. Martin.epub (The_Robert_C._Martin_Clean_Code_split_031.html) - 20\x{2013}21",
            "distance, vertical in code, 80\x{2013}84
distinctions, making meaningful, <<20\x{2013}21|5a:0>>
domain-specific languages (DSLs), 168\x{2013}169",
          ],
          [
            1,
            "[13:14] The Robert C. Martin Clean Code Collection - Robert C. Martin.epub (The_Robert_C._Martin_Clean_Code_split_031.html) - 13\x{2013}14",
            "Eclipse, 26
edit sessions, playing back, <<13\x{2013}14|5a:0>>
efficiency, of code, 7",
          ],
          [
            1,
            "[23:24] The Robert C. Martin Clean Code Collection - Robert C. Martin.epub (The_Robert_C._Martin_Clean_Code_split_031.html) - 23\x{2013}24",
            "of conditionals, 301
encodings, avoiding, <<23\x{2013}24|5a:0>>, 312\x{2013}313
entity bean, 158\x{2013}160",
          ],
          [
            1,
            "[ap 10:11] The Robert C. Martin Clean Code Collection - Robert C. Martin.epub (The_Robert_C._Martin_Clean_Code_split_031.html) - 10\x{2013}11",
            "expressiveness
in code, <<10\x{2013}11|5a:0>>
ensuring, 175\x{2013}176",
          ],
          [
            1,
            "[23:24] The Robert C. Martin Clean Code Collection - Robert C. Martin.epub (The_Robert_C._Martin_Clean_Code_split_031.html) - 23\x{2013}24",
            "HTML, in source code, 69
Hungarian Notation (HN), <<23\x{2013}24|5a:0>>, 295
Hunt, Andy, 8, 289",
          ],
          [
            1,
            "[18:19] The Robert C. Martin Clean Code Collection - Robert C. Martin.epub (The_Robert_C._Martin_Clean_Code_split_031.html) - 18\x{2013}19",
            "intention-revealing function, 19
intention-revealing names, <<18\x{2013}19|5a:0>>
interface(s)",
          ],
          [
            1,
            "[ap 10:11] The Robert C. Martin Clean Code Collection - Robert C. Martin.epub (The_Robert_C._Martin_Clean_Code_split_031.html) - 10\x{2013}11",
            "JDK proxy, providing persistence support, 161\x{2013}163
Jeffries, Ron, <<10\x{2013}11|5a:0>>, 289
jiggling strategies, 190",
          ],
          [
            1,
            "[ap 04:12] The Robert C. Martin Clean Code Collection - Robert C. Martin.epub (The_Robert_C._Martin_Clean_Code_split_031.html) - 4\x{2013}12",
            "mental mapping, avoiding, 25
messy code. See also bad code; dirty code total cost of owning, <<4\x{2013}12|5a:0>>
method invocations, <<324|9l:0>>",
          ],
          [
            1,
            "[18:19] The Robert C. Martin Clean Code Collection - Robert C. Martin.epub (The_Robert_C._Martin_Clean_Code_split_031.html) - 18\x{2013}19",
            "importance of, 309\x{2013}310
intention-revealing, <<18\x{2013}19|5a:0>>
length of corresponding to scope, 22\x{2013}23",
          ],
          [
            1,
            "[18:19] The Robert C. Martin Clean Code Collection - Robert C. Martin.epub (The_Robert_C._Martin_Clean_Code_split_031.html) - 18\x{2013}19",
            "intention-revealing, <<18\x{2013}19|5a:0>>
length of corresponding to scope, <<22\x{2013}23|5a:0>>
long names for long scopes, 312",
          ],
          [
            1,
            "[21:22] The Robert C. Martin Clean Code Collection - Robert C. Martin.epub (The_Robert_C._Martin_Clean_Code_split_031.html) - 21\x{2013}22",
            "problem domain, 27
pronounceable, <<21\x{2013}22|5a:0>>
rules for creating, 18\x{2013}30",
          ],
          [
            1,
            "[21:22] The Robert C. Martin Clean Code Collection - Robert C. Martin.epub (The_Robert_C._Martin_Clean_Code_split_031.html) - 21\x{2013}22",
            "pronounceable, <<21\x{2013}22|5a:0>>
rules for creating, 18\x{2013}30
searchable, 22\x{2013}23",
          ],
          [
            1,
            "[18:30] The Robert C. Martin Clean Code Collection - Robert C. Martin.epub (The_Robert_C._Martin_Clean_Code_split_031.html) - 18\x{2013}30",
            "rules for creating, <<18\x{2013}30|5a:0>>
searchable, 22\x{2013}23
shorter generally better than longer, 30",
          ],
          [
            1,
            "[13:14] The Robert C. Martin Clean Code Collection - Robert C. Martin.epub (The_Robert_C._Martin_Clean_Code_split_031.html) - 13\x{2013}14",
            "programmers
as authors, <<13\x{2013}14|5a:0>>
conundrum faced by, 6",
          ],
          [
            1,
            "[21:22] The Robert C. Martin Clean Code Collection - Robert C. Martin.epub (The_Robert_C._Martin_Clean_Code_split_031.html) - 21\x{2013}22",
            "programs, getting them to work, 201
pronounceable names, <<21\x{2013}22|5a:0>>
protected variables, avoiding, 80",
          ],
          [
            1,
            "[13:14] The Robert C. Martin Clean Code Collection - Robert C. Martin.epub (The_Robert_C._Martin_Clean_Code_split_031.html) - 13\x{2013}14",
            "readers
of code, <<13\x{2013}14|5a:0>>
continuous, 184",
          ],
          [
            1,
            "[ap 00:13] The Robert C. Martin Clean Code Collection - Robert C. Martin.epub (The_Robert_C._Martin_Clean_Code_split_031.html) - 12\x{2013}13",
            "schema, of a class, 194
schools of thought, about clean code, <<12\x{2013}13|5a:0>>
scissors rule, in C++, 81",
          ],
          [
            1,
            "[22:23] The Robert C. Martin Clean Code Collection - Robert C. Martin.epub (The_Robert_C._Martin_Clean_Code_split_031.html) - 22\x{2013}23",
            "limiting for data, 181
names related to the length of, <<22\x{2013}23|5a:0>>, 312
of shared variables, 333",
          ],
          [
            1,
            '[13:00] The Robert C. Martin Clean Code Collection - Robert C. Martin.epub (The_Robert_C._Martin_Clean_Code_split_037.html) - 1:00 PM',
            'It was Friday at <<1:00 PM|2a>>; the web site was set to go live very early the following Monday.',
          ],
          [
            1,
            '[11:39] The Robert C. Martin Clean Code Collection - Robert C. Martin.epub (The_Robert_C._Martin_Clean_Code_split_038.html) - 11:39 AM',
            "At <<11:39 AM|2a>> EST on January 28, 1986, just 73.124 seconds after launch and at an altitude of 48,000 feet, the Space Shuttle Challenger was torn to smithereens by the failure of the right-hand solid rocket booster (SRB). Seven brave astronauts, including high school teacher Christa McAuliffe, were lost. The expression on the face of McAuliffe\x{2019}s mother as she watched the demise of her daughter nine miles overhead haunts me to this day.",
          ],
          [
            1,
            '[ap 01:00] The Robert C. Martin Clean Code Collection - Robert C. Martin.epub (The_Robert_C._Martin_Clean_Code_split_042.html) - 1',
            'The program was simply to read records from a tape, and replace the IDs of those records with new IDs. The new IDs started at <<1|9c:0>> and were incremented by 1 for each new record. The records with the new IDs were to be written to a new tape.',
          ],
          [
            1,
            '[03:00] The Robert C. Martin Clean Code Collection - Robert C. Martin.epub (The_Robert_C._Martin_Clean_Code_split_042.html) - 3 AM',
            "I stayed up till <<3 AM|5>> every night eating pizza and watching old monster movies on my parents\x{2019} old black-and-white, rabbit-ear TV. Only some of the ghosts where characters in the movies. I stayed in bed till <<1 PM|5>> because I didn\x{2019}t want to face my dreary days. I took a calculus course at a local community college and failed it. I was a wreck.",
          ],
          [
            1,
            '[12:00] The Robert C. Martin Clean Code Collection - Robert C. Martin.epub (The_Robert_C._Martin_Clean_Code_split_045.html) - noon',
            "\x{2022} If you set a meeting for <<noon|13>> at a cafe downtown with a colleague and you get stuck in traffic, you doubt you\x{2019}ll be able to follow through on your commitment to be there on time. You can call your colleague as soon as you realize you might be late, and let them know. Maybe you can find a closer place to meet, or perhaps postpone the meeting.",
          ],
          [
            1,
            '[03:00] The Robert C. Martin Clean Code Collection - Robert C. Martin.epub (The_Robert_C._Martin_Clean_Code_split_046.html) - 3 AM',
            "If you are tired or distracted, do not code. You\x{2019}ll only wind up redoing what you did. Instead, find a way to eliminate the distractions and settle your mind.
<<3 AM|5>> Code
The worst code I ever wrote was at <<3 AM|5>>. The year was 1988, and I was working at a telecommunications start-up named Clear Communications. We were all putting in long hours in order to build \x{201c}sweat equity.\x{201d} We were, of course, all dreaming of being rich.",
          ],
          [
            1,
            '[03:00] The Robert C. Martin Clean Code Collection - Robert C. Martin.epub (The_Robert_C._Martin_Clean_Code_split_046.html) - 3 AM',
            "The worst code I ever wrote was at <<3 AM|5>>. The year was 1988, and I was working at a telecommunications start-up named Clear Communications. We were all putting in long hours in order to build \x{201c}sweat equity.\x{201d} We were, of course, all dreaming of being rich.",
          ],
          [
            1,
            '[03:00] The Robert C. Martin Clean Code Collection - Robert C. Martin.epub (The_Robert_C._Martin_Clean_Code_split_046.html) - 3 AM',
            "One very late evening\x{2014}or rather, one very early morning, in order to solve a timing problem\x{2014}I had my code send a message to itself through the event dispatch system (we called this \x{201c}sending mail\x{201d}). This was the wrong solution, but at <<3 AM|5>> it looked pretty damned good. Indeed, after 18 hours of solid coding (not to mention the 60\x{2013}70 hour weeks) it was all I could think of.",
          ],
          [
            1,
            '[03:00] The Robert C. Martin Clean Code Collection - Robert C. Martin.epub (The_Robert_C._Martin_Clean_Code_split_046.html) - 3 AM',
            'I remember feeling so good about myself for the long hours I was working. I remember feeling dedicated. I remember thinking that working at <<3 AM|5>> is what serious professionals do. How wrong I was!',
          ],
          [
            1,
            '[03:00] The Robert C. Martin Clean Code Collection - Robert C. Martin.epub (The_Robert_C._Martin_Clean_Code_split_046.html) - 3 AM',
            "That code came back to bite us over and over again. It instituted a faulty design structure that everyone used but consistently had to work around. It caused all kinds of strange timing errors and odd feedback loops. We\x{2019}d get into infinite mail loops as one message caused another to be sent, and then another, infinitely. We never had time to rewrite this wad (so we thought) but we always seemed to have time to add another wart or patch to work around it. The cruft grew and grew, surrounding that <<3 AM|5>> code with ever more baggage and side effects. Years later it had become a team joke. Whenever I was tired or frustrated they\x{2019}d say, \x{201c}Look out! Bob\x{2019}s about to send mail to himself!\x{201d}",
          ],
          [
            1,
            '[12:00] The Robert C. Martin Clean Code Collection - Robert C. Martin.epub (The_Robert_C._Martin_Clean_Code_split_046.html) - noon',
            "Nowadays when I feel myself slipping into the Zone, I walk away for a few minutes. I clear my head by answering a few emails or looking at some tweets. If it\x{2019}s close enough to <<noon|13>>, I\x{2019}ll break for lunch. If I\x{2019}m working on a team, I\x{2019}ll find a pair partner.",
          ],
          [
            1,
            '[10:00] The Robert C. Martin Clean Code Collection - Robert C. Martin.epub (The_Robert_C._Martin_Clean_Code_split_046.html) - 10 AM',
            "This doesn\x{2019}t mean that you don\x{2019}t need some alone time. Of course you do. But you have to be fair and polite about it. For example, you can let it be known that between the hours of <<10 AM|5>> and <<noon|13>> you should not be bothered, but from <<1 PM|5>> to <<3 PM|5>> your door is open.",
          ],
          [
            1,
            '[12:00] The Robert C. Martin Clean Code Collection - Robert C. Martin.epub (The_Robert_C._Martin_Clean_Code_split_049.html) - Noon',
            "Sam: \x{201c}Any time.\x{201d}
Paula: \x{201c}<<Noon|13>>?\x{201d}
Sam: \x{201c}No, not during trading hours. <<Midnight|13>> would be better.\x{201d}",
          ],
          [
            1,
            '[12:00] The Robert C. Martin Clean Code Collection - Robert C. Martin.epub (The_Robert_C._Martin_Clean_Code_split_049.html) - Noon',
            "Paula: \x{201c}<<Noon|13>>?\x{201d}
Sam: \x{201c}No, not during trading hours. <<Midnight|13>> would be better.\x{201d}
Paula: \x{201c}OK, <<midnight|13>> then.\x{201d}",
          ],
          [
            1,
            '[00:00] The Robert C. Martin Clean Code Collection - Robert C. Martin.epub (The_Robert_C._Martin_Clean_Code_split_049.html) - Midnight',
            "Sam: \x{201c}No, not during trading hours. <<Midnight|13>> would be better.\x{201d}
Paula: \x{201c}OK, <<midnight|13>> then.\x{201d}
Sam: \x{201c}Great, thanks!\x{201d}",
          ],
          [
            1,
            '[00:00] The Robert C. Martin Clean Code Collection - Robert C. Martin.epub (The_Robert_C._Martin_Clean_Code_split_049.html) - midnight',
            "Paula: \x{201c}OK, we need to copy the log file into a sub-directory named backup every night at <<midnight|13>>.\x{201d}",
          ],
          [
            1,
            '[00:00] The Robert C. Martin Clean Code Collection - Robert C. Martin.epub (The_Robert_C._Martin_Clean_Code_split_049.html) - midnight',
            "Sam: \x{201c}Don\x{2019}t worry, I just spoke to Paula. She\x{2019}ll be saving the logs into a directory named backup every night at <<midnight|13>>.\x{201d}",
          ],
          [
            1,
            '[ap 02:57] The Robert C. Martin Clean Code Collection - Robert C. Martin.epub (The_Robert_C._Martin_Clean_Code_split_049.html) - 2.57',
            'execute 15 post transactions and accumulate times.
ensure that the Z score for 2 seconds is at least <<2.57|5a:0>>',
          ],
          [
            1,
            '[06:00] The Robert C. Martin Clean Code Collection - Robert C. Martin.epub (The_Robert_C._Martin_Clean_Code_split_051.html) - 6 AM',
            "\x{2022} I awoke at 5 every morning and rode my bicycle to the office in Bracknell by <<6 AM|5>>. That gave me hours of quiet time before the chaos of the day began.",
          ],
          [
            1,
            '[09:00] The Robert C. Martin Clean Code Collection - Robert C. Martin.epub (The_Robert_C._Martin_Clean_Code_split_051.html) - 9 AM',
            "\x{2022} I completely filled the first 3 hours of that schedule. Starting at <<9 AM|9g>> I started leaving one 15-minute gap per hour; that way I could quickly push most interruptions into one of those open slots and continue working.",
          ],
          [
            1,
            '[05:00] The Robert C. Martin Clean Code Collection - Robert C. Martin.epub (The_Robert_C._Martin_Clean_Code_split_051.html) - 5 AM',
            'This scheme did not always succeed. Waking up at <<5 AM|5>> was not always feasible, and sometimes the chaos broke through all my careful strategies and consumed my day. But for the most part I was able to keep my head above water.',
          ],
          [
            1,
            '[ap 03:24] The Robert C. Martin Clean Code Collection - Robert C. Martin.epub (The_Robert_C._Martin_Clean_Code_split_052.html) - 3.24',
            "The standard deviation of the sequence is the square root of the sum of the squares of the standard deviations of the tasks. So the standard deviation for all three of Peter\x{2019}s tasks is about 3.
(1.8 + 2.2 + 1.3) =
(<<3.24|5a:0>> + <<2.48|5a:0>> + 1.69) =
9.77 = ~ <<3.13|5a:0>>
This tells Mike that Peter\x{2019}s tasks will likely take 14 days, but could very well take 17 days (1\x{3c3}) and could possibly even take 20 days (2\x{3c3}). It could even take longer, but that\x{2019}s pretty unlikely.",
          ],
          [
            1,
            '[ap 05:00] The Robert C. Martin Clean Code Collection - Robert C. Martin.epub (The_Robert_C._Martin_Clean_Code_split_052.html) - 0 to 5',
            'Everybody sits around a table. Tasks are discussed one at a time. For each task there is discussion about what the task involves, what might confound or complicate it, and how it might be implemented. Then the participants put their hands below the table and raise <<0 to 5|10a:0>> fingers based on how long they think the task will take. The moderator counts 1-2-3, and all the participants show their hands at once.',
          ],
          [
            1,
            '[02:00] The Robert C. Martin Clean Code Collection - Robert C. Martin.epub (The_Robert_C._Martin_Clean_Code_split_053.html) - 2 AM',
            "I was the development manager telling the programmers who worked for me that they had to work more and faster. I was one of the 80-hour guys, writing 3,000-line C functions at <<2 AM|5>> while my children slept at home without their father in the house. I was the one who threw the pens and shouted. I got people fired if they didn\x{2019}t shape up. It was awful. I was awful.",
          ],
          [
            1,
            '[ap 23:55] The Robert C. Martin Clean Code Collection - Robert C. Martin.epub (The_Robert_C._Martin_Clean_Code_split_057.html) - 5 to 12',
            'Teams of developers certainly need a list of issues to work on. Those issues include new tasks and features as well as bugs. For any reasonably sized team (<<5 to 12|10a:0>> developers) the size of that list should be in the dozens to hundreds. Not thousands.',
          ],
          [
            1,
            "[20:23] The Robert C. Martin Clean Code Collection - Robert C. Martin.epub (The_Robert_C._Martin_Clean_Code_split_058.html) - 20\x{2013}23",
            "writers of, 99\x{2013}100
Adversarial roles, <<20\x{2013}23|5a:0>>
Affinity estimation, 140\x{2013}141",
          ],
          [
            1,
            '[03:00] The Robert C. Martin Clean Code Collection - Robert C. Martin.epub (The_Robert_C._Martin_Clean_Code_split_058.html) - 3 AM',
            "owned, 157
<<3 AM|5>>, 53\x{2013}54
worry, 54\x{2013}55",
          ],
          [
            1,
            "[ap 05:10] The Robert C. Martin Clean Code Collection - Robert C. Martin.epub (The_Robert_C._Martin_Clean_Code_split_058.html) - 5\x{2013}10",
            "\x{201c}Done,\x{201d} defining, 67, 94\x{2013}97
\x{201c}Do no harm\x{201d} approach, <<5\x{2013}10|5a:0>>
to function, 5\x{2013}8",
          ],
          [
            1,
            "[ap 08:10] The Robert C. Martin Clean Code Collection - Robert C. Martin.epub (The_Robert_C._Martin_Clean_Code_split_058.html) - 8\x{2013}10",
            "to function, 5\x{2013}8
to structure, <<8\x{2013}10|5a:0>>
Driving, 64",
          ],
          [
            1,
            "[20:23] The Robert C. Martin Clean Code Collection - Robert C. Martin.epub (The_Robert_C._Martin_Clean_Code_split_058.html) - 20\x{2013}23",
            "Git, 191\x{2013}194
Goals, <<20\x{2013}23|5a:0>>, 118
Graphical user interfaces (GUIs), 103\x{2013}105",
          ],
          [
            1,
            "[ap 11:13] The Robert C. Martin Clean Code Collection - Robert C. Martin.epub (The_Robert_C._Martin_Clean_Code_split_058.html) - 11\x{2013}13",
            "minimal, 12
work ethic and, <<11\x{2013}13|5a:0>>
L",
          ],
          [
            1,
            "[14:15] The Robert C. Martin Clean Code Collection - Robert C. Martin.epub (The_Robert_C._Martin_Clean_Code_split_058.html) - 14\x{2013}15",
            "time management and, 116\x{2013}121
Mentoring, <<14\x{2013}15|5a:0>>, 69\x{2013}70, 174\x{2013}180
Merciless refactoring, 9",
          ],
          [
            1,
            "[20:23] The Robert C. Martin Clean Code Collection - Robert C. Martin.epub (The_Robert_C._Martin_Clean_Code_split_058.html) - 20\x{2013}23",
            "Optimistic locking, 190
Outcomes, best-possible, <<20\x{2013}23|5a:0>>
Overtime, 66",
          ],
          [
            1,
            "[13:14] The Robert C. Martin Clean Code Collection - Robert C. Martin.epub (The_Robert_C._Martin_Clean_Code_split_058.html) - 13\x{2013}14",
            "turnaround time and, 82\x{2013}83
work ethic and, <<13\x{2013}14|5a:0>>
Precision, premature, in requirements, 91\x{2013}92",
          ],
          [
            1,
            "[ap 05:10] The Robert C. Martin Clean Code Collection - Robert C. Martin.epub (The_Robert_C._Martin_Clean_Code_split_058.html) - 5\x{2013}10",
            "apologies and, 6
\x{201c}do no harm\x{201d} approach and, <<5\x{2013}10|5a:0>>
function and, 5\x{2013}8",
          ],
          [
            1,
            "[ap 08:10] The Robert C. Martin Clean Code Collection - Robert C. Martin.epub (The_Robert_C._Martin_Clean_Code_split_058.html) - 8\x{2013}10",
            "function and, 5\x{2013}8
structure and, <<8\x{2013}10|5a:0>>
work ethic and, 10\x{2013}16",
          ],
          [
            1,
            "[ap 08:10] The Robert C. Martin Clean Code Collection - Robert C. Martin.epub (The_Robert_C._Martin_Clean_Code_split_058.html) - 8\x{2013}10",
            "structure and, <<8\x{2013}10|5a:0>>
work ethic and, <<10\x{2013}16|5a:0>>
RobotFX, 200",
          ],
          [
            1,
            "[20:23] The Robert C. Martin Clean Code Collection - Robert C. Martin.epub (The_Robert_C._Martin_Clean_Code_split_058.html) - 20\x{2013}23",
            "RobotFX, 200
Roles, adversarial, <<20\x{2013}23|5a:0>>
Rushing, 34\x{2013}35, 65\x{2013}66",
          ],
          [
            1,
            "[23:24] The Robert C. Martin Clean Code Collection - Robert C. Martin.epub (The_Robert_C._Martin_Clean_Code_split_058.html) - 23\x{2013}24",
            "Source code control, 189\x{2013}194
Stakes, <<23\x{2013}24|5a:0>>
Stand-up meetings, 119",
          ],
          [
            1,
            "[ap 08:10] The Robert C. Martin Clean Code Collection - Robert C. Martin.epub (The_Robert_C._Martin_Clean_Code_split_058.html) - 8\x{2013}10",
            "Structure
in \x{201c}do no harm\x{201d} approach, <<8\x{2013}10|5a:0>>
flexibility and, 9",
          ],
          [
            1,
            "[00:30] The Robert C. Martin Clean Code Collection - Robert C. Martin.epub (The_Robert_C._Martin_Clean_Code_split_058.html) - 24\x{2013}30",
            "Task estimation, 138\x{2013}141
Teams and teamwork, <<24\x{2013}30|5a:0>>
gelled, 162\x{2013}164",
          ],
          [
            1,
            '[03:00] The Robert C. Martin Clean Code Collection - Robert C. Martin.epub (The_Robert_C._Martin_Clean_Code_split_058.html) - 3 AM',
            "Thomas, Dave, 84
<<3 AM|5>> code, 53\x{2013}54
Time, debugging, 63",
          ],
          [
            1,
            "[ap 10:16] The Robert C. Martin Clean Code Collection - Robert C. Martin.epub (The_Robert_C._Martin_Clean_Code_split_058.html) - 10\x{2013}16",
            "\x{201c}Wish,\x{201d} 42
Work ethic, <<10\x{2013}16|5a:0>>
collaboration and, 14",
          ],
          [
            1,
            "[ap 11:13] The Robert C. Martin Clean Code Collection - Robert C. Martin.epub (The_Robert_C._Martin_Clean_Code_split_058.html) - 11\x{2013}13",
            "continuous learning and, 13
knowledge and, <<11\x{2013}13|5a:0>>
mentoring and, 14\x{2013}15",
          ],
          [
            1,
            "[ap 11:13] The Robert C. Martin Clean Code Collection - Robert C. Martin.epub (The_Robert_C._Martin_Clean_Code_split_058.html) - 11\x{2013}13",
            "knowledge and, <<11\x{2013}13|5a:0>>
mentoring and, 14\x{2013}15
practice and, 13\x{2013}14",
          ],
          [
            1,
            "[14:15] The Robert C. Martin Clean Code Collection - Robert C. Martin.epub (The_Robert_C._Martin_Clean_Code_split_058.html) - 14\x{2013}15",
            "mentoring and, <<14\x{2013}15|5a:0>>
practice and, 13\x{2013}14
Worry code, 54\x{2013}55",
          ],
        ];
