$VAR1 = [
          [
            1,
            '[ap 01:00] Code - Charles Petzold.epub (OEBPS/ch04.html) - 100',
            'Your home might be lit by <<100|3:0>>-watt lightbulbs. These are designed for the 120 volts of your home. Thus, the current that flows through them is equal to 100 watts divided by <<120|3:0>> volts, or about 0.83 ampere. Hence, the resistance of a 100-watt lightbulb is 120 volts divided by 0.83 ampere, or 144 ohms.',
          ],
          [
            1,
            '[ap ~ 01:44] Code - Charles Petzold.epub (OEBPS/ch05.html) - about 144',
            'Another solution is to increase the voltage and use lightbulbs with a much higher resistance. For example, a 100-watt lightbulb that lights a room in your house is designed to be used with 120 volts and has a resistance of <<about 144|18:0>> ohms. The resistance of the wires will then affect the overall circuitry much less.',
          ],
          [
            1,
            '[18:43] Code - Charles Petzold.epub (OEBPS/ch06.html) - until 1843',
            'Although Samuel Morse notified the patent office in 1836 that he had invented a successful telegraph, it wasn\'t <<until 1843|18:0>> that he was able to persuade Congress to fund a public demonstration of the device. The historic day was May 24, 1844, when a telegraph line rigged between Washington, D.C., and Baltimore, Maryland, successfully carried the biblical message: "What hath God wrought!"',
          ],
          [
            1,
            '[ap 02:05] Code - Charles Petzold.epub (OEBPS/ch07.html) - 205',
            'Yes, the zero. The lowly zero is without a doubt one of the most important inventions in the history of numbers and mathematics. It supports positional notation because it allows differentiation of 25 from <<205|9c:0>> and 250. The zero also eases many mathematical operations that are awkward in nonpositional systems, particularly multiplication and division.',
          ],
          [
            1,
            '[ap 01:03] Code - Charles Petzold.epub (OEBPS/ch08.html) - one three',
            'When you\'re working with number systems other than decimal, you can avoid some confusion if you pronounce a number like 10 as one zero. Similarly, 13 is pronounced <<one three|5l:0>> and 20 is pronounced two zero. To really avoid confusion, we can say two zero base eight or two zero octal.',
          ],
          [
            1,
            '[ap 02:00] Code - Charles Petzold.epub (OEBPS/ch08.html) - 2',
            '101101011010TWO = 1 x 211 +0 x 210 +1 x 29 +1 x 28 +0 x 27 +1 x 26 +0 x 25 +1 x 24 +1 x 23 +0 x 22 +1 x 21 +0 x 20If we just add up the parts in decimal, we get 2048 + 512 + 256 + 64 + 16 + 8 + 2, which is <<2|9d>>,906TEN.',
          ],
          [
            1,
            '[00:11] Code - Charles Petzold.epub (OEBPS/ch08.html) - 0011',
            "People who work with binary numbers often write them with leading zeros (that is, zeros to the left of the first 1)\x{2014}for example, <<0011|18:0>> rather than just 11. This doesn't change the value of the number at all; it's just for cosmetic purposes. For example, here are the first sixteen binary numbers with their decimal equivalents:",
          ],
          [
            1,
            '[00:00] Code - Charles Petzold.epub (OEBPS/ch08.html) - 0000',
            'Decimal
<<0000|18:0>>
0',
          ],
          [
            1,
            '[00:01] Code - Charles Petzold.epub (OEBPS/ch08.html) - 0001',
            '0
<<0001|18:0>>
1',
          ],
          [
            1,
            '[00:10] Code - Charles Petzold.epub (OEBPS/ch08.html) - 0010',
            '1
<<0010|18:0>>
2',
          ],
          [
            1,
            '[00:11] Code - Charles Petzold.epub (OEBPS/ch08.html) - 0011',
            '2
<<0011|18:0>>
3',
          ],
          [
            1,
            '[ap 01:00] Code - Charles Petzold.epub (OEBPS/ch08.html) - 0100',
            '3
<<0100|18:0>>
4',
          ],
          [
            1,
            '[ap 01:01] Code - Charles Petzold.epub (OEBPS/ch08.html) - 0101',
            '4
<<0101|18:0>>
5',
          ],
          [
            1,
            '[ap 01:10] Code - Charles Petzold.epub (OEBPS/ch08.html) - 0110',
            '5
<<0110|18:0>>
6',
          ],
          [
            1,
            '[ap 01:11] Code - Charles Petzold.epub (OEBPS/ch08.html) - 0111',
            '6
<<0111|18:0>>
7',
          ],
          [
            1,
            '[ap 01:00] Code - Charles Petzold.epub (OEBPS/ch08.html) - 0 to 1',
            'Here\'s another way of looking at it: When you count in binary, the rightmost digit (also called the least significant digit), alternates between 0 and 1. Every time it changes from a 1 to a 0, the digit second to right (that is, the next most significant digit) also changes, either from <<0 to 1|10a:0>> or from <<1 to 0|10a:0>>. So every time a binary digit changes from a 1 to a 0, the next most significant digit also changes, either from a 0 to a 1 or from a 1 to a 0.',
          ],
          [
            1,
            '[ap 01:11] Code - Charles Petzold.epub (OEBPS/ch08.html) - 0111',
            'Binary numbers can get very long very quickly. For example, twelve million in binary is 101101110001101100000000. To make this a little more readable, it\'s customary to separate every four binary digits with a dash, for example 1011-0111-0001-1011-0000-0000 or with spaces: 1011 <<0111|18:0>> <<0001|18:0>> 1011 <<0000|18:0>> <<0000|18:0>>. Later on in this book, we\'ll look at a more concise way of expressing binary numbers.',
          ],
          [
            1,
            '[~ 19:48] Code - Charles Petzold.epub (OEBPS/ch08.html) - around 1948',
            'Sometime <<around 1948|18:0>>, the American mathematician John Wilder Tukey (born 1915) realized that the words binary digit were likely to assume a much greater importance in the years ahead as computers became more prevalent. He decided to coin a new, shorter word to replace the unwieldy five syllables of binary digit. He considered bigit and binit but settled instead on the short, simple, elegant, and perfectly lovely word bit.',
          ],
          [
            1,
            '[00:00] Code - Charles Petzold.epub (OEBPS/ch09.html) - midnight',
            '"Listen, my children, and you shall hear / Of the <<midnight|13>> ride of Paul Revere," wrote Henry Wadsworth Longfellow, and while he might not have been historically accurate when describing how Paul Revere alerted the American colonies that the British had invaded, he did provide a thoughtprovoking example of the use of bits to communicate important information:',
          ],
          [
            1,
            '[00:00] Code - Charles Petzold.epub (OEBPS/ch09.html) - 0',
            '00 = They both hated it.01 = Siskel hated it; Ebert loved it.10 = Siskel loved it; Ebert hated it.11 = They both loved it.The first bit is the Siskel bit, which is <<0|9d>> if Siskel hated the movie and 1 if he liked it. Similarly, the second bit is the Ebert bit.',
          ],
          [
            1,
            '[ap ~ 01:11] Code - Charles Petzold.epub (OEBPS/ch09.html) - about 111',
            "000 = BOMB001 = *\x{bd}010 = **011 = **\x{bd}100 = ***101 = ***\x{bd}110 = ****\"What <<about 111|18:0>>?\" you may ask. Well, that code doesn't mean anything. It's not defined. If the binary code 111 were used to represent a Maltin rating, you'd know that a mistake was made. (Probably a computer made the mistake because people never do.)",
          ],
          [
            1,
            '[00:00] Code - Charles Petzold.epub (OEBPS/ch09.html) - 0000',
            "<<0000|18:0>> = F0001 = D\x{2013}0010 = D0011 = D+0100 = C\x{2013}0101 = C0110 = C+0111 = B\x{2013}1000 = B1001 = B+1010 = A\x{2013}1011 = A1100 = A+We have three unused codes: 1101, 1110, and 1111, for a grand total of 16.",
          ],
          [
            1,
            '[00:00] Code - Charles Petzold.epub (OEBPS/ch12.html) - 0',
            'The subscripts start at <<0|9g>> and get higher for more significant digits because they correspond to the exponents of powers of two:',
          ],
          [
            1,
            '[13:00] Code - Charles Petzold.epub (OEBPS/ch13.html) - 13',
            'To do this, we start with the rightmost column. First we see that 6 is bigger than 3, so we have to borrow 1 from the 5, and then subtract 6 from <<13|9c:0>>, which is <<7|9f>>. Then we have to remember that we borrowed 1 from the 5, so it\'s really a 4, and this 4 is smaller than 7, so we borrow 1 from the 2 and subtract 7 from <<14|9c:0>>, which is <<7|9f>>. Then we have to remember that we borrowed 1 from the 2, so it\'s really a 1, and then we subtract 1 from it to get 0. Our answer is 77:',
          ],
          [
            1,
            '[ap 09:23] Code - Charles Petzold.epub (OEBPS/ch13.html) - 923',
            'At this point in the earlier problem, you were able to add 1 and subtract 1000 to get the final result. But in this case, that strategy isn\'t going to work well. You would need to subtract 1000 from <<923|9c:0>>, and that really means subtracting 923 from <<1000|9c:0>>, and that requires borrowing.',
          ],
          [
            1,
            '[ap 10:00] Code - Charles Petzold.epub (OEBPS/ch13.html) - ten',
            "This type of notation is called <<ten|9f>>'s complement. To convert a 3-digit negative number to ten's complement, we subtract it from 999 and add 1. In other words, the ten's complement is the nines' complement plus one. For example, to write \x{2013}255 in ten's complement, subtract it from 999 to get 744 and then add 1 to get 745.",
          ],
          [
            1,
            '[ap 02:00] Code - Charles Petzold.epub (OEBPS/ch13.html) - two',
            'The equivalent system in binary is called <<two|9f>>\'s complement. Let\'s assume that we\'re working with 8-bit numbers. These range from 00000000 to 11111111, which normally correspond to decimal numbers 0 through 255. But if you also want to express negative numbers, every 8-bit number that begins with a 1 will actually represent a negative number, as shown in the following table:',
          ],
          [
            1,
            '[ap 01:00] Code - Charles Petzold.epub (OEBPS/ch14.html) - 1',
            'A more interesting approach to the adding machine eliminates an entire row of eight switches. But first we need to modify the D-type flip-flop slightly by adding an OR gate and an input signal called Clear. The Clear input is normally 0. But when it\'s <<1|9f>>, the Q output becomes 0, as shown here:',
          ],
          [
            1,
            '[ap 01:00] Code - Charles Petzold.epub (OEBPS/ch14.html) - 0 to 1',
            'I mentioned earlier that the D-type flip-flop we designed was level-triggered. This means that the Clock input must change its level from <<0 to 1|10a:1>> in order for the value of the Data input to be stored in the latch. But during the time that the Clock input is 1, the Data input can change; any changes in the Data input while the Clock input is 1 will be reflected in the values of the Q and  outputs.',
          ],
          [
            1,
            '[ap 01:00] Code - Charles Petzold.epub (OEBPS/ch14.html) - 0 to 1',
            'For some applications, a level-triggered Clock input is quite sufficient. But for other applications, an edge-triggered Clock input is preferred. An edge trigger causes the outputs to change only when the Clock makes a transition from <<0 to 1|10a:1>>. As with the level-triggered flip-flop, when the Clock input is 0, any changes to the Data input don\'t affect the outputs. The difference in an edge-triggered flip-flop is that changes to the Data input also don\'t affect the outputs when the Clock input is 1. The Data input affects the outputs only at the instant that the Clock changes from <<0 to 1|10a:1>>.',
          ],
          [
            1,
            '[ap 01:00] Code - Charles Petzold.epub (OEBPS/ch14.html) - 0 to 1',
            'The idea here is that the Clock input controls both the first stage and the second stage. But notice that the clock is inverted in the first stage. This means that the first stage works exactly like a D-type flip-flop except that the Data input is stored when the Clock is 0. The outputs of the second stage are inputs to the first stage, and these are saved when the Clock is 1. The overall result is that the Data input is saved when the Clock changes from <<0 to 1|10a:1>>.',
          ],
          [
            1,
            '[00:00] Code - Charles Petzold.epub (OEBPS/ch14.html) - 0',
            'Let\'s take a closer look. Here\'s the flip-flop at rest with both the Data and Clock inputs at <<0|9c:1>> and the Q output at <<0|9c:1>>:',
          ],
          [
            1,
            '[ap 01:00] Code - Charles Petzold.epub (OEBPS/ch14.html) - 0 to 1',
            'The Q and  outputs can change only at the instant that the Clock input changes from <<0 to 1|10a:1>>.',
          ],
          [
            1,
            '[ap 01:00] Code - Charles Petzold.epub (OEBPS/ch14.html) - 0 to 1',
            'The arrow indicates that the output Q becomes the same as the Data input when the Clock makes a transition from <<0 to 1|10a:1>>. This is known as a positive transition of the Clock signal. (A negative transition is the transition from <<1 to 0|10a:1>>.) The flip-flop has a diagram like this:',
          ],
          [
            1,
            '[ap 01:00] Code - Charles Petzold.epub (OEBPS/ch14.html) - 0 to 1',
            'When the Clock input changes from <<0 to 1|10a:1>>, the Q output will become the same as the D input:',
          ],
          [
            1,
            '[ap 01:00] Code - Charles Petzold.epub (OEBPS/ch14.html) - 0 to 1',
            'What\'s happening here can be summed up very simply: Every time the Clock input changes from <<0 to 1|10a:1>>, the Q output changes, either from <<0 to 1|10a:1>> or from <<1 to 0|10a:1>>. The situation is clearer if we look at the timing diagram:',
          ],
          [
            1,
            '[ap 01:00] Code - Charles Petzold.epub (OEBPS/ch14.html) - 0 to 1',
            'When the Clock input goes from <<0 to 1|10a:1>>, the value of D (which is the same as ) is transferred to Q, thus also changing  and D for the next transition of the Clock input from <<0 to 1|10a:1>>.',
          ],
          [
            1,
            '[00:00] Code - Charles Petzold.epub (OEBPS/ch14.html) - 0000',
            'Decimal
<<0000|18:0>>
0',
          ],
          [
            1,
            '[00:01] Code - Charles Petzold.epub (OEBPS/ch14.html) - 0001',
            '0
<<0001|18:0>>
1',
          ],
          [
            1,
            '[00:10] Code - Charles Petzold.epub (OEBPS/ch14.html) - 0010',
            '1
<<0010|18:0>>
2',
          ],
          [
            1,
            '[00:11] Code - Charles Petzold.epub (OEBPS/ch14.html) - 0011',
            '2
<<0011|18:0>>
3',
          ],
          [
            1,
            '[ap 01:00] Code - Charles Petzold.epub (OEBPS/ch14.html) - 0100',
            '3
<<0100|18:0>>
4',
          ],
          [
            1,
            '[ap 01:01] Code - Charles Petzold.epub (OEBPS/ch14.html) - 0101',
            '4
<<0101|18:0>>
5',
          ],
          [
            1,
            '[ap 01:10] Code - Charles Petzold.epub (OEBPS/ch14.html) - 0110',
            '5
<<0110|18:0>>
6',
          ],
          [
            1,
            '[ap 01:11] Code - Charles Petzold.epub (OEBPS/ch14.html) - 0111',
            '6
<<0111|18:0>>
7',
          ],
          [
            1,
            '[~ 19:56] Code - Charles Petzold.epub (OEBPS/ch15.html) - around 1956',
            'The word byte originated at IBM, probably <<around 1956|18:0>>. The word had its origins in the word bite but was spelled with a y so that nobody would mistake the word for bit. For a while, a byte meant simply the number of bits in a particular data path. But by the mid-1960s, in connection with the development of IBM\'s System/360 (their large complex of business computers), the word came to mean a group of 8 bits.',
          ],
          [
            1,
            '[ap ~ 02:56] Code - Charles Petzold.epub (OEBPS/ch15.html) - approximately 256',
            "It turns out that 8 is, indeed, a nice bite size of bits. The byte is right, in more ways than one. One reason that IBM gravitated toward 8-bit bytes was the ease in storing numbers in a format known as BCD (which I'll describe in Chapter\x{a0}23). But as we'll see in the chapters ahead, quite by coincidence a byte is ideal for storing text because most written languages around the world (with the exception of the ideographs used in Chinese, Japanese, and Korean) can be represented with fewer than 256 characters. A byte is also ideal for representing gray shades in black-and-white photographs because the human eye can differentiate <<approximately 256|18:0>> shades of gray. And where 1 byte is inadequate (for representing, for example, the aforementioned ideographs of Chinese, Japanese, and Korean), 2 bytes\x{2014}which allow the representation of 216, or 65,536, things\x{2014}usually works just fine.",
          ],
          [
            1,
            '[00:00] Code - Charles Petzold.epub (OEBPS/ch15.html) - 0000',
            'Decimal
<<0000|18:0>>
0',
          ],
          [
            1,
            '[00:01] Code - Charles Petzold.epub (OEBPS/ch15.html) - 0001',
            '8
<<0001|18:0>>
1',
          ],
          [
            1,
            '[00:10] Code - Charles Petzold.epub (OEBPS/ch15.html) - 0010',
            '9
<<0010|18:0>>
2',
          ],
          [
            1,
            '[00:11] Code - Charles Petzold.epub (OEBPS/ch15.html) - 0011',
            '10
<<0011|18:0>>
3',
          ],
          [
            1,
            '[ap 01:00] Code - Charles Petzold.epub (OEBPS/ch15.html) - 0100',
            '11
<<0100|18:0>>
4',
          ],
          [
            1,
            '[ap 01:01] Code - Charles Petzold.epub (OEBPS/ch15.html) - 0101',
            '12
<<0101|18:0>>
5',
          ],
          [
            1,
            '[ap 01:10] Code - Charles Petzold.epub (OEBPS/ch15.html) - 0110',
            '13
<<0110|18:0>>
6',
          ],
          [
            1,
            '[ap 01:11] Code - Charles Petzold.epub (OEBPS/ch15.html) - 0111',
            '14
<<0111|18:0>>
7',
          ],
          [
            1,
            '[00:00] Code - Charles Petzold.epub (OEBPS/ch15.html) - 0000',
            'Decimal
<<0000|18:0>>
0',
          ],
          [
            1,
            '[00:01] Code - Charles Petzold.epub (OEBPS/ch15.html) - 0001',
            '0
<<0001|18:0>>
1',
          ],
          [
            1,
            '[00:10] Code - Charles Petzold.epub (OEBPS/ch15.html) - 0010',
            '1
<<0010|18:0>>
2',
          ],
          [
            1,
            '[00:11] Code - Charles Petzold.epub (OEBPS/ch15.html) - 0011',
            '2
<<0011|18:0>>
3',
          ],
          [
            1,
            '[ap 01:00] Code - Charles Petzold.epub (OEBPS/ch15.html) - 0100',
            '3
<<0100|18:0>>
4',
          ],
          [
            1,
            '[ap 01:01] Code - Charles Petzold.epub (OEBPS/ch15.html) - 0101',
            '4
<<0101|18:0>>
5',
          ],
          [
            1,
            '[ap 01:10] Code - Charles Petzold.epub (OEBPS/ch15.html) - 0110',
            '5
<<0110|18:0>>
6',
          ],
          [
            1,
            '[ap 01:11] Code - Charles Petzold.epub (OEBPS/ch15.html) - 0111',
            '6
<<0111|18:0>>
7',
          ],
          [
            1,
            '[01:00] Code - Charles Petzold.epub (OEBPS/ch15.html) - 10000h',
            '9A48Ch = 9 x <<10000h|1>> +A x <<1000h|1>> +4 x <<100h|1>> +8 x 10h +C x 1hThis can be written using powers of 16:',
          ],
          [
            1,
            '[ap 02:56] Code - Charles Petzold.epub (OEBPS/ch15.html) - 256',
            'You start by putting the entire decimal number in the box in the upper left corner. That\'s your first dividend. Divide by 4096, the first divisor. The quotient goes in the box below the dividend, and the remainder goes in the box to the right of the dividend. That remainder is the new dividend that you divide by <<256|3:0>>. Here\'s the conversion of 31,148 back to hexadecimal:',
          ],
          [
            1,
            '[ap 02:56] Code - Charles Petzold.epub (OEBPS/ch15.html) - 256',
            'Another approach to converting decimal numbers through 65,535 to hex involves first separating the number into 2 bytes by dividing by <<256|3:0>>. Then for each byte, divide by 16. Here\'s a template for doing it:',
          ],
          [
            1,
            '[03:00] Code - Charles Petzold.epub (OEBPS/ch16.html) - 3:00 A.M.',
            'Nor is human memory foolproof. Indeed, writing was probably invented specifically to compensate for the failings of human memory. Perhaps last night you suddenly woke up at <<3:00 A.M.|2a>> with a great idea for a screenplay. You grabbed the pen and paper you keep by your bed specifically for that purpose, and you wrote it down so you wouldn\'t forget. The next morning you can read the brilliant idea and start work on the screenplay. ("Boy meets girl w. car chase & explosions"? That\'s it?) Or maybe not.',
          ],
          [
            1,
            '[ap 00:52] Code - Charles Petzold.epub (OEBPS/ch16.html) - 8-to-1',
            'The <<8-to-1|10a:0>> Selector has eight Data inputs (shown at the top) and three Select inputs (shown at the left). The Select inputs choose which of the Data inputs appears at the Output. For example, if the Select inputs are 000, the Output is the same as D0. If the Select inputs are 111, the Output is the same as D7. If the Select inputs are 101, the Output is the same as D5. Here\'s the logic table:',
          ],
          [
            1,
            '[ap 00:52] Code - Charles Petzold.epub (OEBPS/ch16.html) - 8-to-1',
            'The <<8-to-1|10a:0>> Selector is built from three inverters, eight 4-input AND gates, and an 8-input OR gate, like this:',
          ],
          [
            1,
            '[ap 00:52] Code - Charles Petzold.epub (OEBPS/ch16.html) - 8-to-1',
            'Let\'s recap what we\'re trying to do here. We\'re trying to wire eight 1-bit latches so that they can be individually written to using a single Data In signal and individually examined using a single Data Out signal. We\'ve already established that we can choose a Data Output signal from one of the eight latches by using an <<8-to-1|10a:0>> Selector, as shown on the following page.',
          ],
          [
            1,
            '[ap 00:52] Code - Charles Petzold.epub (OEBPS/ch16.html) - 8-to-1',
            "To accomplish this task, we need another circuit that looks somewhat similar to the <<8-to-1|10a:0>> Selector but actually does the opposite. This is the <<3-to-8|10a:0>> Decoder. We've also seen a simple Data Decoder before\x{2014}when wiring the switches to select the color of our ideal cat in Chapter\x{a0}11.",
          ],
          [
            1,
            '[ap 07:57] Code - Charles Petzold.epub (OEBPS/ch16.html) - 3-to-8',
            'The <<3-to-8|10a:0>> Decoder has eight Outputs. At any time, all but one of the Outputs are 0. The exception is the Output that\'s selected by the S0, S1, and S2 inputs. This Output is the same as the Data Input.',
          ],
          [
            1,
            '[ap 00:52] Code - Charles Petzold.epub (OEBPS/ch16.html) - 8-to-1',
            'Notice that the three Select signals to the Decoder and the Selector are the same and that I\'ve also labeled those three signals the Address. Like a post office box number, this 3-bit address determines which of the eight 1-bit latches is being referenced. On the input side, the Address input determines which latch the Write signal will trigger to store the Data input. On the output side (at the bottom of the figure), the Address input controls the <<8-to-1|10a:0>> Selector to select the output of one of the eight latches.',
          ],
          [
            1,
            '[ap 00:58] Code - Charles Petzold.epub (OEBPS/ch16.html) - 2-to-1',
            "Or the two 8 x 1 RAM arrays can be combined in much the same way that the individual latches were combined\x{2014}by using a <<2-to-1|10a:0>> Selector and a <<1-to-2|10a:0>> Decoder, as shown on the next page.",
          ],
          [
            1,
            '[ap 10:24] Code - Charles Petzold.epub (OEBPS/ch16.html) - 1024',
            "What you don't say is that a 1-KB RAM array stores 1000 bytes, or (in English) \"one thousand bytes.\" It's more than a thousand\x{2014}it's <<1024|9f>>. To sound like you know what you're talking about, you say either \"1K\" or \"one kilobyte.\"",
          ],
          [
            1,
            '[ap ~ 10:12] Code - Charles Petzold.epub (OEBPS/ch16.html) - approximately 1012',
            'Similarly, a terabyte (teras means monster) equals 240 bytes (<<approximately 1012|18:0>>) or 1,099,511,627,776 bytes. Terabyte is abbreviated TB.',
          ],
          [
            1,
            '[ap ~ 10:15] Code - Charles Petzold.epub (OEBPS/ch16.html) - approximately 1015',
            'Ascending into regions that few have traveled, a petabyte equals 250 bytes or 1,125,899,906,842,624 bytes, which is <<approximately 1015|9n:0>> or a quadrillion. An exabyte equals 260 bytes or 1,152,921,504,606,846,976 bytes, <<approximately 1018|9n:0>> or a quintillion.',
          ],
          [
            1,
            '[ap 02:16] Code - Charles Petzold.epub (OEBPS/ch16.html) - 216',
            'Why 64 KB? Why not 32 KB or 128 KB? Because 65,536 is a nice round number. It\'s <<216|9f>>. This RAM array has a 16-bit address. In other words, the address is 2 bytes exactly. In hexadecimal, the address ranges from <<0000h|1>> through FFFFh.',
          ],
          [
            1,
            '[ap 00:58] Code - Charles Petzold.epub (OEBPS/ch16.html) - 2-to-1',
            'When the Takeover switch is open (as shown), the Address, Data input, and Write inputs to the 64K x 8 RAM array come from external signals shown at the top left of the <<2-to-1|10a:0>> Selectors. When the Takeover switch is closed, the Address, Data input, and Write signals to the RAM array come from the switches on the control panel. In either case, the Data Out signals from the RAM array go to the eight lightbulbs and possibly someplace else.',
          ],
          [
            1,
            '[ap 01:00] Code - Charles Petzold.epub (OEBPS/ch17.html) - 0 to 1',
            "At the time I showed this circuit to you in Chapter\x{a0}14, the only latches that I had introduced so far were level triggered. In a level-triggered latch, the Clock input has to go to 1 and then back to 0 in order for the latch to store something. During the time the Clock input is 1, the data inputs of the latch can change and these changes will affect the stored output. Later in that chapter, I introduced edge-triggered latches. These latches save their values in the brief moment that the Clock input goes from <<0 to 1|10a:1>>. Edge-triggered latches are often somewhat easier to use, so I want to assume that all the latches in this chapter are edge triggered.",
          ],
          [
            1,
            '[00:00] Code - Charles Petzold.epub (OEBPS/ch17.html) - 0000h',
            'This is certainly not the easiest piece of calculating equipment ever invented. To use it, you first must close the switch labeled Clear. This clears the contents of the latch and sets the output of the 16-bit counter to <<0000h|1>>. Then you close the Takeover switch on the RAM control panel. You can then enter a set of 8-bit numbers that you want to add beginning at RAM address <<0000h|1>>. If you have 100 numbers, you\'ll store these numbers at addresses <<0000h|1>> through 0063h. (You should also set all the unused entries in the RAM array to 00h.) You can then open the Takeover switch of the RAM control panel (so that the control panel no longer has control over the RAM array) and open the Clear switch. Then just sit back and watch the flashing lightbulbs.',
          ],
          [
            1,
            '[00:00] Code - Charles Petzold.epub (OEBPS/ch17.html) - 0000h',
            'Here\'s how it works: When the Clear switch is first opened, the address of the RAM array is <<0000h|1>>. The 8-bit value stored in the RAM array at that address is an input to the adder. The other input to the adder is 00h because the latch is also cleared.',
          ],
          [
            1,
            '[00:01] Code - Charles Petzold.epub (OEBPS/ch17.html) - 0001h',
            "The oscillator provides a clock signal\x{2014}a signal that alternates between 0 and 1 very quickly. After the Clear switch is opened, whenever the clock changes from a 0 to a 1, two things happen simultaneously: The latch stores the sum from the adder, and the 16-bit counter increments, thus addressing the next value in the RAM array. The first time the clock changes from 0 to 1 after the Clear switch is opened, the latch stores the first value and the counter increments to <<0001h|1>>. The second time, the latch stores the sum of the first and second values, and the counter increments to <<0002h|1>>. And so on.",
          ],
          [
            1,
            '[00:00] Code - Charles Petzold.epub (OEBPS/ch17.html) - 0000h',
            'One problem with this circuit is that we have no way of stopping it! At some point, the lightbulbs will stop flashing because all the rest of the numbers in the RAM array will be 00h. At that time, you can read the binary sum. But when the counter eventually reaches FFFFh, it will roll over (just like a car odometer) to <<0000h|1>> and this automated adder will begin adding the numbers again to the sum that was already calculated.',
          ],
          [
            1,
            '[00:00] Code - Charles Petzold.epub (OEBPS/ch17.html) - 0000h',
            'For example, suppose we want to add three numbers together and then add two numbers together and then add another three numbers together. We might imagine typing these numbers into the RAM array beginning at address <<0000h|1>> so that the contents of the memory look like this:',
          ],
          [
            1,
            '[00:00] Code - Charles Petzold.epub (OEBPS/ch17.html) - 0000h',
            'In gory detail, what we want the automated adder to do in this particular example is this:
Load the value at address <<0000h|1>> into the accumulator.
Add the value at address <<0001h|1>> to the accumulator.',
          ],
          [
            1,
            '[00:00] Code - Charles Petzold.epub (OEBPS/ch17.html) - 0000h',
            'Load the value at address <<0000h|1>> into the accumulator.
Add the value at address <<0001h|1>> to the accumulator.
Add the value at address <<0002h|1>> to the accumulator.',
          ],
          [
            1,
            '[00:01] Code - Charles Petzold.epub (OEBPS/ch17.html) - 0001h',
            'Add the value at address <<0001h|1>> to the accumulator.
Add the value at address <<0002h|1>> to the accumulator.
Store the contents of the accumulator at address <<0003h|1>>.',
          ],
          [
            1,
            '[00:02] Code - Charles Petzold.epub (OEBPS/ch17.html) - 0002h',
            'Add the value at address <<0002h|1>> to the accumulator.
Store the contents of the accumulator at address <<0003h|1>>.
Load the value at address <<0004h|1>> into the accumulator.',
          ],
          [
            1,
            '[00:03] Code - Charles Petzold.epub (OEBPS/ch17.html) - 0003h',
            'Store the contents of the accumulator at address <<0003h|1>>.
Load the value at address <<0004h|1>> into the accumulator.
Add the value at address <<0005h|1>> to the accumulator.',
          ],
          [
            1,
            '[00:04] Code - Charles Petzold.epub (OEBPS/ch17.html) - 0004h',
            'Load the value at address <<0004h|1>> into the accumulator.
Add the value at address <<0005h|1>> to the accumulator.
Store the contents of the accumulator at address <<0006h|1>>.',
          ],
          [
            1,
            '[00:05] Code - Charles Petzold.epub (OEBPS/ch17.html) - 0005h',
            'Add the value at address <<0005h|1>> to the accumulator.
Store the contents of the accumulator at address <<0006h|1>>.
Load the value at address <<0007h|1>> into the accumulator.',
          ],
          [
            1,
            '[00:06] Code - Charles Petzold.epub (OEBPS/ch17.html) - 0006h',
            'Store the contents of the accumulator at address <<0006h|1>>.
Load the value at address <<0007h|1>> into the accumulator.
Add the value at address <<0008h|1>> to the accumulator.',
          ],
          [
            1,
            '[00:07] Code - Charles Petzold.epub (OEBPS/ch17.html) - 0007h',
            'Load the value at address <<0007h|1>> into the accumulator.
Add the value at address <<0008h|1>> to the accumulator.
Add the value at address <<0009h|1>> to the accumulator.',
          ],
          [
            1,
            '[00:08] Code - Charles Petzold.epub (OEBPS/ch17.html) - 0008h',
            'Add the value at address <<0008h|1>> to the accumulator.
Add the value at address <<0009h|1>> to the accumulator.
Store the contents of the accumulator at address 000Ah.',
          ],
          [
            1,
            '[00:00] Code - Charles Petzold.epub (OEBPS/ch17.html) - 0000h',
            'Notice that just as in the original automated adder, each byte of memory is still being addressed sequentially beginning at <<0000h|1>>. The original automated adder simply added the contents of the memory at that address to the contents of the accumulator. In some cases, we still want to do that. But we also sometimes want to Load the accumulator directly with a value in memory or to Store the contents of the accumulator in memory. And after everything is done, we want the automated adder to simply stop so that the contents of the RAM array can be examined.',
          ],
          [
            1,
            '[ap 00:58] Code - Charles Petzold.epub (OEBPS/ch17.html) - 2-to-1',
            'This diagram is missing a few pieces, but it shows all the 8-bit data paths between the various components. The 16-bit counter provides an address for the two RAM arrays. The output of the Data RAM array goes into the 8-Bit Adder, as usual, to perform the Add instruction. But the input to the 8-bit latch can be either the output of the Data RAM array (in the case of a Load instruction) or the output of the adder (in the case of an Add instruction). This situation requires a <<2-to-1|10a:0>> Selector. The output of the latch circles back to the adder, as usual, but it\'s also the data input of the Data RAM array for a Store instruction.',
          ],
          [
            1,
            '[ap 00:58] Code - Charles Petzold.epub (OEBPS/ch17.html) - 2-to-1',
            'What this diagram is missing are all the little signals that control these components, known collectively as the control signals. These include the Clock and Clear inputs to the 16-bit counter, the Clock and Clear inputs to the 8-bit latch, the Write input to the Data RAM array, and the Select input to the <<2-to-1|10a:1>> Selector. Some of these signals will obviously be based on the output of the Code RAM array. For example, the Select input to the <<2-to-1|10a:1>> Selector must be 0 (selecting the Data RAM output) if the output of the Code RAM array indicates a Load instruction. The Write input to the Data RAM array must be 1 only when the opcode is a Store instruction. These control signals can be generated by various combinations of logic gates.',
          ],
          [
            1,
            '[00:02] Code - Charles Petzold.epub (OEBPS/ch17.html) - 0002h',
            'the result D7h will be stored at address <<0002h|1>>, and the result 99h will be stored at address <<0005h|1>>.',
          ],
          [
            1,
            '[00:00] Code - Charles Petzold.epub (OEBPS/ch17.html) - 0000h',
            'Of course, actually keying these numbers into memory isn\'t the most rewarding job around. Not only do you have to use switches to represent binary numbers, but the numbers aren\'t stored in consecutive addresses. For example, the number 7A892BCDh goes into addresses <<0000h|1>>, <<0003h|1>>, <<0006h|1>>, and <<0009h|1>> starting with the least-significant byte. To get the final result, you have to examine the values located at addresses <<0002h|1>>, <<0005h|1>>, <<0008h|1>>, and 000Bh.',
          ],
          [
            1,
            '[00:00] Code - Charles Petzold.epub (OEBPS/ch17.html) - 0000h',
            'The problem is that we\'ve built an automated adder that addresses the Code memory and the Data memory simultaneously and sequentially beginning at address <<0000h|1>>. Each instruction in the Code memory corresponds to a location in the Data memory at the same address. Once a Store instruction causes something to be stored in the Data memory, that value can\'t later be loaded back into the accumulator.',
          ],
          [
            1,
            '[00:00] Code - Charles Petzold.epub (OEBPS/ch17.html) - 0000h',
            'Each of the instruction codes (except Halt) is followed by 2 bytes that indicate a 16-bit address in the Data RAM array. These three addresses happen to be <<0000h|1>>, <<0001h|1>>, and <<0002h|1>>, but they could be anything.',
          ],
          [
            1,
            '[00:00] Code - Charles Petzold.epub (OEBPS/ch17.html) - 0000h',
            "Earlier I showed how to add a pair of 16-bit numbers\x{2014}specifically 76ABh and 232 Ch\x{2014}using the Add and Add with Carry instructions. But we had to store the 2 low-order bytes of these numbers at memory locations <<0000h|1>> and <<0001h|1>>, and the 2 high-order bytes at <<0003h|1>> and <<0004h|1>>. The result of the addition was stored at <<0002h|1>> and <<0005h|1>>.",
          ],
          [
            1,
            '[00:00] Code - Charles Petzold.epub (OEBPS/ch17.html) - 0000h',
            'If you were actually building such a machine out of relays, the bulk of the circuit would obviously be the two 64-KB RAM arrays. Indeed, much earlier you might have skimped on these components and decided that initially you would need only 1 KB of memory. If you made sure you stored everything in addresses <<0000h|1>> through 03FFh, using less memory than 64 KB would work out just fine.',
          ],
          [
            1,
            '[ap 00:58] Code - Charles Petzold.epub (OEBPS/ch17.html) - 2-to-1',
            'To accomplish this, we need to have a <<2-to-1|10a:0>> Selector to determine how the RAM array is addressed. Usually, the address is the 16-bit counter, as before. The RAM Data Out is still connected to three latches that latch the instruction code and the 2 address bytes that accompany each instruction. But the 16-bit address is the second input to the <<2-to-1|10a:0>> Selector. After the address is latched, this selector allows the latched address to be the address input to the RAM array:',
          ],
          [
            1,
            '[00:00] Code - Charles Petzold.epub (OEBPS/ch17.html) - 0000h',
            'As usual, the instructions begin at <<0000h|1>> because that\'s where the counter starts accessing the RAM array after it has been reset. The final Halt instruction is stored at address 000Ch. We could have stored the three numbers and the results anywhere in the RAM array (except in the first 13 bytes, of course, because those memory locations are occupied by instructions), but we chose to store the data starting at address <<0010h|1>>.',
          ],
          [
            1,
            '[00:10] Code - Charles Petzold.epub (OEBPS/ch17.html) - 0010h',
            'Now suppose you discover that you need to add two more numbers to that result. Well, you can replace all the instructions you just entered with some new instructions, but maybe you don\'t want to do that. Maybe you\'d prefer to just continue with the new instructions starting at the end of these instructions, first replacing the Halt instruction with a new Load instruction at address 000Ch. But you also need two new Add instructions, a Store instruction, and a new Halt instruction. Your only problem is that you have some data stored at address <<0010h|1>>. You have to move that data someplace at a higher memory address. And you then have to change the instructions that refer to those memory instructions.',
          ],
          [
            1,
            '[00:20] Code - Charles Petzold.epub (OEBPS/ch17.html) - 0020h',
            'Hmmm, you think. Maybe combining Code and Data into a single RAM array wasn\'t such a hot idea after all. But I assure you, a problem such as this would have come up sooner or later. So let\'s solve it. In this case, maybe what you\'d like to do is enter the new instructions beginning at address <<0020h|1>> and the new data at address <<0030h|1>>:',
          ],
          [
            1,
            '[00:13] Code - Charles Petzold.epub (OEBPS/ch17.html) - 0013h',
            'Notice that the first Load instruction refers to the memory location <<0013h|1>>, which is where the result of the first calculation was stored.',
          ],
          [
            1,
            '[00:00] Code - Charles Petzold.epub (OEBPS/ch17.html) - 0000h',
            'So now we have some instructions starting at address <<0000h|1>>, some data starting at <<0010h|1>>, some more instructions at <<0020h|1>>, and some more data at <<0030h|1>>. We want to let the automated adding machine start at <<0000h|1>> and execute all the instructions.',
          ],
          [
            1,
            '[00:12] Code - Charles Petzold.epub (OEBPS/ch17.html) - 0012h',
            "We know we must remove that Halt instruction at address 000Ch, and by remove I really mean replace it with something else. But is that sufficient? The problem is that whatever we replace the Halt instruction with is going to be interpreted as an instruction byte. And so will the bytes stored every 3 bytes after that\x{2014}at 000Fh, and <<0012h|1>>, and <<0015h|1>>, and <<0018h|1>>, and 001Bh, and 001Eh. What if one of these bytes just happens to be an 11h? That's a Store instruction. And what if the 2 bytes following that Store instruction happened to refer to address <<0023h|1>>? That would cause the machine to write the contents of the accumulator to that address. But that address contains something important already! And even if nothing like this happened, the next instruction byte that the adder retrieves from memory after the one at 001Eh will be at address <<0021h|1>>, not <<0020h|1>>, which is where our next real instruction happens to be.",
          ],
          [
            1,
            '[00:00] Code - Charles Petzold.epub (OEBPS/ch17.html) - 0000h',
            'So in the preceding example, the automated adder begins at <<0000h|1>>, as usual, and does a Load instruction, an Add, a Subtract, and a Store. It then does the Jump instruction and continues at address <<0020h|1>> with a Load, two Add instructions, a Store, and finally Halt.',
          ],
          [
            1,
            '[ap 00:58] Code - Charles Petzold.epub (OEBPS/ch17.html) - 2-to-1',
            'Otherwise, the changes aren\'t severe. The 16-bit address that\'s latched from the RAM array is an input to both the <<2-to-1|10a:0>> Selector (which allows this address to be an address input to the RAM array) and the 16-bit counter for the Set It function:',
          ],
          [
            1,
            '[10:04] Code - Charles Petzold.epub (OEBPS/ch17.html) - 1004h',
            'Everyone knows that multiplying A7h and 1Ch (which is 28 in decimal) is the same as 28 additions of A7h. So the 16-bit location at addresses <<1004h|1>> and <<1005h|1>> will actually be an accumulated summation. Here\'s the code for adding A7h to that location once:',
          ],
          [
            1,
            '[10:04] Code - Charles Petzold.epub (OEBPS/ch17.html) - 1004h',
            'At the completion of these six instructions, the 16-bit value at memory locations <<1004h|1>> and <<1005h|1>> will equal A7h times 1. Therefore, these six instructions have to be repeated 27 more times in order for that 16-bit value to equal A7h times 1Ch. You can achieve this by typing in these six instructions 27 more times beginning at address <<0012h|1>>. Or you can put a Halt instruction at <<0012h|1>> and press the Reset button 28 times to get the final answer.',
          ],
          [
            1,
            '[00:12] Code - Charles Petzold.epub (OEBPS/ch17.html) - 0012h',
            'But what if you put a Jump instruction at <<0012h|1>>? This instruction causes the counter to start from <<0000h|1>> again:',
          ],
          [
            1,
            '[10:04] Code - Charles Petzold.epub (OEBPS/ch17.html) - 1004h',
            'This certainly does the trick (sort of). The first time through, the 16-bit value at memory locations <<1004h|1>> and <<1005h|1>> will equal A7h times 1. Then the Jump instruction will go back up to the top. At the end of the second time through, the 16-bit result will equal A7h times 2. Eventually, it will equal A7h times 1Ch, but there\'s no stopping it. It just keeps going and going and going.',
          ],
          [
            1,
            '[00:12] Code - Charles Petzold.epub (OEBPS/ch17.html) - 0012h',
            'Now all that\'s necessary to make the code shown above multiply two numbers are the following instructions starting at address <<0012h|1>>:',
          ],
          [
            1,
            '[00:04] Code - Charles Petzold.epub (OEBPS/ch17.html) - 0004h',
            'The first time through, the 16-bit location at <<0004h|1>> and <<0005h|1>> contains A7h times 1, as we\'ve already established. The instructions here load the byte from location <<1003h|1>> into the accumulator. This is 1Ch. This byte is added to the value at location 001Eh. This happens to be the Halt instruction, but of course it\'s also a valid number. Adding FFh to 1Ch is the same as subtracting 1 from 1Ch, so the result is 1Bh. This isn\'t 0, so the Zero flag is 0. The 1Bh byte is stored back at address <<1003h|1>>. Next is a Jump If Not Zero instruction. The Zero flag isn\'t set to 1, so the jump occurs. The next instruction is the one located at address <<0000h|1>>.',
          ],
          [
            1,
            '[10:04] Code - Charles Petzold.epub (OEBPS/ch17.html) - 1004h',
            'The second time through, the 16-bit location at <<1004h|1>> and <<1005h|1>> will contain the value A7h times 2. The value 1Bh is added to FFh to get the result 1Ah. That\'s not 0, so back to the top.',
          ],
          [
            1,
            '[10:04] Code - Charles Petzold.epub (OEBPS/ch17.html) - 1004h',
            'On the twenty-eighth time through, the 16-bit location at <<1004h|1>> and <<1005h|1>> will contain the value A7h times 1Ch. At location <<1003h|1>> will be the value 1. This will be added to FFh and the result will be zero. The Zero flag will be set! So the Jump If Not Zero instruction will not jump back to <<0000h|1>>. Instead, the next instruction is a Halt. We\'re done.',
          ],
          [
            1,
            '[07:00] Code - Charles Petzold.epub (OEBPS/ch17.html) - seven this morning',
            'Computer programming is sometimes also referred to as writing code, or coding, as in, "I spent my vacation coding" or "I was up until <<seven this morning|5>> banging out some code." Sometimes computer programmers are known as coders, although some might consider this a derogatory term. Such programmers might prefer to be called software engineers.',
          ],
          [
            1,
            '[10:03] Code - Charles Petzold.epub (OEBPS/ch17.html) - 1003h',
            'These mnemonics are particularly useful when combined with a couple of other shortcuts. For example, instead of saying something long-winded like, "Load byte at address <<1003h|1>> into accumulator," we can instead write the statement:',
          ],
          [
            1,
            '[10:03] Code - Charles Petzold.epub (OEBPS/ch17.html) - 1003h',
            'LOD A,[<<1003h|1>>]The A and the [1003] that appear to the right of the mnemonic are called arguments that indicate what\'s going on with this particular Load instruction. The arguments are written with a destination on the left (the A stands for accumulator) and a source on the right. The brackets indicate that the accumulator should be loaded not with the value <<1003h|1>> but with the value stored in memory at address <<1003h|1>>.',
          ],
          [
            1,
            '[10:03] Code - Charles Petzold.epub (OEBPS/ch17.html) - 1003h',
            'Similarly, the instruction "Add byte at address 001Eh to accumulator" can be shortened to
ADD A,[001Eh]and "Store contents of accumulator at address <<1003h|1>>" is
STO [<<1003h|1>>],ANotice that the destination (a memory location for the Store instruction) is still on the left and the source is on the right. The contents of the accumulator must be stored in memory at address <<1003h|1>>. The wordy "Jump to <<0000h|1>> if the Zero flag is not 1" is more concisely written as',
          ],
          [
            1,
            '[10:03] Code - Charles Petzold.epub (OEBPS/ch17.html) - 1003h',
            'STO [<<1003h|1>>],ANotice that the destination (a memory location for the Store instruction) is still on the left and the source is on the right. The contents of the accumulator must be stored in memory at address <<1003h|1>>. The wordy "Jump to <<0000h|1>> if the Zero flag is not 1" is more concisely written as',
          ],
          [
            1,
            '[00:00] Code - Charles Petzold.epub (OEBPS/ch17.html) - 0000h',
            'JNZ 0000hThe brackets aren\'t used in this instruction because the instruction jumps to address <<0000h|1>>, not to the value that might be stored at address <<0000h|1>>.',
          ],
          [
            1,
            '[00:00] Code - Charles Petzold.epub (OEBPS/ch17.html) - 0000h',
            '<<0000h|1>>:    LOD A,[<<1005h|1>>]And here\'s how we can indicate some data stored at a particular address:',
          ],
          [
            1,
            '[10:00] Code - Charles Petzold.epub (OEBPS/ch17.html) - 1000h',
            '<<1000h|1>>:   00h, A7h
<<1002h|1>>:   00h, 1Ch
<<1004h|1>>:   00h, 00hThe 2 bytes separated by commas indicate that the first byte is stored at the address on the left and the second byte is stored at the next address. These three lines are equivalent to',
          ],
          [
            1,
            '[10:00] Code - Charles Petzold.epub (OEBPS/ch17.html) - 1000h',
            '<<1000h|1>>:    00h,  A7h,  00h,  1Ch,  00h,  00hSo the entire multiplication program can be written as a series of statements like this:',
          ],
          [
            1,
            '[00:00] Code - Charles Petzold.epub (OEBPS/ch17.html) - 0000h',
            '<<0000h|1>>:    LOD A,[<<1005h|1>>]
          ADD A,[<<1001h|1>>]
          STO [<<1005h|1>>],A

          LOD A,[<<1004h|1>>]
          ADC A,[<<1000h|1>>]
          STO [<<1004h|1>>],A

          LOD A,[<<1003h|1>>]
          ADD A,[001Eh]
          STO [<<1003h|1>>],A

          JNZ <<0000h|1>>

001Eh:    HLT

<<1000h|1>>:    00h, A7h
<<1002h|1>>:    00h, 1Ch
<<1004h|1>>:    00h, 00hThe judicious use of blank lines and other white space is simply to make the whole program more readable for human beings like you and me.',
          ],
          [
            1,
            '[20:00] Code - Charles Petzold.epub (OEBPS/ch17.html) - 2000h',
            'It\'s better not to use actual numeric addresses when writing code because they can change. For example, if you decided to store the numbers at memory locations <<2000h|1>> through <<20005h|1>>, you\'d need to rewrite many of the statements as well. It\'s better to use labels to refer to locations in memory. These labels are simply words, or they look almost like words, like this:',
          ],
          [
            1,
            '[ap 02:56] Code - Charles Petzold.epub (OEBPS/ch17.html) - 256',
            'There\'s even a bug in my multiplication program. If you run it twice, the second time through it will multiply A7h by <<256|3:0>> and add that result to the result already calculated. This is because after you run the program once, the number at address <<1003h|1>> will be 0. When you run it the second time, FFh will be added to that value. The result won\'t be 0, so the program will keep running until it is.',
          ],
          [
            1,
            '[~ 19:45] Code - Charles Petzold.epub (OEBPS/ch17.html) - around 1945',
            'I\'ve mentioned several times that all the hardware to build these devices was available over a hundred years ago. But it\'s unlikely that the computer shown in this chapter could have been built at that time. Many of the concepts implicit in its design weren\'t apparent when relay computers were first built in the mid-1930s and only started to be understood <<around 1945|18:0>> or so. Until that time, for example, people were still trying to build computers that internally used decimal numbers rather than binary. And computer programs weren\'t always stored in memory but instead were sometimes coded on paper tape. In particular, in the early days of computers, memory was expensive and bulky. Building a 64-KB RAM array from five million telegraph relays would have been as absurd one hundred years ago as it is now.',
          ],
          [
            1,
            '[ap ~ 00:00] Code - Charles Petzold.epub (OEBPS/ch18.html) - around 1200',
            'Although commonly associated with Asian cultures, the abacus seems to have been introduced to China by traders <<around 1200|18:0>> CE.',
          ],
          [
            1,
            '[~ 16:20] Code - Charles Petzold.epub (OEBPS/ch18.html) - around 1620',
            "Napier also invented another multiplication aid, which is composed of strips of numbers usually inscribed on bone, horn, or ivory and hence referred to as Napier's Bones. The earliest mechanical calculator was a somewhat automated version of Napier's bones built <<around 1620|18:0>> by Wilhelm Schickard (1592\x{2013}1635). Other calculators based on interlocking wheels, gears, and levers are almost as old. Two of the more significant builders of mechanical calculators were the mathematicians and philosophers Blaise Pascal (1623\x{2013}1662) and Gottfried Wilhelm von Leibniz (1646\x{2013}1716).",
          ],
          [
            1,
            '[~ 18:20] Code - Charles Petzold.epub (OEBPS/ch18.html) - about 1820',
            'Beginning <<about 1820|18:0>>, Babbage believed that he could design and build a machine that would automate the process of constructing a table, even to the point of setting up type for printing. This would eliminate errors. He conceived the Difference Engine, and basically it was a big mechanical adding machine. Multidigit decimal numbers were represented by geared wheels that could be in any of 10 positions. Negatives were handled using the ten\'s complement. Despite some early models that showed Babbage\'s design to be sound and some grants from the British government (never enough, of course), the Difference Engine was never completed. Babbage abandoned work on it in 1833.',
          ],
          [
            1,
            '[19:11] Code - Charles Petzold.epub (OEBPS/ch18.html) - 1911',
            "Herman Hollerith also set in motion a long trail of events. In 1896, he founded the Tabulating Machine Company to lease and sell the punch-card equipment. By <<1911|9n:0>>, with the help of a couple of mergers, it had become the Computing-Tabulating-Recording Company, or C-T-R. By <<1915|9n:0>>, the president of C-T-R was Thomas J. Watson (1874\x{2013}1956), who in 1924 changed the name of the company to International Business Machines Corporation, or IBM.",
          ],
          [
            1,
            '[19:28] Code - Charles Petzold.epub (OEBPS/ch18.html) - 1928',
            "By <<1928|9n:0>>, the original 1890 census cards had evolved into the famous \"do not spindle, fold, or mutilate\" IBM cards, with 80 columns and 12 rows. They remained in active use for over 50 years, and even in their later years were sometimes referred to as Hollerith cards. I'll describe the legacy of these cards more in Chapters Chapter\x{a0}20, Chapter\x{a0}21, and Chapter\x{a0}24.",
          ],
          [
            1,
            '[19:45] Code - Charles Petzold.epub (OEBPS/ch18.html) - 1945',
            'But beginning in the early 1940s, vacuum tubes began supplanting relays in new computers. By <<1945|9n:0>>, the transition was complete. While relay machines were known as electromechanical computers, vacuum tubes were the basis of the first electronic computers.',
          ],
          [
            1,
            '[ap ~ 10:24] Code - Charles Petzold.epub (OEBPS/ch18.html) - about 1024',
            'At the time of the EDVAC, it wasn\'t cost effective to build a lot of memory out of vacuum tubes. Some very odd solutions were proposed instead. One successful one was mercury delay line memory, which used 5-foot tubes of mercury. At one end of the tube, little pulses were sent into the mercury about 1 microsecond apart. These pulses took about a millisecond to reach the other end (where they were detected like sound waves and routed back to the beginning), and hence each tube of mercury could store <<about 1024|18:0>> bits of information.',
          ],
          [
            1,
            '[19:56] Code - Charles Petzold.epub (OEBPS/ch18.html) - until 1956',
            'The transistor didn\'t come out of the blue. Eight years earlier, on December 29, 1939, Shockley had written in his notebook, "It has today occurred to me that an amplifier using semiconductors rather than vacuum is in principle possible." And after that first transistor was demonstrated, many years followed in perfecting it. It wasn\'t <<until 1956|18:0>> that Shockley, Bardeen, and Brattain were awarded the Nobel Prize in physics "for their researches on semiconductors and their discovery of the transistor effect."',
          ],
          [
            1,
            '[~ 20:15] Code - Charles Petzold.epub (OEBPS/ch18.html) - about 2015',
            'In 1965, Gordon E. Moore (then at Fairchild and later a cofounder of Intel Corporation) noticed that technology was improving in such a way that the number of transistors that could fit on a single chip had doubled every year since 1959. He predicted that this trend would continue. The actual trend was a little slower, so Moore\'s Law (as it was eventually called) was modified to predict a doubling of transistors on a chip every 18 months. This is still an astonishingly fast rate of progress and reveals why home computers always seem to become outdated in just a few short years. Some people believe that Moore\'s Law will continue to be accurate until <<about 2015|9c:0>>.',
          ],
          [
            1,
            '[ap 05:25] Code - Charles Petzold.epub (OEBPS/ch18.html) - 5.25',
            'For 7400 series TTL, VCC must be between 4.75 and <<5.25|5a:0>> volts. Another way of saying this is that the power supply voltage must be 5 volts plus or minus 5 percent. If the power supply is below 4.75 volts, the chip might not work. If it\'s higher than <<5.25|5a:0>>, the chip could be damaged. You generally can\'t use batteries with TTL; even if you were to find a 5-volt battery, the voltage wouldn\'t be exact enough to be adequate for these chips. TTL usually requires a power supply that you plug into the wall.',
          ],
          [
            1,
            '[ap 05:25] Code - Charles Petzold.epub (OEBPS/ch18.html) - 5.25',
            "The power supply requirement for TTL is 4.75 to <<5.25|5a:0>> volts. For CMOS, it's anything from 3 volts to 18 volts. That's quite a leeway! Moreover, CMOS requires much less power than TTL, which makes it feasible to run small CMOS circuits from batteries. The drawback of CMOS is lack of speed. For example, the CMOS 4008 4-bit full adder running at 5 volts is only guaranteed to have a propagation time of 750 nanoseconds. It gets faster as the power supply gets higher\x{2014}250 nsec at 10 volts and 190 nsec at 15 volts. But the CMOS device doesn't come close to the TTL 4-bit adder, which has a propagation time of 24 nsec. (Twenty-five years ago, the trade-off between the speed of TTL and the low power requirements of CMOS was fairly clear cut. Today there are low-power versions of TTL and high-speed versions of CMOS.)",
          ],
          [
            1,
            '[ap 02:00] Code - Charles Petzold.epub (OEBPS/ch18.html) - 200',
            "But back to the mid-1970s. Despite the limitations of the 4004, it was a start. By April 1972, Intel had released the 8008\x{2014}an 8-bit microprocessor running at <<200|3:0>> kHz that could address 16 KB of memory. (See how easy it is to sum up a processor with just three numbers?) And then, in a five-month period in 1974, both Intel and Motorola came out with microprocessors that were intended to improve on the 8008. These two chips changed the world.",
          ],
          [
            1,
            '[~ 23:00] Code - Charles Petzold.epub (OEBPS/ch19.html) - about 2300',
            "The microprocessor\x{2014}a consolidation of all the components of a central processing unit (CPU) of a computer on a single chip of silicon\x{2014}was born in 1971. It was a modest beginning: The first microprocessor, the Intel 4004, contained <<about 2300|18:0>> transistors. Today, nearly three decades later, microprocessors made for home computers are approaching the 10,000,000 transistor mark.",
          ],
          [
            1,
            '[00:00] Code - Charles Petzold.epub (OEBPS/ch19.html) - 0000h',
            'After the 8080 chip is reset, it reads the byte located at memory address <<0000h|1>> into the microprocessor. It does this by outputting 16 zeros on the address signals A0 through A15. The byte it reads should be an 8080 instruction, and the process of reading this byte is known as an instruction fetch.',
          ],
          [
            1,
            '[17:56] Code - Charles Petzold.epub (OEBPS/ch19.html) - 4 to 18',
            "When the 8080 is running at its maximum speed of 2 MHz, each clock cycle is 500 nanoseconds. (1 \x{f7} 2,000,000 cycles per second = 0.000000500 seconds.) The instructions in the Chapter\x{a0}17 computer all required 4 clock cycles. Each 8080 instruction requires anywhere from <<4 to 18|10a:1>> clock cycles. This means that each instruction is executed in <<2 to 9|10a:1>> microseconds (millionths of a second).",
          ],
          [
            1,
            '[00:00] Code - Charles Petzold.epub (OEBPS/ch19.html) - 0000',
            'The DAA instruction helps a programmer implement decimal arithmetic using a method of representing numbers known as binary-coded decimal, or BCD. In BCD, each nibble of data may range only from <<0000|18:0>> through 1001, corresponding to decimal digits 0 through 9. The 8 bits of a byte can store two decimal digits in BCD format.',
          ],
          [
            1,
            '[00:00] Code - Charles Petzold.epub (OEBPS/ch19.html) - 0000h',
            'If you have 64 KB of memory connected to your 8080, you might want to initially set the Stack Pointer to <<0000h|1>>. The first PUSH instruction decrements that address to FFFFh. The stack then occupies the area of memory with the very highest addresses, quite a distance from your programs, which will probably be in the area of memory starting at address <<0000h|1>>.',
          ],
          [
            1,
            '[00:00] Code - Charles Petzold.epub (OEBPS/ch19.html) - 0000h',
            '<<0000h|1>>:     LXI SP,0000hIt\'s also possible to increment and decrement register pairs and the Stack Pointer as if they were 16-bit registers:',
          ],
          [
            1,
            '[00:00] Code - Charles Petzold.epub (OEBPS/ch19.html) - 0000h',
            'Multiply:    PUSH PSW         ; Save registers being altered
             PUSH BC

             SUB H,H          ; Set HL (result) to <<0000h|1>>
             SUB L,L

             MOV A,B          ; The multiplier goes in A
             CPI A,00h        ; If it\'s <<0|9c:0>>, we\'re finished.
             JZ AllDone

             MVI B,00h        ; Set high byte of BC to 0

MultLoop:    DAD HL,BC        ; Add BC to HL
             DEC A            ; Decrement multiplier
             JNZ MultLoop     ; Loop if it\'s not 0

AllDone:     POP BC           ; Restore saved registers
             POP PSW
             RET              ; ReturnNotice that the first line of the subroutine begins with a label, which is the word Multiply. This label, of course, actually corresponds to a memory address where the subroutine is located. The subroutine begins with two PUSH instructions. Usually a subroutine should attempt to save (and later restore) any registers that it might need to use.',
          ],
          [
            1,
            '[00:00] Code - Charles Petzold.epub (OEBPS/ch19.html) - 0',
            'Next the subroutine moves the contents of register B (the multiplier) into A and checks if it\'s <<0|9c:0>>. If it\'s <<0|9c:0>>, the multiplication subroutine is complete because the product is 0. Since registers H and L are already 0, the subroutine can just use the JZ (Jump If Zero) instruction to skip to the two POP instructions at the end.',
          ],
          [
            1,
            '[00:00] Code - Charles Petzold.epub (OEBPS/ch19.html) - 0000h',
            "These are called Restart instructions, and they're similar to Call instructions in that the current Program Counter is saved on the stack. But the Restart instructions then jump to specific locations: RST 0 jumps to address <<0000h|1>>, RST 1 to address <<0008h|1>>, and so forth, up to RST 7, which jumps to address <<0038h|1>>. Located at these addresses are sections of code that deal with the interrupt. For example, an interrupt from the keyboard might cause a RST 4 instruction to be executed. At address <<0020h|1>> begins some code to read a byte from the keyboard. (I'll explain this more fully in Chapter\x{a0}21.)",
          ],
          [
            1,
            '[~ 17:50] Code - Charles Petzold.epub (OEBPS/ch20.html) - about 1750',
            "For example, a traditional double-spaced typewritten 8\x{bd}-by-11-inch page with 1-inch margins has about 27 lines of text. Each line is about 6\x{bd} inches wide with 10 characters per inch, for a total of <<about 1750|18:0>> bytes. A singlespace typewritten page has about double that, or 3.5 kilobytes.",
          ],
          [
            1,
            '[ap ~ 05:00] Code - Charles Petzold.epub (OEBPS/ch20.html) - about 500',
            "A hardcover book has <<about 500|18:0>> words per page. An average word is about 5 letters\x{2014}actually 6 characters, counting the space between words. So a book has about 3000 characters per page. Let's say the average book has 333 pages, which may be a made-up figure but nicely implies that the average book is about 1 million bytes, or 1 megabyte.",
          ],
          [
            1,
            '[ap ~ 03:00] Code - Charles Petzold.epub (OEBPS/ch20.html) - about 300',
            'F. Scott Fitzgerald\'s The Great Gatsby is <<about 300|18:0>> kilobytes.J. D. Salinger\'s Catcher in the Rye is <<about 400|18:0>> kilobytes.Mark Twain\'s The Adventures of Huckleberry Finn is <<about 540|18:0>> kilobytes.John Steinbeck\'s The Grapes of Wrath is about a megabyte.Herman Melville\'s Moby Dick is about 1.3 megabytes.Henry Fielding\'s The History of Tom Jones is <<about 2.25|5a:0>> megabytes.Margaret Mitchell\'s Gone with the Wind is about 2.5 megabytes.Stephen King\'s complete and uncut The Stand is about 2.7 megabytes.Leo Tolstoy\'s War and Peace is about 3.9 megabytes.Marcel Proust\'s Remembrance of Things Past is about 7.7 megabytes.The United States Library of Congress has about 20 million books for a total of 20 trillion characters, or 20 terabytes, of text data. (It has a bunch of photographs and sound recordings as well.)',
          ],
          [
            1,
            '[00:00] Code - Charles Petzold.epub (OEBPS/ch20.html) - 0000h',
            'Under the assumption that it\'s preferable to have just one unambiguous character encoding system that\'s suitable for all the world\'s languages, in 1988 several major computer companies got together and began developing an alternative to ASCII known as Unicode. Whereas ASCII is a 7-bit code, Unicode is a 16-bit code. Each and every character in Unicode requires 2 bytes. That means that Unicode has character codes ranging from <<0000h|1>> through FFFFh and can represent 65,536 different characters. That\'s enough for all the world\'s languages that are likely to be used in computer communication, with room for expansion.',
          ],
          [
            1,
            '[00:00] Code - Charles Petzold.epub (OEBPS/ch20.html) - 0000h',
            "Unicode doesn't start from scratch. The first 128 characters of Unicode\x{2014}codes <<0000h|1>> through 007Fh\x{2014}are the same as the ASCII characters. Also, Unicode codes 00A0h through 00FFh are the same as the Latin Alphabet No. 1 extension of ASCII that I described earlier. Other worldwide standards are also incorporated into Unicode.",
          ],
          [
            1,
            '[ap ~ 02:00] Code - Charles Petzold.epub (OEBPS/ch20.html) - about 2',
            'The only real problem with Unicode is that it makes invalid the old equivalence between one character of text and 1 byte of storage. Encoded in ASCII, The Grapes of Wrath is about 1 megabyte in size. Encoded in Unicode, it\'s <<about 2|9:0>> megabytes. But that\'s a small price to pay for a universal unambiguous character encoding system.',
          ],
          [
            1,
            '[00:00] Code - Charles Petzold.epub (OEBPS/ch21.html) - 0000h',
            'Because the S-100 bus was designed for the 8080 chip, it has 16 address signals, 8 data input signals, and 8 data output signals. (As you\'ll recall, the 8080 itself combines the data input and data output signals. These signals are divided into separate input and output signals by other chips on the circuit board that contains the 8080.) The bus also includes 8 interrupt signals. These are signals generated by other devices when they need immediate attention from the CPU. For example (as we\'ll see later in this chapter), a keyboard might generate an interrupt signal when a key is pressed. A short program run by the 8080 can then determine what that key was and take some action. The board containing the 8080 also generally includes a chip called the Intel 8214 Priority Interrupt Control Unit to handle these interrupts. When an interrupt occurs, this chip generates an interrupt signal to the 8080. When the 8080 acknowledges the interrupt, the chip provides a RST (Restart) instruction that causes the microprocessor to save the current program counter and branch to address <<0000h|1>>, <<0008h|1>>, <<0010h|1>>, <<0018h|1>>, <<0020h|1>>, <<0028h|1>>, <<0030h|1>>, or <<0038h|1>> depending on the interrupt.',
          ],
          [
            1,
            '[15:52] Code - Charles Petzold.epub (OEBPS/ch21.html) - 8 to 16',
            'Busses need to be upgraded or replaced when microprocessors outgrow them, either in data width (from <<8 to 16|10a:1>> to 32 bits) or in the number of address signals they output. But microprocessors also outgrow busses when they achieve faster speeds. Early busses were designed for microprocessors operating at a clock speed of several megahertz rather than several hundred megahertz. When a bus isn\'t properly designed for high speeds, it can give off radio frequency interference (RFI) that causes static or other noise on nearby radios and television sets.',
          ],
          [
            1,
            '[00:00] Code - Charles Petzold.epub (OEBPS/ch21.html) - 0000h',
            "The 10 address signals A0 through A9 are directly wired to the RAM chips. The address signals A10 and A11 select which of the four banks is being addressed. The address signals A12 through A15 determine which addresses apply to this particular board\x{2014}in other words, the addresses that the board responds to. The 4-KB memory board we're designing can occupy one of 16 different 4-KB ranges in the entire 64-KB memory space of the microprocessor:
<<0000h|1>> through 0FFFh, or
<<1000h|1>> through 1FFFh, or",
          ],
          [
            1,
            '[00:00] Code - Charles Petzold.epub (OEBPS/ch21.html) - 0000h',
            '<<0000h|1>> through 0FFFh, or
<<1000h|1>> through 1FFFh, or
<<2000h|1>> through 2FFFh, or',
          ],
          [
            1,
            '[10:00] Code - Charles Petzold.epub (OEBPS/ch21.html) - 1000h',
            "<<1000h|1>> through 1FFFh, or
<<2000h|1>> through 2FFFh, or
\x{22ee}",
          ],
          [
            1,
            '[ap 00:56] Code - Charles Petzold.epub (OEBPS/ch21.html) - 4-to-1',
            "If you recall the messy details of combining RAM arrays in Chapter\x{a0}16, you might assume that we also need eight <<4-to-1|10a:0>> Selectors to select the correct data output signals from the four banks of memory. But we don't, and here's why.",
          ],
          [
            1,
            '[ap ~ 04:00] Code - Charles Petzold.epub (OEBPS/ch21.html) - about 400',
            'For black and white television, this video signal is quite straightforward and easy to comprehend. (Color gets a bit messier.) Sixty times per second, the signal contains a vertical sync pulse that indicates the beginning of a field. This pulse is 0 volts (ground) for <<about 400|18:0>> microseconds. A horizontal sync pulse indicates the beginning of each scan line: The video signal is 0 volts for 5 microseconds 15,750 times per second. Between the horizontal sync pulses, the signal varies from 0.5 volt for black to 2 volts for white, with voltages between 0.5 volt and 2 volts to indicate shades of gray.',
          ],
          [
            1,
            '[ap ~ 03:20] Code - Charles Petzold.epub (OEBPS/ch21.html) - about 320',
            "The video bandwidth enforces a limit to the number of pixels that can fit in a horizontal scan line. I defined the bandwidth as the speed with which the video signal can change from black to white and back to black again. A bandwidth of 4.2 MHz for television sets allows two pixels 4.2 million times a second, or\x{2014}dividing 2 x 4,200,000 by the horizontal scan rate of 15,750\x{2014} 533 pixels in each horizontal scan line. But about a third of these pixels aren't available because they're hidden from view\x{2014}either at the far ends of the image or while the light beam is in the horizontal retrace. That leaves <<about 320|18:0>> useful pixels horizontally.",
          ],
          [
            1,
            '[ap 02:00] Code - Charles Petzold.epub (OEBPS/ch21.html) - 200',
            'We can thus say that the resolution of a primitive video display adapter attached to a conventional television set is 320 pixels across by <<200|3:0>> pixels down, or 320 pixels horizontally by <<200|3:0>> pixels vertically, commonly referred to as 320 by <<200|3:0>> or 320 x 200:',
          ],
          [
            1,
            '[ap 02:00] Code - Charles Petzold.epub (OEBPS/ch21.html) - 200',
            'To determine the total number of pixels in this grid, you can count them or simply multiply 320 by <<200|3:0>> to get 64,000 pixels. Depending on how you\'ve configured your video adapter (as I\'ll explain shortly), each pixel can be either black or white, or each pixel can be a particular color.',
          ],
          [
            1,
            '[ap 03:20] Code - Charles Petzold.epub (OEBPS/ch21.html) - 320',
            'Using these character definitions, you can fit 25 lines of 40 characters each on the <<320|3c>> x 200 video display, which (for example) is enough to fit an entire short poem by Amy Lowell:',
          ],
          [
            1,
            '[ap ~ 10:24] Code - Charles Petzold.epub (OEBPS/ch21.html) - approximately 1024',
            'Let\'s start with the low estimate. One way to reduce the memory requirements of a video display adapter is to restrict the adapter to text only. We\'ve already established that we can display 25 rows of 40 characters each, or a total of 1000 characters. The RAM on the video board need only store the 7-bit ASCII codes of those 1000 characters. That\'s 1000 7-bit values, which is <<approximately 1024|9n:0>> bytes, or 1 kilobyte.',
          ],
          [
            1,
            '[ap 02:00] Code - Charles Petzold.epub (OEBPS/ch21.html) - 200',
            "If the video adapter board is not restricted to text only, it's referred to as a graphics board. By writing into the RAM on a graphics video board, a microprocessor can draw pictures, including text in a multitude of sizes and styles. Graphics video boards require more memory than text-only boards. A graphics video board that displays 320 pixels across by <<200|3:0>> pixels down has 64,000 pixels. If each pixel corresponds to one bit of RAM, such a board requires 64,000 bits of RAM, or 8000 bytes. This, however, is the rock-bottom minimum. A correspondence of 1 bit to 1 pixel allows the use of only two colors\x{2014}for instance, black and white. A 0 bit might correspond to a black pixel, and a 1 bit might correspond to a white pixel.",
          ],
          [
            1,
            '[ap 01:33] Code - Charles Petzold.epub (OEBPS/ch21.html) - 1.33',
            'The 640-by-480 resolution was a significant milestone, but you might not believe that the reason for its importance goes back to Thomas Edison! Around 1889, when Edison and his engineer William Kennedy Laurie Dickson were working on the Kinetograph motion picture camera and the Kinetoscope projector, they decided to make the motion picture image one-third wider than it was high. The ratio of the width of the image to its height is called the aspect ratio. The ratio that Edison and Dickson established is commonly expressed as <<1.33|5a:0>> to 1, or <<1.33|5a:0>>:1, or, to avoid fractions, 4:3. This aspect ratio was used for most movies for over 60 years, and it was also used for television. Only in the early 1950s did the Hollywood studios introduce some widescreen techniques that competed against television by going beyond the 4:3 aspect ratio.',
          ],
          [
            1,
            '[ap 06:00] Code - Charles Petzold.epub (OEBPS/ch21.html) - 600',
            'Today\'s video adapters and monitors almost always do 640 by 480 but are also capable of various additional video modes, often including resolutions of 800 by <<600|3:0>>, 1024 by 768, 1280 by <<960|3:0>>, and 1600 by <<1200|3:0>>.',
          ],
          [
            1,
            '[00:00] Code - Charles Petzold.epub (OEBPS/ch21.html) - 0000',
            'To prevent my diagram of the keyboard hardware from becoming unwieldy, I\'m going to assume that our keyboard has a mere 16 keys. Whenever a key is pressed, the keyboard hardware should generate a 4-bit code with binary values ranging from <<0000|18:0>> through 1111.',
          ],
          [
            1,
            '[ap 01:10] Code - Charles Petzold.epub (OEBPS/ch21.html) - 0110',
            'The outputs of the 4-bit counter are the select inputs of both a 2-Line-to-4-Line Decoder and a 4-Line-to-1-Line Data Selector. If no keys are pressed, none of the inputs to the selector can be 1. Therefore the output of the selector isn\'t 1. But if a particular key is pressed, at a particular 4-bit counter output the output from the selector will be 1. For example, if the switch second from the top and right is pressed, and if the counter output is <<0110|18:0>>, the output from the selector becomes 1:',
          ],
          [
            1,
            '[ap 07:57] Code - Charles Petzold.epub (OEBPS/ch21.html) - 3-to-8',
            'If your keyboard has 64 keys, you need a 6-bit scan code. That would involve a 6-bit counter. You could arrange the keys in an 8x8 array, using a <<3-to-8|10a:0>> Decoder and a <<1-of-8|10>> Selector. If your keyboard has between 65 and 128 keys, you need a 7-bit code. You could arrange the keys in an 8x16 array and use a <<4-to-16|10a:0>> Decoder and an <<8-to-1|10a:0>> Selector (or a <<3-to-8|10a:0>> Decoder and a <<16-to-1|10a:0>> Selector).',
          ],
          [
            1,
            '[00:00] Code - Charles Petzold.epub (OEBPS/ch22.html) - 0000h',
            'What we\'re missing here is software. When a microprocessor is first turned on or reset, it begins executing machine code at a particular memory address. In the case of the Intel 8080, that address is <<0000h|1>>. In a properly designed computer, that memory address should contain a machine-code instruction (most likely the first of many) when the computer is turned on.',
          ],
          [
            1,
            '[ap 09:00] Code - Charles Petzold.epub (OEBPS/ch22.html) - 0 to 9',
            'NibbleToAscii: CPI A,0Ah ; Check if it\'s a letter or number
               JC Number
               ADD A,37h ; A to F converted to 41h to 46h
               RET
Number:        ADD A,30h ; <<0 to 9|10a:0>> converted to 30h to 39h
               RETThis subroutine calls NibbleToAscii twice to convert a byte in accumulator <<A to two|10>> ASCII digits in registers B and C:',
          ],
          [
            1,
            '[00:08] Code - Charles Petzold.epub (OEBPS/ch22.html) - 0008h',
            'The key, of course, is the keyboard. We\'ve constructed the computer keyboard so that every time a key is pressed, an interrupt to the microprocessor occurs. The interrupt controller chip that we\'ve used in our computer causes the microprocessor to respond to this interrupt by executing a RST (Restart) instruction. Let\'s suppose that this is a RST 1 instruction. This instruction causes the microprocessor to save the current program counter on the stack and to jump to address <<0008h|1>>. Beginning at that address, you\'ll enter some code (using the control panel) that we\'ll call the keyboard handler.',
          ],
          [
            1,
            '[10:20] Code - Charles Petzold.epub (OEBPS/ch22.html) - 1020h',
            "W 1020 35 4F 78 23 9B AC 67This command instructs the command processor to write the hexadecimal bytes 35, 4F, and so on into the memory addresses beginning at address <<1020h|1>>. For this job, the keyboard handler needs to convert ASCII codes to bytes\x{2014}a reversal of the conversion I demonstrated earlier.",
          ],
          [
            1,
            '[10:30] Code - Charles Petzold.epub (OEBPS/ch22.html) - 1030h',
            'D 1030The command processor responds by displaying the 11 bytes stored beginning at location <<1030h|1>>. (I say 11 bytes because that\'s how many will fit on a 40-characterwide display on the same line following the address.) You can use the Display command to examine the contents of memory.',
          ],
          [
            1,
            '[10:00] Code - Charles Petzold.epub (OEBPS/ch22.html) - 1000h',
            'R 1000and means "Run the program that\'s stored beginning at address <<1000h|1>>." The command processor stores <<1000h|1>> in the register pair HL and then executes the instruction PCHL, which loads the program counter from register pair HL, effectively jumping to that address.',
          ],
          [
            1,
            '[00:00] Code - Charles Petzold.epub (OEBPS/ch22.html) - 0000h',
            'As you\'ll recall, we wired our RAM boards with a DIP switch that allows us to specify the starting address of the board. If you\'re working with an 8080 system, initially one of your RAM boards will be set for address <<0000h|1>>. After you create a ROM, that ROM will occupy address <<0000h|1>> and the RAM board can be switched to a higher address.',
          ],
          [
            1,
            '[01:00] Code - Charles Petzold.epub (OEBPS/ch22.html) - 0100h',
            'If you type in a command that CP/M doesn\'t recognize, it assumes you\'re specifying the name of a program that\'s stored as a file on the disk. Programs always have the file type COM, which stands for Command. The CCP searches for a file of that name on the disk. If one exists, CP/M loads the file from disk into the Transient Program Area, which begins at memory address <<0100h|1>>. This is how you run programs that are located on the disk. For example, if you type',
          ],
          [
            1,
            '[01:00] Code - Charles Petzold.epub (OEBPS/ch22.html) - 0100h',
            'CALCfollowing the CP/M prompt, and if a file named CALC.COM exists on the disk, the CCP loads that file into memory starting at address <<0100h|1>> and then executes the program by jumping to the machine-code instruction located at address <<0100h|1>>.',
          ],
          [
            1,
            '[01:00] Code - Charles Petzold.epub (OEBPS/ch22.html) - 0100h',
            'Earlier I explained how you can insert machine-code instructions any-where into memory and execute them, but in CP/M programs that are stored in disk files must be designed to be loaded into memory beginning at a specific memory location, which is <<0100h|1>>.',
          ],
          [
            1,
            '[00:05] Code - Charles Petzold.epub (OEBPS/ch22.html) - 0005h',
            "What does CALL 5 actually do? The memory location at <<0005h|1>> is set up by CP/M to contain a JMP (Jump) instruction, which jumps to a location in the Basic Disk Operating System (BDOS) of CP/M. This area contains a bunch of subroutines that execute each of the CP/M functions. The BDOS\x{2014}as its name implies\x{2014}is primarily responsible for maintaining the file system on the disk. Frequently, the BDOS has to make use of subroutines in the Basic Input/Output System (BIOS) of CP/M, which is the area that actually accesses the hardware of the keyboard, the video display, and the disk drives. In fact, the BIOS is the only section of CP/M that needs to know about the hardware of the computer. The CCP does everything it needs to do using BDOS functions, and so do the utilities that come with CP/M.",
          ],
          [
            1,
            '[00:00] Code - Charles Petzold.epub (OEBPS/ch23.html) - 0000',
            '0
<<0000|18:0>>
1',
          ],
          [
            1,
            '[00:01] Code - Charles Petzold.epub (OEBPS/ch23.html) - 0001',
            '1
<<0001|18:0>>
2',
          ],
          [
            1,
            '[00:10] Code - Charles Petzold.epub (OEBPS/ch23.html) - 0010',
            '2
<<0010|18:0>>
3',
          ],
          [
            1,
            '[00:11] Code - Charles Petzold.epub (OEBPS/ch23.html) - 0011',
            '3
<<0011|18:0>>
4',
          ],
          [
            1,
            '[ap 01:00] Code - Charles Petzold.epub (OEBPS/ch23.html) - 0100',
            '4
<<0100|18:0>>
5',
          ],
          [
            1,
            '[ap 01:01] Code - Charles Petzold.epub (OEBPS/ch23.html) - 0101',
            '5
<<0101|18:0>>
6',
          ],
          [
            1,
            '[ap 01:10] Code - Charles Petzold.epub (OEBPS/ch23.html) - 0110',
            '6
<<0110|18:0>>
7',
          ],
          [
            1,
            '[ap 01:11] Code - Charles Petzold.epub (OEBPS/ch23.html) - 0111',
            '7
<<0111|18:0>>
8',
          ],
          [
            1,
            '[ap 02:00] Code - Charles Petzold.epub (OEBPS/ch23.html) - two',
            "This type of storage and notation is also called fixed-point format because the decimal point is always fixed at a particular number of places\x{2014}in our example, at <<two|9:0>> decimal places. Notice that there's nothing actually stored along with the number that indicates the position of the decimal point. Programs that work with numbers in fixed-point format must know where the decimal point is. You can create fixed-point numbers with any number of decimal places, and you can mix and match these numbers in the same computer program. But any part of the program that does arithmetic on the numbers has to know where the decimal points are.",
          ],
          [
            1,
            '[ap 01:00] Code - Charles Petzold.epub (OEBPS/ch23.html) - 1',
            '1 x 22 +0 x 21 +1 x 20 +1 x 2-1 +1 x 2-2 +0 x 2-3 +1 x 2-4Or the negative powers of two can be calculated by starting at <<1|9g>> and repeatedly dividing by 2:',
          ],
          [
            1,
            '[ap 02:00] Code - Charles Petzold.epub (OEBPS/ch23.html) - 2',
            'In decimal scientific notation, the normalized significand should be greater than or equal to 1 but less than 10. Similarly, the normalized significand of numbers in binary scientific notation is always greater than or equal to 1 but less than binary 10, which is <<2|9d>> in decimal. So in binary scientific notation, the number',
          ],
          [
            1,
            '[ap 10:38] Code - Charles Petzold.epub (OEBPS/ch23.html) - 10-38',
            '1.11111111111111111111111TWO x 2127In decimal, these two numbers are approximately 1.175494351 x <<10-38|5a:0>> and 3.402823466 x 1038. That\'s the effective range of single-precision floating-point notation.',
          ],
          [
            1,
            '[ap 03:50] Code - Charles Petzold.epub (OEBPS/ch23.html) - 3.50',
            '1.00000000000000000000000TWO x 218.That\'s one reason why fixed-point is preferred when dealing with dollars and cents. When you work with floating-point numbers, you could also discover other little quirks that can drive you mad. Your program will do a calculation that should yield the result <<3.50|5a:0>> and instead you get 3.499999999999. This type of thing tends to happen in floating-point calculations, and there isn\'t a whole lot you can do about it.',
          ],
          [
            1,
            '[ap 01:00] Code - Charles Petzold.epub (OEBPS/ch23.html) - 1',
            '1.1111111111111111111111111111111111111111111111111111TWO x 21023The range is decimal in approximately 2.2250738585072014 x 10-308 to 1.7976931348623158 x 10308. Ten to the 308th power is a very big number. It\'s <<1|9d>> followed by <<308|3:0>> decimal zeros.',
          ],
          [
            1,
            '[01:00] Code - Charles Petzold.epub (OEBPS/ch24.html) - 0100h',
            'ORG <<0100h|1>>
      LXI DE, Text
      MVI C,9
      CALL 5
      RET
Text: DB \'Hello!$\'
      ENDThis file has a couple of statements we haven\'t seen before. The first one is an ORG (for origin) statement. This statement does not correspond to an 8080 instruction. Instead, it indicates that the address of the next statement is to begin at address <<0100h|1>>, which you\'ll recall is the address where CP/M loads programs into memory.',
          ],
          [
            1,
            '[ap 00:59] Code - Charles Petzold.epub (OEBPS/ch24.html) - one-to-one',
            "What an assembler such as ASM.COM does is read an assembly-language program (often called a source-code file) and write out a file containing machine code\x{2014}an executable file. In the grand scheme of things, assemblers are fairly simple programs because there's a <<one-to-one|10a:0>> correspondence between the assembly-language mnemonics and machine code. The assembler works by separating each line of text into mnemonics and arguments and then comparing these small words and letters with a list that the assembler contains of all the possible mnemonics and arguments. These comparisons reveal which machine-code instructions correspond to each statement.",
          ],
          [
            1,
            '[01:09] Code - Charles Petzold.epub (OEBPS/ch24.html) - 0109h',
            'Notice how the assembler figures out that the LXI instruction must set the register pair DE to the address <<0109h|1>>. If the LXI instruction itself is located at <<0100h|1>> (as it is when CP/M loads the program into memory to run), address <<0109h|1>> is where the text string begins. Generally a programmer using an assembler doesn\'t need to worry about the specific addresses associated with different parts of the program.',
          ],
          [
            1,
            '[ap 00:59] Code - Charles Petzold.epub (OEBPS/ch24.html) - one-to-one',
            'Of course, it\'s not enough to simply define a high-level language (which involves developing a syntax to express all the things you want to do with the language); you must also write a compiler, which is the program that converts the statements of your high-level language to machine code. Like an assembler, a compiler must read through a source-code file character by character and break it down into short words and symbols and numbers. A compiler, however, is much more complex than an assembler. An assembler is simplified somewhat because of the <<one-to-one|10a:0>> correspondence between assembly-language statements and machine code. A compiler usually must translate a single statement of a high-level language into many machine-code instructions. Compilers aren\'t easy to write. Whole books are devoted to their design and construction.',
          ],
          [
            1,
            '[ap 02:59] Code - Charles Petzold.epub (OEBPS/ch24.html) - a to 3',
            'begin
    real a, b;

    for a := 3 step 2 until 99 do
    begin
        b := a x a x a;
        print (\'The cube of \', a, \' is \', b);
    end
endThe for statement initially sets the variable <<a to 3|10>> and executes the block following the for statement. Then a is increased by the number following the step keyword, which is <<2|9f>>. The new value of a, which is <<5|9f>>, is used to execute the block. The variable a will continue to be increased by 2. When it exceeds 99, the for loop is completed.',
          ],
          [
            1,
            '[ap 01:00] Code - Charles Petzold.epub (OEBPS/ch24.html) - 100',
            'begin
    real array a[1:100];
    integer i;

    for i := 1 step 1 until <<100|3:0>> do
        a[i] := sqrt(i);

    for i := 1 step 1 until <<100|3:0>> do
        print (\'The square root of \', i, \' is \', a[i]);
endThis program also shows an integer variable named i (which is a traditional name for an integer variable because it\'s the first letter of the word). In the first for loop, each element of the array is assigned the square root of its index. In the second for loop, these are printed out.',
          ],
          [
            1,
            '[ap 01:00] Code - Charles Petzold.epub (OEBPS/ch24.html) - 100',
            "begin
    Boolean array a[2:10000];
    integer i, j;

    for i := 2 step 1 until 10000 do
        a[i] := true;

    for i := 2 step 1 until <<100|3:0>> do
        if a[i] then
            for j := 2 step 1 until 10000 \x{f7} i do
                a[i x j] := false;

    for i := 2 step 1 until 10000 do
        if a[i] then
            print (i);
endThe first for loop sets all the array elements to the Boolean value true. Thus, the program starts by assuming that all the numbers are prime. The second for loop goes from 1 through 100 (the square root of 10,000). If the number is prime, which means that a[i] is true, another for loop sets all the multiples of that number to false. Those numbers aren't prime. The final for loop prints out all the prime numbers, which are the values of i where a[i] is true.",
          ],
          [
            1,
            '[ap 06:00] Code - Charles Petzold.epub (OEBPS/ch25.html) - 600',
            'Number of colors = 2Number of bits per pixelA video adapter board has only a certain amount of memory, so it\'s limited in the combinations of resolutions and color depths that are possible. For example, a video adapter board that has a megabyte of memory can do a 640-by-480 resolution with 3 bytes per pixel. But if you want to use a resolution of 800 by <<600|3:0>>, there\'s not enough memory for 3 bytes per pixel. Instead, you\'ll need to use 2 bytes per pixel.',
          ],
          [
            1,
            '[ap ~ 02:00] Code - Charles Petzold.epub (OEBPS/ch25.html) - about 200',
            'The first big project at PARC was the Alto, designed and built between 1972 and 1973. By the standards of those years, it was an impressive piece of work. The floor-standing system unit had 16-bit processing, two 3-MB disk drives, 128 KB of memory (expandable to 512 KB), and a mouse with three buttons. Because the Alto preceded the availability of 16-bit single-chip microprocessors, the Alto processor had to be built from <<about 200|18:0>> integrated circuits.',
          ],
          [
            1,
            '[ap 08:08] Code - Charles Petzold.epub (OEBPS/ch25.html) - 808',
            "The video display was one of the several unusual aspects of the Alto. The screen was approximately the size and shape of a sheet of paper\x{2014}8 inches wide and 10 inches high. It ran in a raster graphics mode with 606 pixels horizontally by <<808|3:0>> pixels vertically, for a total of 489,648 pixels. One bit of memory was devoted to each pixel, which meant that each pixel could be either black or white. The total amount of memory devoted to the video display was 64 KB, which was part of the address space of the processor.",
          ],
          [
            1,
            '[ap 03:42] Code - Charles Petzold.epub (OEBPS/ch25.html) - 342',
            "The original Macintosh had a Motorola 68000 microprocessor, 64 KB of ROM, 128 KB of RAM, a 3\x{bd}-inch diskette drive (storing 400 KB per diskette), a keyboard, a mouse, and a video display capable of displaying 512 pixels horizontally by <<342|3:0>> pixels vertically. (The CRT itself measured only 9 inches diagonally.) That's a total of 175,104 pixels. Each pixel was associated with 1 bit of memory and could be colored either black or white, so about 22 KB were required for the video display RAM.",
          ],
          [
            1,
            '[00:00] Code - Charles Petzold.epub (OEBPS/ch25.html) - 000h',
            "An electrical current that represents sound isn't like the on-off digital signals that we've encountered throughout this book. Sound waves vary continuously, and so does the voltage of such a current. The electrical current is an analog of the sound waves. A device known as an analog-to-digital converter (ADC)\x{2014}generally implemented in a chip\x{2014}converts an analog voltage to a binary number. The output of an ADC is a certain number of digital signals\x{2014}usually 8, 12, or 16\x{2014}that together indicate the relative level of the voltage. A 12-bit ADC, for example, converts a voltage to a number between <<000h|1>> and FFFh and can differentiate 4096 different voltage levels.",
          ],
          [
            1,
            '[ap ~ 07:00] Code - Charles Petzold.epub (OEBPS/ch25.html) - about 660',
            'CDs can store data as well as sound. When used exclusively for data, they\'re called CD-ROM (CD Read-Only Memory). A CD-ROM is generally limited to <<about 660|18:0>> megabytes. Most computers these days have CD-ROM drives installed, and much application and game software is distributed on CD-ROM.',
          ],
          [
            1,
            '[ap < 02:00] Code - Charles Petzold.epub (OEBPS/ch25.html) - just about 200',
            "A movie file on a computer is simply a series of bitmaps with sound. But without compression, a movie file requires a huge amount of data. For example, consider a movie with each frame the size of a 640-by-480-pixel computer screen with 24-bit color. That's 921,600 bytes per frame. At 30 frames per second, we're up to 27,648,000 bytes per second. Keep multiplying and you get 1,658,880,000 bytes per minute, and 199,065,600,000 bytes\x{2014}<<just about 200|18:1>> gigabytes\x{2014}for a two-hour movie. This is why most movies displayed on the personal computer are short, small, and jumpy.",
          ],
          [
            1,
            '[ap 03:00] Code - Charles Petzold.epub (OEBPS/ch25.html) - 300',
            'In early modems, a technique called frequency-shift keying (FSK) was used. A modem operating at <<300|3:0>> bits per second (for example) might convert a 0 bit to a frequency of 1070 Hz and a 1 bit to a frequency of 1270 Hz. Each byte is prefaced by a start bit and concluded with a stop bit, so each byte requires 10 bits. At <<300|9m>> bits per second, the transmission speed is only 30 bytes per second. More modern modems use more sophisticated techniques to achieve speeds over 100 times that.',
          ],
          [
            1,
            '[ap 06:52] Code - Charles Petzold.epub (OEBPS/co02.html) - 6.52',
            'The manuscript for this book was prepared using Microsoft Word 2000. Pages were composed using Adobe PageMaker <<6.52|5a:0>>, with text and display type in Sabon and math fonts in Syntax. Composed pages were delivered to the printer as electronic prepress files.',
          ],
        ];
