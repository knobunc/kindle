$VAR1 = [
          [
            1,
            '[18:43] Code - Charles Petzold.epub (OEBPS/ch06.html) - 1843',
            'Although Samuel Morse notified the patent office in 1836 that he had invented a successful telegraph, it wasn\'t until <<1843|18:0>> that he was able to persuade Congress to fund a public demonstration of the device. The historic day was May 24, 1844, when a telegraph line rigged between Washington, D.C., and Baltimore, Maryland, successfully carried the biblical message: "What hath God wrought!"',
          ],
          [
            1,
            '[ap 02:05] Code - Charles Petzold.epub (OEBPS/ch07.html) - 205',
            'Yes, the zero. The lowly zero is without a doubt one of the most important inventions in the history of numbers and mathematics. It supports positional notation because it allows differentiation of 25 from <<205|9c:0>> and 250. The zero also eases many mathematical operations that are awkward in nonpositional systems, particularly multiplication and division.',
          ],
          [
            1,
            '[00:11] Code - Charles Petzold.epub (OEBPS/ch08.html) - 0011',
            "People who work with binary numbers often write them with leading zeros (that is, zeros to the left of the first 1)\x{2014}for example, <<0011|18:0>> rather than just 11. This doesn't change the value of the number at all; it's just for cosmetic purposes. For example, here are the first sixteen binary numbers with their decimal equivalents:",
          ],
          [
            1,
            '[00:00] Code - Charles Petzold.epub (OEBPS/ch08.html) - 0000',
            'Decimal
<<0000|18:0>>
0',
          ],
          [
            1,
            '[00:01] Code - Charles Petzold.epub (OEBPS/ch08.html) - 0001',
            '0
<<0001|18:0>>
1',
          ],
          [
            1,
            '[00:10] Code - Charles Petzold.epub (OEBPS/ch08.html) - 0010',
            '1
<<0010|18:0>>
2',
          ],
          [
            1,
            '[00:11] Code - Charles Petzold.epub (OEBPS/ch08.html) - 0011',
            '2
<<0011|18:0>>
3',
          ],
          [
            1,
            '[ap 01:00] Code - Charles Petzold.epub (OEBPS/ch08.html) - 0100',
            '3
<<0100|18:0>>
4',
          ],
          [
            1,
            '[ap 01:01] Code - Charles Petzold.epub (OEBPS/ch08.html) - 0101',
            '4
<<0101|18:0>>
5',
          ],
          [
            1,
            '[ap 01:10] Code - Charles Petzold.epub (OEBPS/ch08.html) - 0110',
            '5
<<0110|18:0>>
6',
          ],
          [
            1,
            '[ap 01:11] Code - Charles Petzold.epub (OEBPS/ch08.html) - 0111',
            '6
<<0111|18:0>>
7',
          ],
          [
            1,
            '[23:59] Code - Charles Petzold.epub (OEBPS/ch08.html) - 1 to 0',
            'Here\'s another way of looking at it: When you count in binary, the rightmost digit (also called the least significant digit), alternates between 0 and 1. Every time it changes from a 1 to a 0, the digit second to right (that is, the next most significant digit) also changes, either from 0 to 1 or from <<1 to 0|10a:0>>. So every time a binary digit changes from a 1 to a 0, the next most significant digit also changes, either from a 0 to a 1 or from a 1 to a 0.',
          ],
          [
            1,
            '[ap 01:11] Code - Charles Petzold.epub (OEBPS/ch08.html) - 0111',
            'Binary numbers can get very long very quickly. For example, twelve million in binary is 101101110001101100000000. To make this a little more readable, it\'s customary to separate every four binary digits with a dash, for example 1011-0111-0001-1011-0000-0000 or with spaces: 1011 <<0111|18:0>> <<0001|18:0>> 1011 <<0000|18:0>> <<0000|18:0>>. Later on in this book, we\'ll look at a more concise way of expressing binary numbers.',
          ],
          [
            1,
            '[~ 19:48] Code - Charles Petzold.epub (OEBPS/ch08.html) - around 1948',
            'Sometime <<around 1948|18:0>>, the American mathematician John Wilder Tukey (born 1915) realized that the words binary digit were likely to assume a much greater importance in the years ahead as computers became more prevalent. He decided to coin a new, shorter word to replace the unwieldy five syllables of binary digit. He considered bigit and binit but settled instead on the short, simple, elegant, and perfectly lovely word bit.',
          ],
          [
            1,
            '[00:00] Code - Charles Petzold.epub (OEBPS/ch09.html) - midnight',
            '"Listen, my children, and you shall hear / Of the <<midnight|13>> ride of Paul Revere," wrote Henry Wadsworth Longfellow, and while he might not have been historically accurate when describing how Paul Revere alerted the American colonies that the British had invaded, he did provide a thoughtprovoking example of the use of bits to communicate important information:',
          ],
          [
            1,
            '[00:00] Code - Charles Petzold.epub (OEBPS/ch09.html) - 0000',
            "The magazine Entertainment Weekly gives grades, not only for movies but for television shows, CDs, books, CD-ROMs, Web sites, and much else. The grades range from A+ straight down to F (although it seems that only Pauly Shore movies are worthy of that honor). If you count them, you see 13 possible grades. We would need 4 bits to represent these grades:
<<0000|18:0>> = F
<<0001|18:0>> = D\x{2013}",
          ],
          [
            1,
            '[00:00] Code - Charles Petzold.epub (OEBPS/ch09.html) - 0000',
            "<<0000|18:0>> = F
<<0001|18:0>> = D\x{2013}
<<0010|18:0>> = D",
          ],
          [
            1,
            '[00:01] Code - Charles Petzold.epub (OEBPS/ch09.html) - 0001',
            "<<0001|18:0>> = D\x{2013}
<<0010|18:0>> = D
<<0011|18:0>> = D+",
          ],
          [
            1,
            '[00:10] Code - Charles Petzold.epub (OEBPS/ch09.html) - 0010',
            "<<0010|18:0>> = D
<<0011|18:0>> = D+
<<0100|18:0>> = C\x{2013}",
          ],
          [
            1,
            '[00:11] Code - Charles Petzold.epub (OEBPS/ch09.html) - 0011',
            "<<0011|18:0>> = D+
<<0100|18:0>> = C\x{2013}
<<0101|18:0>> = C",
          ],
          [
            1,
            '[ap 01:00] Code - Charles Petzold.epub (OEBPS/ch09.html) - 0100',
            "<<0100|18:0>> = C\x{2013}
<<0101|18:0>> = C
<<0110|18:0>> = C+",
          ],
          [
            1,
            '[ap 01:01] Code - Charles Petzold.epub (OEBPS/ch09.html) - 0101',
            "<<0101|18:0>> = C
<<0110|18:0>> = C+
<<0111|18:0>> = B\x{2013}",
          ],
          [
            1,
            '[ap 01:10] Code - Charles Petzold.epub (OEBPS/ch09.html) - 0110',
            "<<0110|18:0>> = C+
<<0111|18:0>> = B\x{2013}
1000 = B",
          ],
          [
            1,
            '[00:00] Code - Charles Petzold.epub (OEBPS/ch12.html) - 0',
            'The subscripts start at <<0|9g>> and get higher for more significant digits because they correspond to the exponents of powers of two:',
          ],
          [
            1,
            '[13:00] Code - Charles Petzold.epub (OEBPS/ch13.html) - 13',
            'To do this, we start with the rightmost column. First we see that 6 is bigger than 3, so we have to borrow 1 from the 5, and then subtract 6 from <<13|9c:0>>, which is <<7|9c:0>>. Then we have to remember that we borrowed 1 from the 5, so it\'s really a 4, and this 4 is smaller than 7, so we borrow 1 from the 2 and subtract 7 from <<14|9c:0>>, which is <<7|9c:0>>. Then we have to remember that we borrowed 1 from the 2, so it\'s really a 1, and then we subtract 1 from it to get 0. Our answer is 77:',
          ],
          [
            1,
            '[ap 09:23] Code - Charles Petzold.epub (OEBPS/ch13.html) - 923',
            'At this point in the earlier problem, you were able to add 1 and subtract 1000 to get the final result. But in this case, that strategy isn\'t going to work well. You would need to subtract 1000 from <<923|9c:0>>, and that really means subtracting 923 from <<1000|9c:0>>, and that requires borrowing.',
          ],
          [
            1,
            '[ap 10:00] Code - Charles Petzold.epub (OEBPS/ch13.html) - ten',
            "This type of notation is called <<ten|9f>>'s complement. To convert a 3-digit negative number to ten's complement, we subtract it from 999 and add 1. In other words, the ten's complement is the nines' complement plus one. For example, to write \x{2013}255 in ten's complement, subtract it from 999 to get 744 and then add 1 to get 745.",
          ],
          [
            1,
            '[ap 02:00] Code - Charles Petzold.epub (OEBPS/ch13.html) - two',
            'The equivalent system in binary is called <<two|9f>>\'s complement. Let\'s assume that we\'re working with 8-bit numbers. These range from 00000000 to 11111111, which normally correspond to decimal numbers 0 through 255. But if you also want to express negative numbers, every 8-bit number that begins with a 1 will actually represent a negative number, as shown in the following table:',
          ],
          [
            1,
            '[ap 01:00] Code - Charles Petzold.epub (OEBPS/ch14.html) - 1',
            'A more interesting approach to the adding machine eliminates an entire row of eight switches. But first we need to modify the D-type flip-flop slightly by adding an OR gate and an input signal called Clear. The Clear input is normally 0. But when it\'s <<1|9c:0>>, the Q output becomes 0, as shown here:',
          ],
          [
            1,
            '[23:59] Code - Charles Petzold.epub (OEBPS/ch14.html) - 1 to 0',
            'The arrow indicates that the output Q becomes the same as the Data input when the Clock makes a transition from 0 to 1. This is known as a positive transition of the Clock signal. (A negative transition is the transition from <<1 to 0|10a:1>>.) The flip-flop has a diagram like this:',
          ],
          [
            1,
            '[23:59] Code - Charles Petzold.epub (OEBPS/ch14.html) - 1 to 0',
            'What\'s happening here can be summed up very simply: Every time the Clock input changes from 0 to 1, the Q output changes, either from 0 to 1 or from <<1 to 0|10a:1>>. The situation is clearer if we look at the timing diagram:',
          ],
          [
            1,
            '[00:00] Code - Charles Petzold.epub (OEBPS/ch14.html) - 0000',
            'Decimal
<<0000|18:0>>
0',
          ],
          [
            1,
            '[00:01] Code - Charles Petzold.epub (OEBPS/ch14.html) - 0001',
            '0
<<0001|18:0>>
1',
          ],
          [
            1,
            '[00:10] Code - Charles Petzold.epub (OEBPS/ch14.html) - 0010',
            '1
<<0010|18:0>>
2',
          ],
          [
            1,
            '[00:11] Code - Charles Petzold.epub (OEBPS/ch14.html) - 0011',
            '2
<<0011|18:0>>
3',
          ],
          [
            1,
            '[ap 01:00] Code - Charles Petzold.epub (OEBPS/ch14.html) - 0100',
            '3
<<0100|18:0>>
4',
          ],
          [
            1,
            '[ap 01:01] Code - Charles Petzold.epub (OEBPS/ch14.html) - 0101',
            '4
<<0101|18:0>>
5',
          ],
          [
            1,
            '[ap 01:10] Code - Charles Petzold.epub (OEBPS/ch14.html) - 0110',
            '5
<<0110|18:0>>
6',
          ],
          [
            1,
            '[ap 01:11] Code - Charles Petzold.epub (OEBPS/ch14.html) - 0111',
            '6
<<0111|18:0>>
7',
          ],
          [
            1,
            '[~ 19:56] Code - Charles Petzold.epub (OEBPS/ch15.html) - around 1956',
            'The word byte originated at IBM, probably <<around 1956|18:0>>. The word had its origins in the word bite but was spelled with a y so that nobody would mistake the word for bit. For a while, a byte meant simply the number of bits in a particular data path. But by the mid-1960s, in connection with the development of IBM\'s System/360 (their large complex of business computers), the word came to mean a group of 8 bits.',
          ],
          [
            1,
            '[00:00] Code - Charles Petzold.epub (OEBPS/ch15.html) - 0000',
            'Decimal
<<0000|18:0>>
0',
          ],
          [
            1,
            '[00:01] Code - Charles Petzold.epub (OEBPS/ch15.html) - 0001',
            '8
<<0001|18:0>>
1',
          ],
          [
            1,
            '[00:10] Code - Charles Petzold.epub (OEBPS/ch15.html) - 0010',
            '9
<<0010|18:0>>
2',
          ],
          [
            1,
            '[00:11] Code - Charles Petzold.epub (OEBPS/ch15.html) - 0011',
            '10
<<0011|18:0>>
3',
          ],
          [
            1,
            '[ap 01:00] Code - Charles Petzold.epub (OEBPS/ch15.html) - 0100',
            '11
<<0100|18:0>>
4',
          ],
          [
            1,
            '[ap 01:01] Code - Charles Petzold.epub (OEBPS/ch15.html) - 0101',
            '12
<<0101|18:0>>
5',
          ],
          [
            1,
            '[ap 01:10] Code - Charles Petzold.epub (OEBPS/ch15.html) - 0110',
            '13
<<0110|18:0>>
6',
          ],
          [
            1,
            '[ap 01:11] Code - Charles Petzold.epub (OEBPS/ch15.html) - 0111',
            '14
<<0111|18:0>>
7',
          ],
          [
            1,
            '[00:00] Code - Charles Petzold.epub (OEBPS/ch15.html) - 0000',
            'Decimal
<<0000|18:0>>
0',
          ],
          [
            1,
            '[00:01] Code - Charles Petzold.epub (OEBPS/ch15.html) - 0001',
            '0
<<0001|18:0>>
1',
          ],
          [
            1,
            '[00:10] Code - Charles Petzold.epub (OEBPS/ch15.html) - 0010',
            '1
<<0010|18:0>>
2',
          ],
          [
            1,
            '[00:11] Code - Charles Petzold.epub (OEBPS/ch15.html) - 0011',
            '2
<<0011|18:0>>
3',
          ],
          [
            1,
            '[ap 01:00] Code - Charles Petzold.epub (OEBPS/ch15.html) - 0100',
            '3
<<0100|18:0>>
4',
          ],
          [
            1,
            '[ap 01:01] Code - Charles Petzold.epub (OEBPS/ch15.html) - 0101',
            '4
<<0101|18:0>>
5',
          ],
          [
            1,
            '[ap 01:10] Code - Charles Petzold.epub (OEBPS/ch15.html) - 0110',
            '5
<<0110|18:0>>
6',
          ],
          [
            1,
            '[ap 01:11] Code - Charles Petzold.epub (OEBPS/ch15.html) - 0111',
            '6
<<0111|18:0>>
7',
          ],
          [
            1,
            '[01:00] Code - Charles Petzold.epub (OEBPS/ch15.html) - 10000h',
            'The hexadecimal number 9A48Ch is
9A48Ch = 9 x <<10000h|1>> +
A x <<1000h|1>> +',
          ],
          [
            1,
            '[01:00] Code - Charles Petzold.epub (OEBPS/ch15.html) - 10000h',
            '9A48Ch = 9 x <<10000h|1>> +
A x <<1000h|1>> +
4 x <<100h|1>> +',
          ],
          [
            1,
            '[10:00] Code - Charles Petzold.epub (OEBPS/ch15.html) - 1000h',
            'A x <<1000h|1>> +
4 x <<100h|1>> +
8 x 10h +',
          ],
          [
            1,
            '[03:00] Code - Charles Petzold.epub (OEBPS/ch16.html) - 3:00 A.M.',
            'Nor is human memory foolproof. Indeed, writing was probably invented specifically to compensate for the failings of human memory. Perhaps last night you suddenly woke up at <<3:00 A.M.|2a>> with a great idea for a screenplay. You grabbed the pen and paper you keep by your bed specifically for that purpose, and you wrote it down so you wouldn\'t forget. The next morning you can read the brilliant idea and start work on the screenplay. ("Boy meets girl w. car chase & explosions"? That\'s it?) Or maybe not.',
          ],
          [
            1,
            '[ap 00:52] Code - Charles Petzold.epub (OEBPS/ch16.html) - 8-to-1',
            'The <<8-to-1|10a:0>> Selector has eight Data inputs (shown at the top) and three Select inputs (shown at the left). The Select inputs choose which of the Data inputs appears at the Output. For example, if the Select inputs are 000, the Output is the same as D0. If the Select inputs are 111, the Output is the same as D7. If the Select inputs are 101, the Output is the same as D5. Here\'s the logic table:',
          ],
          [
            1,
            '[ap 00:52] Code - Charles Petzold.epub (OEBPS/ch16.html) - 8-to-1',
            'The <<8-to-1|10a:0>> Selector is built from three inverters, eight 4-input AND gates, and an 8-input OR gate, like this:',
          ],
          [
            1,
            '[ap 00:52] Code - Charles Petzold.epub (OEBPS/ch16.html) - 8-to-1',
            'Let\'s recap what we\'re trying to do here. We\'re trying to wire eight 1-bit latches so that they can be individually written to using a single Data In signal and individually examined using a single Data Out signal. We\'ve already established that we can choose a Data Output signal from one of the eight latches by using an <<8-to-1|10a:0>> Selector, as shown on the following page.',
          ],
          [
            1,
            '[ap 00:52] Code - Charles Petzold.epub (OEBPS/ch16.html) - 8-to-1',
            "To accomplish this task, we need another circuit that looks somewhat similar to the <<8-to-1|10a:0>> Selector but actually does the opposite. This is the <<3-to-8|10a:0>> Decoder. We've also seen a simple Data Decoder before\x{2014}when wiring the switches to select the color of our ideal cat in Chapter\x{a0}11.",
          ],
          [
            1,
            '[ap 07:57] Code - Charles Petzold.epub (OEBPS/ch16.html) - 3-to-8',
            'The <<3-to-8|10a:0>> Decoder has eight Outputs. At any time, all but one of the Outputs are 0. The exception is the Output that\'s selected by the S0, S1, and S2 inputs. This Output is the same as the Data Input.',
          ],
          [
            1,
            '[ap 00:52] Code - Charles Petzold.epub (OEBPS/ch16.html) - 8-to-1',
            'Notice that the three Select signals to the Decoder and the Selector are the same and that I\'ve also labeled those three signals the Address. Like a post office box number, this 3-bit address determines which of the eight 1-bit latches is being referenced. On the input side, the Address input determines which latch the Write signal will trigger to store the Data input. On the output side (at the bottom of the figure), the Address input controls the <<8-to-1|10a:0>> Selector to select the output of one of the eight latches.',
          ],
          [
            1,
            '[ap 00:58] Code - Charles Petzold.epub (OEBPS/ch16.html) - 2-to-1',
            "Or the two 8 x 1 RAM arrays can be combined in much the same way that the individual latches were combined\x{2014}by using a <<2-to-1|10a:0>> Selector and a <<1-to-2|10a:0>> Decoder, as shown on the next page.",
          ],
          [
            1,
            '[ap 10:24] Code - Charles Petzold.epub (OEBPS/ch16.html) - 1024',
            "What you don't say is that a 1-KB RAM array stores 1000 bytes, or (in English) \"one thousand bytes.\" It's more than a thousand\x{2014}it's <<1024|9c:0>>. To sound like you know what you're talking about, you say either \"1K\" or \"one kilobyte.\"",
          ],
          [
            1,
            '[ap ~ 10:12] Code - Charles Petzold.epub (OEBPS/ch16.html) - approximately 1012',
            'Similarly, a terabyte (teras means monster) equals 240 bytes (<<approximately 1012|18:0>>) or 1,099,511,627,776 bytes. Terabyte is abbreviated TB.',
          ],
          [
            1,
            '[ap ~ 10:18] Code - Charles Petzold.epub (OEBPS/ch16.html) - approximately 1018',
            'Ascending into regions that few have traveled, a petabyte equals 250 bytes or 1,125,899,906,842,624 bytes, which is approximately 1015 or a quadrillion. An exabyte equals 260 bytes or 1,152,921,504,606,846,976 bytes, <<approximately 1018|9:0>> or a quintillion.',
          ],
          [
            1,
            '[ap 02:16] Code - Charles Petzold.epub (OEBPS/ch16.html) - 216',
            'Why 64 KB? Why not 32 KB or 128 KB? Because 65,536 is a nice round number. It\'s <<216|9l>>. This RAM array has a 16-bit address. In other words, the address is 2 bytes exactly. In hexadecimal, the address ranges from <<0000h|1>> through FFFFh.',
          ],
          [
            1,
            '[ap 00:58] Code - Charles Petzold.epub (OEBPS/ch16.html) - 2-to-1',
            'When the Takeover switch is open (as shown), the Address, Data input, and Write inputs to the 64K x 8 RAM array come from external signals shown at the top left of the <<2-to-1|10a:0>> Selectors. When the Takeover switch is closed, the Address, Data input, and Write signals to the RAM array come from the switches on the control panel. In either case, the Data Out signals from the RAM array go to the eight lightbulbs and possibly someplace else.',
          ],
          [
            1,
            '[00:00] Code - Charles Petzold.epub (OEBPS/ch17.html) - 0000h',
            'This is certainly not the easiest piece of calculating equipment ever invented. To use it, you first must close the switch labeled Clear. This clears the contents of the latch and sets the output of the 16-bit counter to <<0000h|1>>. Then you close the Takeover switch on the RAM control panel. You can then enter a set of 8-bit numbers that you want to add beginning at RAM address <<0000h|1>>. If you have 100 numbers, you\'ll store these numbers at addresses <<0000h|1>> through 0063h. (You should also set all the unused entries in the RAM array to 00h.) You can then open the Takeover switch of the RAM control panel (so that the control panel no longer has control over the RAM array) and open the Clear switch. Then just sit back and watch the flashing lightbulbs.',
          ],
          [
            1,
            '[00:00] Code - Charles Petzold.epub (OEBPS/ch17.html) - 0000h',
            'Here\'s how it works: When the Clear switch is first opened, the address of the RAM array is <<0000h|1>>. The 8-bit value stored in the RAM array at that address is an input to the adder. The other input to the adder is 00h because the latch is also cleared.',
          ],
          [
            1,
            '[00:01] Code - Charles Petzold.epub (OEBPS/ch17.html) - 0001h',
            "The oscillator provides a clock signal\x{2014}a signal that alternates between 0 and 1 very quickly. After the Clear switch is opened, whenever the clock changes from a 0 to a 1, two things happen simultaneously: The latch stores the sum from the adder, and the 16-bit counter increments, thus addressing the next value in the RAM array. The first time the clock changes from 0 to 1 after the Clear switch is opened, the latch stores the first value and the counter increments to <<0001h|1>>. The second time, the latch stores the sum of the first and second values, and the counter increments to <<0002h|1>>. And so on.",
          ],
          [
            1,
            '[00:00] Code - Charles Petzold.epub (OEBPS/ch17.html) - 0000h',
            'One problem with this circuit is that we have no way of stopping it! At some point, the lightbulbs will stop flashing because all the rest of the numbers in the RAM array will be 00h. At that time, you can read the binary sum. But when the counter eventually reaches FFFFh, it will roll over (just like a car odometer) to <<0000h|1>> and this automated adder will begin adding the numbers again to the sum that was already calculated.',
          ],
          [
            1,
            '[00:00] Code - Charles Petzold.epub (OEBPS/ch17.html) - 0000h',
            'For example, suppose we want to add three numbers together and then add two numbers together and then add another three numbers together. We might imagine typing these numbers into the RAM array beginning at address <<0000h|1>> so that the contents of the memory look like this:',
          ],
          [
            1,
            '[00:00] Code - Charles Petzold.epub (OEBPS/ch17.html) - 0000h',
            'In gory detail, what we want the automated adder to do in this particular example is this:
Load the value at address <<0000h|1>> into the accumulator.
Add the value at address <<0001h|1>> to the accumulator.',
          ],
          [
            1,
            '[00:00] Code - Charles Petzold.epub (OEBPS/ch17.html) - 0000h',
            'Load the value at address <<0000h|1>> into the accumulator.
Add the value at address <<0001h|1>> to the accumulator.
Add the value at address <<0002h|1>> to the accumulator.',
          ],
          [
            1,
            '[00:01] Code - Charles Petzold.epub (OEBPS/ch17.html) - 0001h',
            'Add the value at address <<0001h|1>> to the accumulator.
Add the value at address <<0002h|1>> to the accumulator.
Store the contents of the accumulator at address <<0003h|1>>.',
          ],
          [
            1,
            '[00:02] Code - Charles Petzold.epub (OEBPS/ch17.html) - 0002h',
            'Add the value at address <<0002h|1>> to the accumulator.
Store the contents of the accumulator at address <<0003h|1>>.
Load the value at address <<0004h|1>> into the accumulator.',
          ],
          [
            1,
            '[00:03] Code - Charles Petzold.epub (OEBPS/ch17.html) - 0003h',
            'Store the contents of the accumulator at address <<0003h|1>>.
Load the value at address <<0004h|1>> into the accumulator.
Add the value at address <<0005h|1>> to the accumulator.',
          ],
          [
            1,
            '[00:04] Code - Charles Petzold.epub (OEBPS/ch17.html) - 0004h',
            'Load the value at address <<0004h|1>> into the accumulator.
Add the value at address <<0005h|1>> to the accumulator.
Store the contents of the accumulator at address <<0006h|1>>.',
          ],
          [
            1,
            '[00:05] Code - Charles Petzold.epub (OEBPS/ch17.html) - 0005h',
            'Add the value at address <<0005h|1>> to the accumulator.
Store the contents of the accumulator at address <<0006h|1>>.
Load the value at address <<0007h|1>> into the accumulator.',
          ],
          [
            1,
            '[00:06] Code - Charles Petzold.epub (OEBPS/ch17.html) - 0006h',
            'Store the contents of the accumulator at address <<0006h|1>>.
Load the value at address <<0007h|1>> into the accumulator.
Add the value at address <<0008h|1>> to the accumulator.',
          ],
          [
            1,
            '[00:07] Code - Charles Petzold.epub (OEBPS/ch17.html) - 0007h',
            'Load the value at address <<0007h|1>> into the accumulator.
Add the value at address <<0008h|1>> to the accumulator.
Add the value at address <<0009h|1>> to the accumulator.',
          ],
          [
            1,
            '[00:08] Code - Charles Petzold.epub (OEBPS/ch17.html) - 0008h',
            'Add the value at address <<0008h|1>> to the accumulator.
Add the value at address <<0009h|1>> to the accumulator.
Store the contents of the accumulator at address 000Ah.',
          ],
          [
            1,
            '[00:00] Code - Charles Petzold.epub (OEBPS/ch17.html) - 0000h',
            'Notice that just as in the original automated adder, each byte of memory is still being addressed sequentially beginning at <<0000h|1>>. The original automated adder simply added the contents of the memory at that address to the contents of the accumulator. In some cases, we still want to do that. But we also sometimes want to Load the accumulator directly with a value in memory or to Store the contents of the accumulator in memory. And after everything is done, we want the automated adder to simply stop so that the contents of the RAM array can be examined.',
          ],
          [
            1,
            '[ap 00:58] Code - Charles Petzold.epub (OEBPS/ch17.html) - 2-to-1',
            'This diagram is missing a few pieces, but it shows all the 8-bit data paths between the various components. The 16-bit counter provides an address for the two RAM arrays. The output of the Data RAM array goes into the 8-Bit Adder, as usual, to perform the Add instruction. But the input to the 8-bit latch can be either the output of the Data RAM array (in the case of a Load instruction) or the output of the adder (in the case of an Add instruction). This situation requires a <<2-to-1|10a:0>> Selector. The output of the latch circles back to the adder, as usual, but it\'s also the data input of the Data RAM array for a Store instruction.',
          ],
          [
            1,
            '[ap 00:58] Code - Charles Petzold.epub (OEBPS/ch17.html) - 2-to-1',
            'What this diagram is missing are all the little signals that control these components, known collectively as the control signals. These include the Clock and Clear inputs to the 16-bit counter, the Clock and Clear inputs to the 8-bit latch, the Write input to the Data RAM array, and the Select input to the <<2-to-1|10a:1>> Selector. Some of these signals will obviously be based on the output of the Code RAM array. For example, the Select input to the <<2-to-1|10a:1>> Selector must be 0 (selecting the Data RAM output) if the output of the Code RAM array indicates a Load instruction. The Write input to the Data RAM array must be 1 only when the opcode is a Store instruction. These control signals can be generated by various combinations of logic gates.',
          ],
          [
            1,
            '[00:02] Code - Charles Petzold.epub (OEBPS/ch17.html) - 0002h',
            'the result D7h will be stored at address <<0002h|1>>, and the result 99h will be stored at address <<0005h|1>>.',
          ],
          [
            1,
            '[00:00] Code - Charles Petzold.epub (OEBPS/ch17.html) - 0000h',
            'Of course, actually keying these numbers into memory isn\'t the most rewarding job around. Not only do you have to use switches to represent binary numbers, but the numbers aren\'t stored in consecutive addresses. For example, the number 7A892BCDh goes into addresses <<0000h|1>>, <<0003h|1>>, <<0006h|1>>, and <<0009h|1>> starting with the least-significant byte. To get the final result, you have to examine the values located at addresses <<0002h|1>>, <<0005h|1>>, <<0008h|1>>, and 000Bh.',
          ],
          [
            1,
            '[00:00] Code - Charles Petzold.epub (OEBPS/ch17.html) - 0000h',
            'The problem is that we\'ve built an automated adder that addresses the Code memory and the Data memory simultaneously and sequentially beginning at address <<0000h|1>>. Each instruction in the Code memory corresponds to a location in the Data memory at the same address. Once a Store instruction causes something to be stored in the Data memory, that value can\'t later be loaded back into the accumulator.',
          ],
          [
            1,
            '[00:00] Code - Charles Petzold.epub (OEBPS/ch17.html) - 0000h',
            'Each of the instruction codes (except Halt) is followed by 2 bytes that indicate a 16-bit address in the Data RAM array. These three addresses happen to be <<0000h|1>>, <<0001h|1>>, and <<0002h|1>>, but they could be anything.',
          ],
          [
            1,
            '[00:00] Code - Charles Petzold.epub (OEBPS/ch17.html) - 0000h',
            "Earlier I showed how to add a pair of 16-bit numbers\x{2014}specifically 76ABh and 232 Ch\x{2014}using the Add and Add with Carry instructions. But we had to store the 2 low-order bytes of these numbers at memory locations <<0000h|1>> and <<0001h|1>>, and the 2 high-order bytes at <<0003h|1>> and <<0004h|1>>. The result of the addition was stored at <<0002h|1>> and <<0005h|1>>.",
          ],
          [
            1,
            '[00:00] Code - Charles Petzold.epub (OEBPS/ch17.html) - 0000h',
            'If you were actually building such a machine out of relays, the bulk of the circuit would obviously be the two 64-KB RAM arrays. Indeed, much earlier you might have skimped on these components and decided that initially you would need only 1 KB of memory. If you made sure you stored everything in addresses <<0000h|1>> through 03FFh, using less memory than 64 KB would work out just fine.',
          ],
          [
            1,
            '[ap 00:58] Code - Charles Petzold.epub (OEBPS/ch17.html) - 2-to-1',
            'To accomplish this, we need to have a <<2-to-1|10a:0>> Selector to determine how the RAM array is addressed. Usually, the address is the 16-bit counter, as before. The RAM Data Out is still connected to three latches that latch the instruction code and the 2 address bytes that accompany each instruction. But the 16-bit address is the second input to the <<2-to-1|10a:0>> Selector. After the address is latched, this selector allows the latched address to be the address input to the RAM array:',
          ],
          [
            1,
            '[00:00] Code - Charles Petzold.epub (OEBPS/ch17.html) - 0000h',
            'As usual, the instructions begin at <<0000h|1>> because that\'s where the counter starts accessing the RAM array after it has been reset. The final Halt instruction is stored at address 000Ch. We could have stored the three numbers and the results anywhere in the RAM array (except in the first 13 bytes, of course, because those memory locations are occupied by instructions), but we chose to store the data starting at address <<0010h|1>>.',
          ],
          [
            1,
            '[00:10] Code - Charles Petzold.epub (OEBPS/ch17.html) - 0010h',
            'Now suppose you discover that you need to add two more numbers to that result. Well, you can replace all the instructions you just entered with some new instructions, but maybe you don\'t want to do that. Maybe you\'d prefer to just continue with the new instructions starting at the end of these instructions, first replacing the Halt instruction with a new Load instruction at address 000Ch. But you also need two new Add instructions, a Store instruction, and a new Halt instruction. Your only problem is that you have some data stored at address <<0010h|1>>. You have to move that data someplace at a higher memory address. And you then have to change the instructions that refer to those memory instructions.',
          ],
          [
            1,
            '[00:20] Code - Charles Petzold.epub (OEBPS/ch17.html) - 0020h',
            'Hmmm, you think. Maybe combining Code and Data into a single RAM array wasn\'t such a hot idea after all. But I assure you, a problem such as this would have come up sooner or later. So let\'s solve it. In this case, maybe what you\'d like to do is enter the new instructions beginning at address <<0020h|1>> and the new data at address <<0030h|1>>:',
          ],
          [
            1,
            '[00:13] Code - Charles Petzold.epub (OEBPS/ch17.html) - 0013h',
            'Notice that the first Load instruction refers to the memory location <<0013h|1>>, which is where the result of the first calculation was stored.',
          ],
          [
            1,
            '[00:00] Code - Charles Petzold.epub (OEBPS/ch17.html) - 0000h',
            'So now we have some instructions starting at address <<0000h|1>>, some data starting at <<0010h|1>>, some more instructions at <<0020h|1>>, and some more data at <<0030h|1>>. We want to let the automated adding machine start at <<0000h|1>> and execute all the instructions.',
          ],
          [
            1,
            '[00:12] Code - Charles Petzold.epub (OEBPS/ch17.html) - 0012h',
            "We know we must remove that Halt instruction at address 000Ch, and by remove I really mean replace it with something else. But is that sufficient? The problem is that whatever we replace the Halt instruction with is going to be interpreted as an instruction byte. And so will the bytes stored every 3 bytes after that\x{2014}at 000Fh, and <<0012h|1>>, and <<0015h|1>>, and <<0018h|1>>, and 001Bh, and 001Eh. What if one of these bytes just happens to be an 11h? That's a Store instruction. And what if the 2 bytes following that Store instruction happened to refer to address <<0023h|1>>? That would cause the machine to write the contents of the accumulator to that address. But that address contains something important already! And even if nothing like this happened, the next instruction byte that the adder retrieves from memory after the one at 001Eh will be at address <<0021h|1>>, not <<0020h|1>>, which is where our next real instruction happens to be.",
          ],
          [
            1,
            '[00:00] Code - Charles Petzold.epub (OEBPS/ch17.html) - 0000h',
            'So in the preceding example, the automated adder begins at <<0000h|1>>, as usual, and does a Load instruction, an Add, a Subtract, and a Store. It then does the Jump instruction and continues at address <<0020h|1>> with a Load, two Add instructions, a Store, and finally Halt.',
          ],
          [
            1,
            '[ap 00:58] Code - Charles Petzold.epub (OEBPS/ch17.html) - 2-to-1',
            'Otherwise, the changes aren\'t severe. The 16-bit address that\'s latched from the RAM array is an input to both the <<2-to-1|10a:0>> Selector (which allows this address to be an address input to the RAM array) and the 16-bit counter for the Set It function:',
          ],
          [
            1,
            '[10:04] Code - Charles Petzold.epub (OEBPS/ch17.html) - 1004h',
            'Everyone knows that multiplying A7h and 1Ch (which is 28 in decimal) is the same as 28 additions of A7h. So the 16-bit location at addresses <<1004h|1>> and <<1005h|1>> will actually be an accumulated summation. Here\'s the code for adding A7h to that location once:',
          ],
          [
            1,
            '[10:04] Code - Charles Petzold.epub (OEBPS/ch17.html) - 1004h',
            'At the completion of these six instructions, the 16-bit value at memory locations <<1004h|1>> and <<1005h|1>> will equal A7h times 1. Therefore, these six instructions have to be repeated 27 more times in order for that 16-bit value to equal A7h times 1Ch. You can achieve this by typing in these six instructions 27 more times beginning at address <<0012h|1>>. Or you can put a Halt instruction at <<0012h|1>> and press the Reset button 28 times to get the final answer.',
          ],
          [
            1,
            '[00:12] Code - Charles Petzold.epub (OEBPS/ch17.html) - 0012h',
            'But what if you put a Jump instruction at <<0012h|1>>? This instruction causes the counter to start from <<0000h|1>> again:',
          ],
          [
            1,
            '[10:04] Code - Charles Petzold.epub (OEBPS/ch17.html) - 1004h',
            'This certainly does the trick (sort of). The first time through, the 16-bit value at memory locations <<1004h|1>> and <<1005h|1>> will equal A7h times 1. Then the Jump instruction will go back up to the top. At the end of the second time through, the 16-bit result will equal A7h times 2. Eventually, it will equal A7h times 1Ch, but there\'s no stopping it. It just keeps going and going and going.',
          ],
          [
            1,
            '[00:12] Code - Charles Petzold.epub (OEBPS/ch17.html) - 0012h',
            'Now all that\'s necessary to make the code shown above multiply two numbers are the following instructions starting at address <<0012h|1>>:',
          ],
          [
            1,
            '[00:04] Code - Charles Petzold.epub (OEBPS/ch17.html) - 0004h',
            'The first time through, the 16-bit location at <<0004h|1>> and <<0005h|1>> contains A7h times 1, as we\'ve already established. The instructions here load the byte from location <<1003h|1>> into the accumulator. This is 1Ch. This byte is added to the value at location 001Eh. This happens to be the Halt instruction, but of course it\'s also a valid number. Adding FFh to 1Ch is the same as subtracting 1 from 1Ch, so the result is 1Bh. This isn\'t 0, so the Zero flag is 0. The 1Bh byte is stored back at address <<1003h|1>>. Next is a Jump If Not Zero instruction. The Zero flag isn\'t set to 1, so the jump occurs. The next instruction is the one located at address <<0000h|1>>.',
          ],
          [
            1,
            '[10:04] Code - Charles Petzold.epub (OEBPS/ch17.html) - 1004h',
            'The second time through, the 16-bit location at <<1004h|1>> and <<1005h|1>> will contain the value A7h times 2. The value 1Bh is added to FFh to get the result 1Ah. That\'s not 0, so back to the top.',
          ],
          [
            1,
            '[10:04] Code - Charles Petzold.epub (OEBPS/ch17.html) - 1004h',
            'On the twenty-eighth time through, the 16-bit location at <<1004h|1>> and <<1005h|1>> will contain the value A7h times 1Ch. At location <<1003h|1>> will be the value 1. This will be added to FFh and the result will be zero. The Zero flag will be set! So the Jump If Not Zero instruction will not jump back to <<0000h|1>>. Instead, the next instruction is a Halt. We\'re done.',
          ],
          [
            1,
            '[07:00] Code - Charles Petzold.epub (OEBPS/ch17.html) - seven this morning',
            'Computer programming is sometimes also referred to as writing code, or coding, as in, "I spent my vacation coding" or "I was up until <<seven this morning|5>> banging out some code." Sometimes computer programmers are known as coders, although some might consider this a derogatory term. Such programmers might prefer to be called software engineers.',
          ],
          [
            1,
            '[10:03] Code - Charles Petzold.epub (OEBPS/ch17.html) - 1003h',
            'These mnemonics are particularly useful when combined with a couple of other shortcuts. For example, instead of saying something long-winded like, "Load byte at address <<1003h|1>> into accumulator," we can instead write the statement:',
          ],
          [
            1,
            '[10:03] Code - Charles Petzold.epub (OEBPS/ch17.html) - 1003h',
            'These mnemonics are particularly useful when combined with a couple of other shortcuts. For example, instead of saying something long-winded like, "Load byte at address <<1003h|1>> into accumulator," we can instead write the statement:
LOD A,[<<1003h|1>>]
The A and the [1003] that appear to the right of the mnemonic are called arguments that indicate what\'s going on with this particular Load instruction. The arguments are written with a destination on the left (the A stands for accumulator) and a source on the right. The brackets indicate that the accumulator should be loaded not with the value <<1003h|1>> but with the value stored in memory at address <<1003h|1>>.',
          ],
          [
            1,
            '[10:03] Code - Charles Petzold.epub (OEBPS/ch17.html) - 1003h',
            'The A and the [1003] that appear to the right of the mnemonic are called arguments that indicate what\'s going on with this particular Load instruction. The arguments are written with a destination on the left (the A stands for accumulator) and a source on the right. The brackets indicate that the accumulator should be loaded not with the value <<1003h|1>> but with the value stored in memory at address <<1003h|1>>.',
          ],
          [
            1,
            '[10:03] Code - Charles Petzold.epub (OEBPS/ch17.html) - 1003h',
            'ADD A,[001Eh]
and "Store contents of accumulator at address <<1003h|1>>" is
STO [<<1003h|1>>],A',
          ],
          [
            1,
            '[10:03] Code - Charles Petzold.epub (OEBPS/ch17.html) - 1003h',
            'and "Store contents of accumulator at address <<1003h|1>>" is
STO [<<1003h|1>>],A
Notice that the destination (a memory location for the Store instruction) is still on the left and the source is on the right. The contents of the accumulator must be stored in memory at address <<1003h|1>>. The wordy "Jump to <<0000h|1>> if the Zero flag is not 1" is more concisely written as',
          ],
          [
            1,
            '[10:03] Code - Charles Petzold.epub (OEBPS/ch17.html) - 1003h',
            'Notice that the destination (a memory location for the Store instruction) is still on the left and the source is on the right. The contents of the accumulator must be stored in memory at address <<1003h|1>>. The wordy "Jump to <<0000h|1>> if the Zero flag is not 1" is more concisely written as',
          ],
          [
            1,
            '[10:03] Code - Charles Petzold.epub (OEBPS/ch17.html) - 1003h',
            'Notice that the destination (a memory location for the Store instruction) is still on the left and the source is on the right. The contents of the accumulator must be stored in memory at address <<1003h|1>>. The wordy "Jump to <<0000h|1>> if the Zero flag is not 1" is more concisely written as
JNZ <<0000h|1>>
The brackets aren\'t used in this instruction because the instruction jumps to address <<0000h|1>>, not to the value that might be stored at address <<0000h|1>>.',
          ],
          [
            1,
            '[00:00] Code - Charles Petzold.epub (OEBPS/ch17.html) - 0000h',
            'The brackets aren\'t used in this instruction because the instruction jumps to address <<0000h|1>>, not to the value that might be stored at address <<0000h|1>>.',
          ],
          [
            1,
            '[00:00] Code - Charles Petzold.epub (OEBPS/ch17.html) - 0000h',
            'It\'s convenient to write these instructions in this type of shorthand because the instructions can be listed sequentially in a readable way that doesn\'t require us to draw boxes of memory locations. To indicate that a particular instruction is stored at a particular address, you can use the hexadecimal address followed by a colon, such as
<<0000h|1>>: LOD A,[<<1005h|1>>]
And here\'s how we can indicate some data stored at a particular address:',
          ],
          [
            1,
            '[10:00] Code - Charles Petzold.epub (OEBPS/ch17.html) - 1000h',
            'And here\'s how we can indicate some data stored at a particular address:
<<1000h|1>>: 00h, A7h <<1002h|1>>: 00h, 1Ch <<1004h|1>>: 00h, 00h
The 2 bytes separated by commas indicate that the first byte is stored at the address on the left and the second byte is stored at the next address. These three lines are equivalent to',
          ],
          [
            1,
            '[10:00] Code - Charles Petzold.epub (OEBPS/ch17.html) - 1000h',
            'The 2 bytes separated by commas indicate that the first byte is stored at the address on the left and the second byte is stored at the next address. These three lines are equivalent to
<<1000h|1>>: 00h, A7h, 00h, 1Ch, 00h, 00h
So the entire multiplication program can be written as a series of statements like this:',
          ],
          [
            1,
            '[00:00] Code - Charles Petzold.epub (OEBPS/ch17.html) - 0000h',
            '<<0000h|1>>: LOD A,[<<1005h|1>>] ADD A,[<<1001h|1>>] STO [<<1005h|1>>],A LOD A,[<<1004h|1>>] ADC A,[<<1000h|1>>] STO [<<1004h|1>>],A LOD A,[<<1003h|1>>] ADD A,[001Eh] STO [<<1003h|1>>],A JNZ <<0000h|1>> 001Eh: HLT <<1000h|1>>: 00h, A7h <<1002h|1>>: 00h, 1Ch <<1004h|1>>: 00h, 00h',
          ],
          [
            1,
            '[20:00] Code - Charles Petzold.epub (OEBPS/ch17.html) - 2000h',
            'It\'s better not to use actual numeric addresses when writing code because they can change. For example, if you decided to store the numbers at memory locations <<2000h|1>> through <<20005h|1>>, you\'d need to rewrite many of the statements as well. It\'s better to use labels to refer to locations in memory. These labels are simply words, or they look almost like words, like this:',
          ],
          [
            1,
            '[ap 02:56] Code - Charles Petzold.epub (OEBPS/ch17.html) - 256',
            'There\'s even a bug in my multiplication program. If you run it twice, the second time through it will multiply A7h by <<256|3:0>> and add that result to the result already calculated. This is because after you run the program once, the number at address <<1003h|1>> will be 0. When you run it the second time, FFh will be added to that value. The result won\'t be 0, so the program will keep running until it is.',
          ],
          [
            1,
            '[~ 19:45] Code - Charles Petzold.epub (OEBPS/ch17.html) - around 1945',
            'I\'ve mentioned several times that all the hardware to build these devices was available over a hundred years ago. But it\'s unlikely that the computer shown in this chapter could have been built at that time. Many of the concepts implicit in its design weren\'t apparent when relay computers were first built in the mid-1930s and only started to be understood <<around 1945|18:0>> or so. Until that time, for example, people were still trying to build computers that internally used decimal numbers rather than binary. And computer programs weren\'t always stored in memory but instead were sometimes coded on paper tape. In particular, in the early days of computers, memory was expensive and bulky. Building a 64-KB RAM array from five million telegraph relays would have been as absurd one hundred years ago as it is now.',
          ],
          [
            1,
            '[~ 16:20] Code - Charles Petzold.epub (OEBPS/ch18.html) - around 1620',
            "Napier also invented another multiplication aid, which is composed of strips of numbers usually inscribed on bone, horn, or ivory and hence referred to as Napier's Bones. The earliest mechanical calculator was a somewhat automated version of Napier's bones built <<around 1620|18:0>> by Wilhelm Schickard (1592\x{2013}1635). Other calculators based on interlocking wheels, gears, and levers are almost as old. Two of the more significant builders of mechanical calculators were the mathematicians and philosophers Blaise Pascal (1623\x{2013}1662) and Gottfried Wilhelm von Leibniz (1646\x{2013}1716).",
          ],
          [
            1,
            '[~ 18:20] Code - Charles Petzold.epub (OEBPS/ch18.html) - about 1820',
            'Beginning <<about 1820|18:0>>, Babbage believed that he could design and build a machine that would automate the process of constructing a table, even to the point of setting up type for printing. This would eliminate errors. He conceived the Difference Engine, and basically it was a big mechanical adding machine. Multidigit decimal numbers were represented by geared wheels that could be in any of 10 positions. Negatives were handled using the ten\'s complement. Despite some early models that showed Babbage\'s design to be sound and some grants from the British government (never enough, of course), the Difference Engine was never completed. Babbage abandoned work on it in 1833.',
          ],
          [
            1,
            '[19:11] Code - Charles Petzold.epub (OEBPS/ch18.html) - 1911',
            "Herman Hollerith also set in motion a long trail of events. In 1896, he founded the Tabulating Machine Company to lease and sell the punch-card equipment. By <<1911|9:0>>, with the help of a couple of mergers, it had become the Computing-Tabulating-Recording Company, or C-T-R. By <<1915|9:0>>, the president of C-T-R was Thomas J. Watson (1874\x{2013}1956), who in 1924 changed the name of the company to International Business Machines Corporation, or IBM.",
          ],
          [
            1,
            '[19:28] Code - Charles Petzold.epub (OEBPS/ch18.html) - 1928',
            "By <<1928|9:0>>, the original 1890 census cards had evolved into the famous \"do not spindle, fold, or mutilate\" IBM cards, with 80 columns and 12 rows. They remained in active use for over 50 years, and even in their later years were sometimes referred to as Hollerith cards. I'll describe the legacy of these cards more in Chapters Chapter\x{a0}20, Chapter\x{a0}21, and Chapter\x{a0}24.",
          ],
          [
            1,
            '[19:45] Code - Charles Petzold.epub (OEBPS/ch18.html) - 1945',
            'But beginning in the early 1940s, vacuum tubes began supplanting relays in new computers. By <<1945|9:0>>, the transition was complete. While relay machines were known as electromechanical computers, vacuum tubes were the basis of the first electronic computers.',
          ],
          [
            1,
            '[ap ~ 10:24] Code - Charles Petzold.epub (OEBPS/ch18.html) - about 1024',
            'At the time of the EDVAC, it wasn\'t cost effective to build a lot of memory out of vacuum tubes. Some very odd solutions were proposed instead. One successful one was mercury delay line memory, which used 5-foot tubes of mercury. At one end of the tube, little pulses were sent into the mercury about 1 microsecond apart. These pulses took about a millisecond to reach the other end (where they were detected like sound waves and routed back to the beginning), and hence each tube of mercury could store <<about 1024|18:0>> bits of information.',
          ],
          [
            1,
            '[ap 07:01] Code - Charles Petzold.epub (OEBPS/ch18.html) - 701',
            "In 1948, the Eckert-Mauchly Computer Corporation (later part of Remington Rand) began work on what would become the first commercially available computer\x{2014}the Universal Automatic Computer, or UNIVAC. It was completed in 1951, and the first one was delivered to the Bureau of the Census. The UNIVAC made its prime-time network debut on CBS, when it was used to predict results of the 1952 presidential election. Walter Cronkite referred to it as an \"electronic brain.\" Also in 1952, IBM announced the company's first commercial computer system, the <<701|9l>>.",
          ],
          [
            1,
            '[19:56] Code - Charles Petzold.epub (OEBPS/ch18.html) - 1956',
            'The transistor didn\'t come out of the blue. Eight years earlier, on December 29, 1939, Shockley had written in his notebook, "It has today occurred to me that an amplifier using semiconductors rather than vacuum is in principle possible." And after that first transistor was demonstrated, many years followed in perfecting it. It wasn\'t until <<1956|18:0>> that Shockley, Bardeen, and Brattain were awarded the Nobel Prize in physics "for their researches on semiconductors and their discovery of the transistor effect."',
          ],
          [
            1,
            '[~ 20:15] Code - Charles Petzold.epub (OEBPS/ch18.html) - about 2015',
            'In 1965, Gordon E. Moore (then at Fairchild and later a cofounder of Intel Corporation) noticed that technology was improving in such a way that the number of transistors that could fit on a single chip had doubled every year since 1959. He predicted that this trend would continue. The actual trend was a little slower, so Moore\'s Law (as it was eventually called) was modified to predict a doubling of transistors on a chip every 18 months. This is still an astonishingly fast rate of progress and reveals why home computers always seem to become outdated in just a few short years. Some people believe that Moore\'s Law will continue to be accurate until <<about 2015|9c:0>>.',
          ],
          [
            1,
            '[ap 05:25] Code - Charles Petzold.epub (OEBPS/ch18.html) - 5.25',
            'For 7400 series TTL, VCC must be between 4.75 and 5.25 volts. Another way of saying this is that the power supply voltage must be 5 volts plus or minus 5 percent. If the power supply is below 4.75 volts, the chip might not work. If it\'s higher than <<5.25|5a:0>>, the chip could be damaged. You generally can\'t use batteries with TTL; even if you were to find a 5-volt battery, the voltage wouldn\'t be exact enough to be adequate for these chips. TTL usually requires a power supply that you plug into the wall.',
          ],
          [
            1,
            '[ap 02:00] Code - Charles Petzold.epub (OEBPS/ch18.html) - 200',
            "But back to the mid-1970s. Despite the limitations of the 4004, it was a start. By April 1972, Intel had released the 8008\x{2014}an 8-bit microprocessor running at <<200|3:0>> kHz that could address 16 KB of memory. (See how easy it is to sum up a processor with just three numbers?) And then, in a five-month period in 1974, both Intel and Motorola came out with microprocessors that were intended to improve on the 8008. These two chips changed the world.",
          ],
          [
            1,
            '[~ 23:00] Code - Charles Petzold.epub (OEBPS/ch19.html) - about 2300',
            "The microprocessor\x{2014}a consolidation of all the components of a central processing unit (CPU) of a computer on a single chip of silicon\x{2014}was born in 1971. It was a modest beginning: The first microprocessor, the Intel 4004, contained <<about 2300|18:0>> transistors. Today, nearly three decades later, microprocessors made for home computers are approaching the 10,000,000 transistor mark.",
          ],
          [
            1,
            '[00:00] Code - Charles Petzold.epub (OEBPS/ch19.html) - 0000h',
            'After the 8080 chip is reset, it reads the byte located at memory address <<0000h|1>> into the microprocessor. It does this by outputting 16 zeros on the address signals A0 through A15. The byte it reads should be an 8080 instruction, and the process of reading this byte is known as an instruction fetch.',
          ],
          [
            1,
            '[17:56] Code - Charles Petzold.epub (OEBPS/ch19.html) - 4 to 18',
            "When the 8080 is running at its maximum speed of 2 MHz, each clock cycle is 500 nanoseconds. (1 \x{f7} 2,000,000 cycles per second = 0.000000500 seconds.) The instructions in the Chapter\x{a0}17 computer all required 4 clock cycles. Each 8080 instruction requires anywhere from <<4 to 18|10a:1>> clock cycles. This means that each instruction is executed in <<2 to 9|10a:1>> microseconds (millionths of a second).",
          ],
          [
            1,
            '[00:00] Code - Charles Petzold.epub (OEBPS/ch19.html) - 0000',
            'The DAA instruction helps a programmer implement decimal arithmetic using a method of representing numbers known as binary-coded decimal, or BCD. In BCD, each nibble of data may range only from <<0000|18:0>> through 1001, corresponding to decimal digits 0 through 9. The 8 bits of a byte can store two decimal digits in BCD format.',
          ],
          [
            1,
            '[00:00] Code - Charles Petzold.epub (OEBPS/ch19.html) - 0000h',
            'If you have 64 KB of memory connected to your 8080, you might want to initially set the Stack Pointer to <<0000h|1>>. The first PUSH instruction decrements that address to FFFFh. The stack then occupies the area of memory with the very highest addresses, quite a distance from your programs, which will probably be in the area of memory starting at address <<0000h|1>>.',
          ],
          [
            1,
            '[00:00] Code - Charles Petzold.epub (OEBPS/ch19.html) - 0000h',
            'The LXI instruction saves a byte. In addition, the last LXI instruction in the preceding table is used to set the Stack Pointer to a particular value. It\'s not uncommon for this instruction to be one of the first instructions that a microprocessor executes after being restarted:
<<0000h|1>>: LXI SP,0000h
It\'s also possible to increment and decrement register pairs and the Stack Pointer as if they were 16-bit registers:',
          ],
          [
            1,
            '[00:00] Code - Charles Petzold.epub (OEBPS/ch19.html) - 0000h',
            'Multiply: PUSH PSW ; Save registers being altered PUSH BC SUB H,H ; Set HL (result) to <<0000h|1>> SUB L,L MOV A,B ; The multiplier goes in A CPI A,00h ; If it\'s 0, we\'re finished. JZ AllDone MVI B,00h ; Set high byte of BC to 0 MultLoop: DAD HL,BC ; Add BC to HL DEC A ; Decrement multiplier JNZ MultLoop ; Loop if it\'s not 0 AllDone: POP BC ; Restore saved registers POP PSW RET ; Return',
          ],
          [
            1,
            '[00:00] Code - Charles Petzold.epub (OEBPS/ch19.html) - 0000h',
            "These are called Restart instructions, and they're similar to Call instructions in that the current Program Counter is saved on the stack. But the Restart instructions then jump to specific locations: RST 0 jumps to address <<0000h|1>>, RST 1 to address <<0008h|1>>, and so forth, up to RST 7, which jumps to address <<0038h|1>>. Located at these addresses are sections of code that deal with the interrupt. For example, an interrupt from the keyboard might cause a RST 4 instruction to be executed. At address <<0020h|1>> begins some code to read a byte from the keyboard. (I'll explain this more fully in Chapter\x{a0}21.)",
          ],
          [
            1,
            '[~ 17:50] Code - Charles Petzold.epub (OEBPS/ch20.html) - about 1750',
            "For example, a traditional double-spaced typewritten 8\x{bd}-by-11-inch page with 1-inch margins has about 27 lines of text. Each line is about 6\x{bd} inches wide with 10 characters per inch, for a total of <<about 1750|18:0>> bytes. A singlespace typewritten page has about double that, or 3.5 kilobytes.",
          ],
          [
            1,
            '[ap ~ 02:25] Code - Charles Petzold.epub (OEBPS/ch20.html) - about 2.25',
            'Herman Melville\'s Moby Dick is about 1.3 megabytes.
Henry Fielding\'s The History of Tom Jones is <<about 2.25|5a:0>> megabytes.
Margaret Mitchell\'s Gone with the Wind is about 2.5 megabytes.',
          ],
          [
            1,
            '[00:00] Code - Charles Petzold.epub (OEBPS/ch20.html) - 0000h',
            'Under the assumption that it\'s preferable to have just one unambiguous character encoding system that\'s suitable for all the world\'s languages, in 1988 several major computer companies got together and began developing an alternative to ASCII known as Unicode. Whereas ASCII is a 7-bit code, Unicode is a 16-bit code. Each and every character in Unicode requires 2 bytes. That means that Unicode has character codes ranging from <<0000h|1>> through FFFFh and can represent 65,536 different characters. That\'s enough for all the world\'s languages that are likely to be used in computer communication, with room for expansion.',
          ],
          [
            1,
            '[00:00] Code - Charles Petzold.epub (OEBPS/ch20.html) - 0000h',
            "Unicode doesn't start from scratch. The first 128 characters of Unicode\x{2014}codes <<0000h|1>> through 007Fh\x{2014}are the same as the ASCII characters. Also, Unicode codes 00A0h through 00FFh are the same as the Latin Alphabet No. 1 extension of ASCII that I described earlier. Other worldwide standards are also incorporated into Unicode.",
          ],
          [
            1,
            '[ap ~ 02:00] Code - Charles Petzold.epub (OEBPS/ch20.html) - about 2',
            'The only real problem with Unicode is that it makes invalid the old equivalence between one character of text and 1 byte of storage. Encoded in ASCII, The Grapes of Wrath is about 1 megabyte in size. Encoded in Unicode, it\'s <<about 2|9w>> megabytes. But that\'s a small price to pay for a universal unambiguous character encoding system.',
          ],
          [
            1,
            '[00:00] Code - Charles Petzold.epub (OEBPS/ch21.html) - 0000h',
            'Because the S-100 bus was designed for the 8080 chip, it has 16 address signals, 8 data input signals, and 8 data output signals. (As you\'ll recall, the 8080 itself combines the data input and data output signals. These signals are divided into separate input and output signals by other chips on the circuit board that contains the 8080.) The bus also includes 8 interrupt signals. These are signals generated by other devices when they need immediate attention from the CPU. For example (as we\'ll see later in this chapter), a keyboard might generate an interrupt signal when a key is pressed. A short program run by the 8080 can then determine what that key was and take some action. The board containing the 8080 also generally includes a chip called the Intel 8214 Priority Interrupt Control Unit to handle these interrupts. When an interrupt occurs, this chip generates an interrupt signal to the 8080. When the 8080 acknowledges the interrupt, the chip provides a RST (Restart) instruction that causes the microprocessor to save the current program counter and branch to address <<0000h|1>>, <<0008h|1>>, <<0010h|1>>, <<0018h|1>>, <<0020h|1>>, <<0028h|1>>, <<0030h|1>>, or <<0038h|1>> depending on the interrupt.',
          ],
          [
            1,
            '[15:52] Code - Charles Petzold.epub (OEBPS/ch21.html) - 8 to 16',
            'Busses need to be upgraded or replaced when microprocessors outgrow them, either in data width (from <<8 to 16|10a:1>> to 32 bits) or in the number of address signals they output. But microprocessors also outgrow busses when they achieve faster speeds. Early busses were designed for microprocessors operating at a clock speed of several megahertz rather than several hundred megahertz. When a bus isn\'t properly designed for high speeds, it can give off radio frequency interference (RFI) that causes static or other noise on nearby radios and television sets.',
          ],
          [
            1,
            '[00:00] Code - Charles Petzold.epub (OEBPS/ch21.html) - 0000h',
            "The 10 address signals A0 through A9 are directly wired to the RAM chips. The address signals A10 and A11 select which of the four banks is being addressed. The address signals A12 through A15 determine which addresses apply to this particular board\x{2014}in other words, the addresses that the board responds to. The 4-KB memory board we're designing can occupy one of 16 different 4-KB ranges in the entire 64-KB memory space of the microprocessor:
<<0000h|1>> through 0FFFh, or
<<1000h|1>> through 1FFFh, or",
          ],
          [
            1,
            '[00:00] Code - Charles Petzold.epub (OEBPS/ch21.html) - 0000h',
            '<<0000h|1>> through 0FFFh, or
<<1000h|1>> through 1FFFh, or
<<2000h|1>> through 2FFFh, or',
          ],
          [
            1,
            '[10:00] Code - Charles Petzold.epub (OEBPS/ch21.html) - 1000h',
            "<<1000h|1>> through 1FFFh, or
<<2000h|1>> through 2FFFh, or
\x{22ee}",
          ],
          [
            1,
            '[ap 00:56] Code - Charles Petzold.epub (OEBPS/ch21.html) - 4-to-1',
            "If you recall the messy details of combining RAM arrays in Chapter\x{a0}16, you might assume that we also need eight <<4-to-1|10a:0>> Selectors to select the correct data output signals from the four banks of memory. But we don't, and here's why.",
          ],
          [
            1,
            '[ap 02:00] Code - Charles Petzold.epub (OEBPS/ch21.html) - 200',
            'We can thus say that the resolution of a primitive video display adapter attached to a conventional television set is 320 pixels across by <<200|3:0>> pixels down, or 320 pixels horizontally by <<200|3:0>> pixels vertically, commonly referred to as 320 by 200 or 320 x 200:',
          ],
          [
            1,
            '[ap 02:00] Code - Charles Petzold.epub (OEBPS/ch21.html) - 200',
            "If the video adapter board is not restricted to text only, it's referred to as a graphics board. By writing into the RAM on a graphics video board, a microprocessor can draw pictures, including text in a multitude of sizes and styles. Graphics video boards require more memory than text-only boards. A graphics video board that displays 320 pixels across by <<200|3:0>> pixels down has 64,000 pixels. If each pixel corresponds to one bit of RAM, such a board requires 64,000 bits of RAM, or 8000 bytes. This, however, is the rock-bottom minimum. A correspondence of 1 bit to 1 pixel allows the use of only two colors\x{2014}for instance, black and white. A 0 bit might correspond to a black pixel, and a 1 bit might correspond to a white pixel.",
          ],
          [
            1,
            '[ap 01:33] Code - Charles Petzold.epub (OEBPS/ch21.html) - 1.33',
            'The 640-by-480 resolution was a significant milestone, but you might not believe that the reason for its importance goes back to Thomas Edison! Around 1889, when Edison and his engineer William Kennedy Laurie Dickson were working on the Kinetograph motion picture camera and the Kinetoscope projector, they decided to make the motion picture image one-third wider than it was high. The ratio of the width of the image to its height is called the aspect ratio. The ratio that Edison and Dickson established is commonly expressed as <<1.33|5a:0>> to 1, or <<1.33|5a:0>>:1, or, to avoid fractions, 4:3. This aspect ratio was used for most movies for over 60 years, and it was also used for television. Only in the early 1950s did the Hollywood studios introduce some widescreen techniques that competed against television by going beyond the 4:3 aspect ratio.',
          ],
          [
            1,
            '[00:00] Code - Charles Petzold.epub (OEBPS/ch21.html) - 0000',
            'To prevent my diagram of the keyboard hardware from becoming unwieldy, I\'m going to assume that our keyboard has a mere 16 keys. Whenever a key is pressed, the keyboard hardware should generate a 4-bit code with binary values ranging from <<0000|18:0>> through 1111.',
          ],
          [
            1,
            '[ap 01:10] Code - Charles Petzold.epub (OEBPS/ch21.html) - 0110',
            'The outputs of the 4-bit counter are the select inputs of both a 2-Line-to-4-Line Decoder and a 4-Line-to-1-Line Data Selector. If no keys are pressed, none of the inputs to the selector can be 1. Therefore the output of the selector isn\'t 1. But if a particular key is pressed, at a particular 4-bit counter output the output from the selector will be 1. For example, if the switch second from the top and right is pressed, and if the counter output is <<0110|18:0>>, the output from the selector becomes 1:',
          ],
          [
            1,
            '[ap 07:57] Code - Charles Petzold.epub (OEBPS/ch21.html) - 3-to-8',
            'If your keyboard has 64 keys, you need a 6-bit scan code. That would involve a 6-bit counter. You could arrange the keys in an 8x8 array, using a <<3-to-8|10a:0>> Decoder and a <<1-of-8|10>> Selector. If your keyboard has between 65 and 128 keys, you need a 7-bit code. You could arrange the keys in an 8x16 array and use a <<4-to-16|10a:0>> Decoder and an <<8-to-1|10a:0>> Selector (or a <<3-to-8|10a:0>> Decoder and a <<16-to-1|10a:0>> Selector).',
          ],
          [
            1,
            '[00:00] Code - Charles Petzold.epub (OEBPS/ch22.html) - 0000h',
            'What we\'re missing here is software. When a microprocessor is first turned on or reset, it begins executing machine code at a particular memory address. In the case of the Intel 8080, that address is <<0000h|1>>. In a properly designed computer, that memory address should contain a machine-code instruction (most likely the first of many) when the computer is turned on.',
          ],
          [
            1,
            '[ap 09:00] Code - Charles Petzold.epub (OEBPS/ch22.html) - 0 to 9',
            'NibbleToAscii: CPI A,0Ah ; Check if it\'s a letter or number JC Number ADD A,37h ; A to F converted to 41h to 46h RET Number: ADD A,30h ; <<0 to 9|10a:0>> converted to 30h to 39h RET',
          ],
          [
            1,
            '[ap 01:59] Code - Charles Petzold.epub (OEBPS/ch22.html) - A to two',
            'This subroutine calls NibbleToAscii twice to convert a byte in accumulator <<A to two|10>> ASCII digits in registers B and C:',
          ],
          [
            1,
            '[00:08] Code - Charles Petzold.epub (OEBPS/ch22.html) - 0008h',
            'The key, of course, is the keyboard. We\'ve constructed the computer keyboard so that every time a key is pressed, an interrupt to the microprocessor occurs. The interrupt controller chip that we\'ve used in our computer causes the microprocessor to respond to this interrupt by executing a RST (Restart) instruction. Let\'s suppose that this is a RST 1 instruction. This instruction causes the microprocessor to save the current program counter on the stack and to jump to address <<0008h|1>>. Beginning at that address, you\'ll enter some code (using the control panel) that we\'ll call the keyboard handler.',
          ],
          [
            1,
            '[10:20] Code - Charles Petzold.epub (OEBPS/ch22.html) - 1020h',
            "This command instructs the command processor to write the hexadecimal bytes 35, 4F, and so on into the memory addresses beginning at address <<1020h|1>>. For this job, the keyboard handler needs to convert ASCII codes to bytes\x{2014}a reversal of the conversion I demonstrated earlier.",
          ],
          [
            1,
            '[10:30] Code - Charles Petzold.epub (OEBPS/ch22.html) - 1030h',
            'The command processor responds by displaying the 11 bytes stored beginning at location <<1030h|1>>. (I say 11 bytes because that\'s how many will fit on a 40-characterwide display on the same line following the address.) You can use the Display command to examine the contents of memory.',
          ],
          [
            1,
            '[10:00] Code - Charles Petzold.epub (OEBPS/ch22.html) - 1000h',
            'and means "Run the program that\'s stored beginning at address <<1000h|1>>." The command processor stores <<1000h|1>> in the register pair HL and then executes the instruction PCHL, which loads the program counter from register pair HL, effectively jumping to that address.',
          ],
          [
            1,
            '[00:00] Code - Charles Petzold.epub (OEBPS/ch22.html) - 0000h',
            'As you\'ll recall, we wired our RAM boards with a DIP switch that allows us to specify the starting address of the board. If you\'re working with an 8080 system, initially one of your RAM boards will be set for address <<0000h|1>>. After you create a ROM, that ROM will occupy address <<0000h|1>> and the RAM board can be switched to a higher address.',
          ],
          [
            1,
            '[01:00] Code - Charles Petzold.epub (OEBPS/ch22.html) - 0100h',
            'If you type in a command that CP/M doesn\'t recognize, it assumes you\'re specifying the name of a program that\'s stored as a file on the disk. Programs always have the file type COM, which stands for Command. The CCP searches for a file of that name on the disk. If one exists, CP/M loads the file from disk into the Transient Program Area, which begins at memory address <<0100h|1>>. This is how you run programs that are located on the disk. For example, if you type',
          ],
          [
            1,
            '[01:00] Code - Charles Petzold.epub (OEBPS/ch22.html) - 0100h',
            'following the CP/M prompt, and if a file named CALC.COM exists on the disk, the CCP loads that file into memory starting at address <<0100h|1>> and then executes the program by jumping to the machine-code instruction located at address <<0100h|1>>.',
          ],
          [
            1,
            '[01:00] Code - Charles Petzold.epub (OEBPS/ch22.html) - 0100h',
            'Earlier I explained how you can insert machine-code instructions any-where into memory and execute them, but in CP/M programs that are stored in disk files must be designed to be loaded into memory beginning at a specific memory location, which is <<0100h|1>>.',
          ],
          [
            1,
            '[00:05] Code - Charles Petzold.epub (OEBPS/ch22.html) - 0005h',
            "What does CALL 5 actually do? The memory location at <<0005h|1>> is set up by CP/M to contain a JMP (Jump) instruction, which jumps to a location in the Basic Disk Operating System (BDOS) of CP/M. This area contains a bunch of subroutines that execute each of the CP/M functions. The BDOS\x{2014}as its name implies\x{2014}is primarily responsible for maintaining the file system on the disk. Frequently, the BDOS has to make use of subroutines in the Basic Input/Output System (BIOS) of CP/M, which is the area that actually accesses the hardware of the keyboard, the video display, and the disk drives. In fact, the BIOS is the only section of CP/M that needs to know about the hardware of the computer. The CCP does everything it needs to do using BDOS functions, and so do the utilities that come with CP/M.",
          ],
          [
            1,
            '[00:00] Code - Charles Petzold.epub (OEBPS/ch23.html) - 0000',
            '0
<<0000|18:0>>
1',
          ],
          [
            1,
            '[00:01] Code - Charles Petzold.epub (OEBPS/ch23.html) - 0001',
            '1
<<0001|18:0>>
2',
          ],
          [
            1,
            '[00:10] Code - Charles Petzold.epub (OEBPS/ch23.html) - 0010',
            '2
<<0010|18:0>>
3',
          ],
          [
            1,
            '[00:11] Code - Charles Petzold.epub (OEBPS/ch23.html) - 0011',
            '3
<<0011|18:0>>
4',
          ],
          [
            1,
            '[ap 01:00] Code - Charles Petzold.epub (OEBPS/ch23.html) - 0100',
            '4
<<0100|18:0>>
5',
          ],
          [
            1,
            '[ap 01:01] Code - Charles Petzold.epub (OEBPS/ch23.html) - 0101',
            '5
<<0101|18:0>>
6',
          ],
          [
            1,
            '[ap 01:10] Code - Charles Petzold.epub (OEBPS/ch23.html) - 0110',
            '6
<<0110|18:0>>
7',
          ],
          [
            1,
            '[ap 01:11] Code - Charles Petzold.epub (OEBPS/ch23.html) - 0111',
            '7
<<0111|18:0>>
8',
          ],
          [
            1,
            '[ap 02:00] Code - Charles Petzold.epub (OEBPS/ch23.html) - two',
            "This type of storage and notation is also called fixed-point format because the decimal point is always fixed at a particular number of places\x{2014}in our example, at <<two|9:0>> decimal places. Notice that there's nothing actually stored along with the number that indicates the position of the decimal point. Programs that work with numbers in fixed-point format must know where the decimal point is. You can create fixed-point numbers with any number of decimal places, and you can mix and match these numbers in the same computer program. But any part of the program that does arithmetic on the numbers has to know where the decimal points are.",
          ],
          [
            1,
            '[ap 10:10] Code - Charles Petzold.epub (OEBPS/ch23.html) - 10-10',
            'is written
2.6 x <<10-10|5a:0>>
In these two examples, the numbers 4.9 and 2.6 are called the fraction part, or the characteristic, or sometimes (although this word is more properly used in conjunction with logarithms) the mantissa. But to be more in tune with the terminology used with computers, I\'m going to call this part of scientific notation the significand.',
          ],
          [
            1,
            '[ap 01:00] Code - Charles Petzold.epub (OEBPS/ch23.html) - 1',
            'Or the negative powers of two can be calculated by starting at <<1|9g>> and repeatedly dividing by 2:',
          ],
          [
            1,
            '[ap 10:38] Code - Charles Petzold.epub (OEBPS/ch23.html) - 10-38',
            'In decimal, these two numbers are approximately 1.175494351 x <<10-38|5a:0>> and <<3|91:0>>.402823466 x 1038. That\'s the effective range of single-precision floating-point notation.',
          ],
          [
            1,
            '[ap 03:50] Code - Charles Petzold.epub (OEBPS/ch23.html) - 3.50',
            'That\'s one reason why fixed-point is preferred when dealing with dollars and cents. When you work with floating-point numbers, you could also discover other little quirks that can drive you mad. Your program will do a calculation that should yield the result <<3.50|5a:0>> and instead you get 3.499999999999. This type of thing tends to happen in floating-point calculations, and there isn\'t a whole lot you can do about it.',
          ],
          [
            1,
            '[ap 03:08] Code - Charles Petzold.epub (OEBPS/ch23.html) - 308',
            'The range is decimal in approximately 2.2250738585072014 x 10-308 to 1.7976931348623158 x 10308. Ten to the 308th power is a very big number. It\'s 1 followed by <<308|3:0>> decimal zeros.',
          ],
          [
            1,
            '[01:00] Code - Charles Petzold.epub (OEBPS/ch24.html) - 0100h',
            'First you create a text file to contain your program written in assembly language. You can use the CP/M program ED.COM for this job. This program is a text editor, which means that it allows you to create and modify text files. Let\'s suppose you create a text file with the name PROGRAM1.ASM. The ASM file type indicates that this file contains an assembly-language program. The file might look something like this:
ORG <<0100h|1>> LXI DE, Text MVI C,9 CALL 5 RET Text: DB \'Hello!$\' END
This file has a couple of statements we haven\'t seen before. The first one is an ORG (for origin) statement. This statement does not correspond to an 8080 instruction. Instead, it indicates that the address of the next statement is to begin at address <<0100h|1>>, which you\'ll recall is the address where CP/M loads programs into memory.',
          ],
          [
            1,
            '[01:00] Code - Charles Petzold.epub (OEBPS/ch24.html) - 0100h',
            'This file has a couple of statements we haven\'t seen before. The first one is an ORG (for origin) statement. This statement does not correspond to an 8080 instruction. Instead, it indicates that the address of the next statement is to begin at address <<0100h|1>>, which you\'ll recall is the address where CP/M loads programs into memory.',
          ],
          [
            1,
            '[01:09] Code - Charles Petzold.epub (OEBPS/ch24.html) - 0109h',
            'Notice how the assembler figures out that the LXI instruction must set the register pair DE to the address <<0109h|1>>. If the LXI instruction itself is located at <<0100h|1>> (as it is when CP/M loads the program into memory to run), address <<0109h|1>> is where the text string begins. Generally a programmer using an assembler doesn\'t need to worry about the specific addresses associated with different parts of the program.',
          ],
          [
            1,
            '[ap 02:59] Code - Charles Petzold.epub (OEBPS/ch24.html) - a to 3',
            'The for statement initially sets the variable <<a to 3|10>> and executes the block following the for statement. Then a is increased by the number following the step keyword, which is <<2|9c:0>>. The new value of a, which is <<5|9c:0>>, is used to execute the block. The variable a will continue to be increased by 2. When it exceeds 99, the for loop is completed.',
          ],
          [
            1,
            '[ap 08:08] Code - Charles Petzold.epub (OEBPS/ch25.html) - 808',
            "The video display was one of the several unusual aspects of the Alto. The screen was approximately the size and shape of a sheet of paper\x{2014}8 inches wide and 10 inches high. It ran in a raster graphics mode with 606 pixels horizontally by <<808|3:0>> pixels vertically, for a total of 489,648 pixels. One bit of memory was devoted to each pixel, which meant that each pixel could be either black or white. The total amount of memory devoted to the video display was 64 KB, which was part of the address space of the processor.",
          ],
          [
            1,
            '[ap 03:42] Code - Charles Petzold.epub (OEBPS/ch25.html) - 342',
            "The original Macintosh had a Motorola 68000 microprocessor, 64 KB of ROM, 128 KB of RAM, a 3\x{bd}-inch diskette drive (storing 400 KB per diskette), a keyboard, a mouse, and a video display capable of displaying 512 pixels horizontally by <<342|3:0>> pixels vertically. (The CRT itself measured only 9 inches diagonally.) That's a total of 175,104 pixels. Each pixel was associated with 1 bit of memory and could be colored either black or white, so about 22 KB were required for the video display RAM.",
          ],
          [
            1,
            '[00:00] Code - Charles Petzold.epub (OEBPS/ch25.html) - 000h',
            "An electrical current that represents sound isn't like the on-off digital signals that we've encountered throughout this book. Sound waves vary continuously, and so does the voltage of such a current. The electrical current is an analog of the sound waves. A device known as an analog-to-digital converter (ADC)\x{2014}generally implemented in a chip\x{2014}converts an analog voltage to a binary number. The output of an ADC is a certain number of digital signals\x{2014}usually 8, 12, or 16\x{2014}that together indicate the relative level of the voltage. A 12-bit ADC, for example, converts a voltage to a number between <<000h|1>> and FFFh and can differentiate 4096 different voltage levels.",
          ],
          [
            1,
            '[ap 03:00] Code - Charles Petzold.epub (OEBPS/ch25.html) - 300',
            'In early modems, a technique called frequency-shift keying (FSK) was used. A modem operating at <<300|3:0>> bits per second (for example) might convert a 0 bit to a frequency of 1070 Hz and a 1 bit to a frequency of 1270 Hz. Each byte is prefaced by a start bit and concluded with a stop bit, so each byte requires 10 bits. At <<300|9m:0>> bits per second, the transmission speed is only 30 bytes per second. More modern modems use more sophisticated techniques to achieve speeds over 100 times that.',
          ],
          [
            1,
            '[ap 06:52] Code - Charles Petzold.epub (OEBPS/co02.html) - 6.52',
            'The manuscript for this book was prepared using Microsoft Word 2000. Pages were composed using Adobe PageMaker <<6.52|5a:0>>, with text and display type in Sabon and math fonts in Syntax. Composed pages were delivered to the printer as electronic prepress files.',
          ],
        ];
