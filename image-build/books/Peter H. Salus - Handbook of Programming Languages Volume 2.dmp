$VAR1 = [
          [
            1,
            '[ap 09:00] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (013-016.html) - 0 to 9',
            'A Fortran statement is a sequence of characters. The characters of the Fortran character set consist of the uppercase letters A to Z, the lowercase letters a to z, the digits <<0 to 9|10a:0>>, the underscore (_), and the special characters in Table 1.1.',
          ],
          [
            1,
            '[ap 09:00] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (013-016.html) - 0 to 9',
            'The integer type is used to represent values that are whole numbers. An integer constant is a string containing only the digits <<0 to 9|10a:0>>, possibly followed by an underscore (_) and a named integer constant, which designates the kind parameter, as described in section 1.2.5. The following are examples of integer constants:',
          ],
          [
            1,
            '[19:59] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (024-027.html) - 1 to 20',
            'This type of loop control provides a simple means of assigning successive values to a variable each time an iteration of a loop is executed. A simple example that prints the squares and cubes of the integers <<1 to 20|10a:0>> follows:',
          ],
          [
            1,
            "[21:27] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (082-086.html) - 21\x{2013}27",
            "Anderson, B. 1980. Type syntax in the language C: An object lesson in syntactic innovation. SIGPLAN Notices 15(3):<<21\x{2013}27|5a:0>>.",
          ],
          [
            1,
            '[ap 09:59] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (087-089_split_001.html) - 1 to 10',
            'sets up a loop that steps the variable i through the values <<1 to 10|10a:0>> (inclusive). The body of the loop, enclosed in another pair of braces, consists of a declaration of a block-local variable f, a call to the function fib, and a call to printf. In this call to printf, the string to be printed includes the two-character sequence %d, which indicates that the value of another int argument passed to printf, in this case the variable f, should be inserted as a decimal integer (replacing the two characters %d in the output).',
          ],
          [
            1,
            '[ap 03:10] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (089-091.html) - 3.10',
            "We now proceed with detailed explanations of the four fundamental syntactic elements of C programs: declarations (including types and constants), expressions, statements, and functions. Section 3.6 discusses the special topic of pointers, and section 3.7 describes user-defined data structures. Section 3.8 covers the C preprocessor. Section 3.9 introduces the C runtime environment. Finally, section <<3.10|5a:0>> lists the functions in C\x{2019}s standard library.",
          ],
          [
            1,
            '[ap 01:44] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (091-094.html) - 0144',
            "Integer constants are indicated in the obvious way by simple digit sequences: 0, 1, 23, 456. Integer constants are in decimal (base 10) by default, but may be entered in octal (base 8) by prepending a leading 0 (digit zero), or in hexadecimal (base 16) by prepending a leading 0x or 0X. (The hexadecimal digits are 0\x{2013}9 and the letters a\x{2013}f or A\x{2013}F). Thus, 010 and 0377 are octal constants, and 0x10, 0x1abc, and 0XFEED are hexadecimal constants. The constants 100, <<0144|9l>>, and 0x64 all have the same value, one hundred decimal.",
          ],
          [
            1,
            '[ap 03:14] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (091-094.html) - 3.14',
            "A decimal-point character (.) indicates a floating-point constant, as in <<3.14|5a:0>>. The letter e or E may also be used to indicate exponential notation: 1.23e4 is <<1.23|5a:0>>\x{d7}10, or 12,300. A constant is floating point if it includes a decimal point (.) or e (or E) or both; digits may precede or follow the decimal point, or both. A sign (+ or -) may follow the letter e; 1.23e-4 is <<1.23|5a:0>>\x{d7}10, or 0.000123.",
          ],
          [
            1,
            '[ap 09:59] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (096-098.html) - a of 10',
            'declares an array <<a of 10|10>> ints. All arrays in C are 0-based, so the 10 elements of the array a are numbered from <<0 to 9|10a:0>>.',
          ],
          [
            1,
            '[ap 03:14] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (101-103.html) - 3.14',
            'Simple examples of these type qualifiers in use are
const float pi = <<3.14|5a:0>>;
and',
          ],
          [
            1,
            '[ap 01:00] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (113-115.html) - 1',
            "The bitwise operators are commonly used to encode a set of 1-bit flags within an integer. The expression flags = flags | 0x10 sets the fifth bit from the right in flags to 1 (whether it was 1 or not). The expression flags = flags & ~0x10 clears the fifth bit to 0. (The expression ~0x10 is preferable in this application to 0xffef or 0xffffffef because it is independent of the size of an int.) The expression flags & 0x10 tests the fifth bit, yielding a zero value if the fifth bit is 0 and a nonzero value if it is <<1|9c:0>>, and can therefore be used directly in conditionals, as in if(flags & 0x10) \x{2026}. It is also possible to construct bit masks \x{201c}on the fly\x{201d} by using the shift operators: the mask 0x10 could be computed from its (0-based) bit number using 0x01 << 4.",
          ],
          [
            1,
            '[23:59] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (113-115.html) - 1 to 0',
            "The exclusive-OR operator ^ has an \x{201c}information preserving\x{201d} property (roughly speaking, it changes as many 0\x{2019}s to 1\x{2019}s as it changes 1\x{2019}s to 0\x{2019}s), which makes it useful in several situations. Returning to the bit flags example, the expression flags = flags ^ 0x10 toggles the fifth bit from 0 to 1 or from <<1 to 0|10a:0>>. If val is a data value and key is an encryption key, the expression xval = val ^ key yields a scrambled value xval with the property that the original value can be recovered simply by computing xval ^ key. (This rudimentary example has almost no security, but it forms the basis of many useful encryption algorithms, especially those that are self inverse.) If val1, val2, and val3 are three values that are to be transmitted via an unreliable communications channel, the expression val4x = val1 ^ val2 ^ val3 computes a fourth value, which, if it is transmitted along with the first three, can be used to recover any of them. For example, if it is discovered that val2 was damaged in transit, the expression val1 ^ val3 ^ val4x recovers val2.",
          ],
          [
            1,
            '[ap 09:00] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (130-132.html) - 0 to 9',
            'initializes i to 0, loops as long as i is less than 10, and increments i by one after each trip through the loop. Ten values of i are therefore printed, from <<0 to 9|10a:0>>, inclusive.',
          ],
          [
            1,
            '[ap 03:10] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (145-147.html) - 3.10',
            "on the other hand, declares constptr as type \x{201c}const pointer to int.\x{201d} (These declarations have to be read \x{201c}inside out\x{201d} to make sense.) It is permissible to modify the int to which constptr points (that is, *constptr), and it is permissible to modify ptrtoconst to make it point to other const ints, but it is not permissible to modify constptr (the pointer itself) or *ptrtoconst (the pointed-to value). Pointers to constant values (e.g., const char *) are often used as function arguments, documenting (and in most cases ensuring) that the function does not use a particular pointer to modify any data in the caller. (See section <<3.10|5a:0>> for many examples.)",
          ],
          [
            1,
            '[ap 09:59] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (173-176.html) - 1 to 10',
            'The variable lp steps from node to node, starting at the base of the list and pointing to each node in turn until the null pointer marking the end of the list is found. In this for loop, therefore, the loop control variable is not even an integer (let alone one that steps from, say, <<1 to 10|10a:1>>). Yet this is a perfectly legal and common loop, illustrating the generality of the for loop while preserving the familiar initialize/test/increment pattern.',
          ],
          [
            1,
            '[ap 03:10] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (181-184.html) - 3.10',
            'A C program can return an exit status to the invoking environment. The exit status is simply an integer value, with 0 indicating successful termination and nonzero values representing other conditions. The exit status is either the return value from main or the value passed to the exit function. See section 3.10.4.5 for more information on exit and the two predefined exit status values EXIT_SUCCESS and EXIT_FAILURE.
<<3.10|9p>>. The Standard C Library
The Standard C runtime library is an occasionally eclectic mixture of extremely useful functions, along with a few unlikely historical warts. Most of these functions are valuable, and their use is recommended for productive and efficient programming. A few (such as strncpy) have foibles that must be understood for proper use, and one or two (such as gets) cannot be used safely, and are best avoided.',
          ],
          [
            1,
            '[ap 03:14] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (188-190.html) - 3.14',
            "printf(\x{201c}%d, %5d, %-5d, %05d, %5.5d\\n\x{201d}, 1, 2, 3, 4, 5);
printf(\x{201c}%o %x %X %#o %#x\\n\x{201d}, 171, 171, 171, 171, 171);
printf(\x{201c}%f %e %g\\n\x{201d}, <<3.14|9p>>, <<3.14|9p>>, <<3.14|5a:0>>);
printf(\x{201c}%s, %.5s!\\n\x{201d}, \x{201c}Hello\x{201d}, \x{201c}worldly\x{201d});
printf(\x{201c}%0*d, %.*f, %*.*s\\n\x{201d}, 2, 3, 4, 5.6, 7, 3, \x{201c}abcdef\x{201d});",
          ],
          [
            1,
            '[ap 02:53] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (188-190.html) - 0253',
            '1,     2, 3    , 00004, 00005
253 ab AB <<0253|18:0>> 0xab
3.140000 3.140000e+00 <<3.14|5a:0>>
Hello, world!
03, 5.6000,     abc',
          ],
          [
            1,
            '[ap 07:50] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (213-216.html) - 07:50',
            "These functions construct a human-readable string corresponding to a date and time. The string is of the form
Tue Oct 28 <<07:50|2>>:28 1997\\n\\0
(and is therefore equivalent to calling strftime with the format string \x{201c}%a %b %m %H:%M:%S %Y\\n\x{201d}). asctime builds the string from the information in the tm structure pointed to by tp. ctime builds the string from the time_t value pointed to by t; it is equivalent to asctime(localtime(t)). The return pointer is to a static string that is overwritten by each call.",
          ],
          [
            1,
            '[ap 02:10] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (216-218.html) - 2:10',
            'mktime attempts to compute the time_t value corresponding to the local date and time represented by the tm structure pointed to by tp. The date is determined by tm_mon and tm_mday; tm_wday and tm_yday are ignored on input. If tm_isdst is negative, mktime attempts to determine whether DST will or would have applied on the given date, and act accordingly; if tm_isdst is positive or zero, the caller is asserting that the given time does or does not have a DST offset applied, respectively. If any of tm_sec, tm_min, tm_hour, tm_mday, or tm_mon has a value outside the expected range, mktime normalizes them in the process of computing a date (and also adjusts their values in *tp). For example, 25:70 on January 32 is converted to <<2:10|2>> on February 2. Finally, appropriate values of tm_wday and tm_yday are set in *tp. The return value is the converted time_t value, or -1 if the conversion is impossible (e.g., the date represented by the tm structure is outside the range representable by a time_t).',
          ],
          [
            1,
            '[ap 03:11] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (232-234.html) - 3.11',
            "These functions permit new character conversions to be introduced without adding additional functions. wctrans accepts a string convname indicating a character conversion and returns a token that can be used for performing that conversion. (The token type, wctrans_t, is also defined in <wctype.h>.) towctrans accepts a wide character c and a token convtok previously returned by wctrans, and returns the appropriately converted wide character. wctrans accepts the strings \x{201c}toupper\x{201d} and \x{201c}tolower\x{201d} (corresponding to the two predefined classifications), plus any other conversion strings an implementation chooses to provide.
<<3.11|9p>>. Acknowledgments
Thanks to Clive Feather for his invaluable summary of NA1. Thanks to Mark Brader, Jutta Degener, Dennis Ritchie, Melanie Summit, and Rob Young for reading and commenting on drafts of this manuscript.",
          ],
          [
            1,
            '[ap 03:12] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (232-234.html) - 3.12',
            "Thanks to Clive Feather for his invaluable summary of NA1. Thanks to Mark Brader, Jutta Degener, Dennis Ritchie, Melanie Summit, and Rob Young for reading and commenting on drafts of this manuscript.
<<3.12|9p>>. Bibliography
American National Standards Institute. 1989. American national standard for information systems\x{2014}Programming language\x{2014}C, ANSI X3.159-1989.",
          ],
          [
            1,
            '[16:18] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (242-245.html) - 16.18',
            "\x{2022}\x{a0}\x{a0}The semantics of the IL should be cleanly defined and readily apparent. A good test of this criterion is the ease with which an interpreter can be written for the IL. A good example of such an IL is Pascal\x{2019}s Pcode, which we\x{2019}ll examine later in more detail. A worse example is GNU\x{2019}s RTL (Stallman, http://www.fsf.org):
\x{201c}People frequently have the idea of using RTL stored as text in a file as an interface between a language front end and the bulk of GNU CC. This idea is not feasible. GNU CC was designed to use RTL internally only. Correct RTL for a given program is very dependent on the particular target machine. And the RTL does not contain all the information about the program. (Section <<16.18|5a:0>>)\x{201d}
It turns out that GNU has another intermediate representation, but it is poorly documented (Stallman, http://www.fsf.org):
\x{201c}The proper way to interface GNU CC to a new language front end is with the \x{201c}tree\x{201d} data structure. There is no manual for this data structure, but it is described in the files \x{2019}tree.h\x{2019} and \x{2019}tree.def\x{2019}. (Section <<16.18|5a:0>>)\x{201d}
If GNU\x{2019}s ILs have these problems, why are the GNU compilers in such widespread use? They are popular because they are easily re-targeted even though they are not easily re-sourced. Admittedly, the act of re-targeting a compiler occurs more frequently than its re-sourcing.",
          ],
          [
            1,
            "[21:23] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (248-250.html) - 21\x{2013}23",
            "Chow, F. C., and M. Ganapathi. 1983. Intermediate languages in compiler construction\x{2014}A bibliography. Sigplan Notices 18(11):<<21\x{2013}23|5a:0>>.",
          ],
          [
            1,
            '[ap 07:01] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (256-258.html) - 7.01',
            "Unfortunately, though, there has been a lack of attention to the DOS versions of Borland\x{2019}s Pascal compilers from the Borland company itself. Version 7 of the DOS compiler, which was last updated in 1993 (<<7.01|5a:0>>), has continued to be largely usable for creating 16-bit DOS applications, though Borland has ceased to support it (yet continues to sell it). This, along with the advent of newer platforms, has resulted in a renaissance of Pascal compiler creation. As a result, compilers exist today for almost all platforms, from the Macintosh to OS/2 and even UNIX.",
          ],
          [
            1,
            '[ap 03:23] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (259-261.html) - 3.23',
            'This section describes standard addition, subtraction, multiplication, division, and concatenation. For purposes of this section, variables declared as real are decimal numbers, such as <<3.23|5a:0>>, and variables declared as integer are whole numbers, such as 5. Order of operations rules and use of parentheses in Turbo Pascal are consistent with the rules of mathematics. These rules usually are consistent with all programming languages. In Listing 5.4, observe means of doing these arithmetic functions.',
          ],
          [
            1,
            '[ap 10:00] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (262-264.html) - 10',
            'In addition, an if statement might be extended to execute another statement if the condition is not met. This is referred to as an extension to the if statement, called an else statement. That extension is demonstrated along with the method used for placing multiple statements in any control structure (a begin-end; pair) in Turbo Pascal in Listing 5.6. It represents a rewrite of Listing 5.5 that adds a statement which appears if the number entered is less than 10, and adds statements on each part that tell how much greater or less the number entered was from <<10|9c:0>>:',
          ],
          [
            1,
            '[ap 09:59] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (262-264.html) - 1 to 10',
            "for i := <<1 to 10|10a:0>> do
for c := \x{2018}a\x{2019} to \x{2018}z\x{2019} do
for i := 10 downto 1 do
for c := \x{2018}z\x{2019} downto \x{2018}a\x{2019} do",
          ],
          [
            1,
            '[ap 10:00] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (262-264.html) - 10',
            "program fig8;
 var
   i: integer;
   c: char;
 begin
   write(\x{2018}I can count down from <<10|9c:0>>: \x{2019});
   for i := 10 downto 1 do
     write(i, \x{2018} \x{2019});
   writeln;
   writeln(\x{2018}Now here\x{201c}s the ABC\x{201d}s\x{2019});
   for c := \x{2018}A\x{2019} to \x{2018}Z\x{2019} do
     write(c, \x{2018} \x{2019});
   writeln;
 end.",
          ],
          [
            1,
            '[ap 10:00] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (264-267.html) - 10',
            "program fig9;
 var
   i: integer;
 begin
   write(\x{2018}I can count down from <<10|9c:0>>: \x{2019});
   i := 10;
   while i > 0 do
     begin
       write(i, \x{2018} \x{2019});
       i := i - 1;
     end;
   writeln;
 end.",
          ],
          [
            1,
            '[ap 05:10] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (264-267.html) - 5.10',
            'Listing <<5.10|5a:0>> shows a program that performs the same actions as Listing 5.9, using a repeat loop. Note the difference in the control statement as well as the location of the control statement. As Wirth intended Pascal to be a teaching language with logic behind how the control structures are expressed, the way the constructs are written indicates the actions that happen. Because a repeat loop checks the condition after the statements are executed, the condition appears afterwards, whereas a while loop shows the control statement beforehand.',
          ],
          [
            1,
            '[ap 05:10] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (264-267.html) - 5.10',
            "Listing <<5.10|5a:0>> shows a program that performs the same actions as Listing 5.9, using a repeat loop. Note the difference in the control statement as well as the location of the control statement. As Wirth intended Pascal to be a teaching language with logic behind how the control structures are expressed, the way the constructs are written indicates the actions that happen. Because a repeat loop checks the condition after the statements are executed, the condition appears afterwards, whereas a while loop shows the control statement beforehand.
Listing <<5.10|5a:0>>. A demonstration of a repeat loop.
program fig10;
 var
   i: integer;
begin
 write(\x{2018}I can count down from <<10|9c:0>>: \x{2019});
 i := 10;
 repeat
   write(i, \x{2018} \x{2019});
   i := i - 1;
 until i < 1;
 writeln;
end.",
          ],
          [
            1,
            '[ap 10:00] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (264-267.html) - 10',
            "program fig10;
 var
   i: integer;
begin
 write(\x{2018}I can count down from <<10|9c:0>>: \x{2019});
 i := 10;
 repeat
   write(i, \x{2018} \x{2019});
   i := i - 1;
 until i < 1;
 writeln;
end.",
          ],
          [
            1,
            '[ap 05:11] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (264-267.html) - 5.11',
            'In the order of operations, these operators are placed above all arithmetic operations and comparison operations. If a true comparison between two conditional statements is desired, parentheses must be used, as the AND or OR will be evaluated between the items nearest the word as boolean types and not the results of the two conditions as might be desired. In Listing <<5.11|5a:0>>, multiple conditions are demonstrated in the rewrite of Listing 5.7, which was the case statement grades example, to use if statements. Here, you begin to see the easily sprawling code that if statements can begin to generate.',
          ],
          [
            1,
            '[ap 05:11] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (264-267.html) - 5.11',
            'Listing <<5.11|5a:0>>. A demonstration of control statements including boolean logic.',
          ],
          [
            1,
            '[ap ~ 09:50] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (267-269.html) - about 10 to 10',
            "\x{2022}\x{a0}\x{a0}real\x{2014}scientific number, 11 digits precision, storage from <<about 10 to 10|10>>, 6 bytes storage",
          ],
          [
            1,
            '[ap 05:12] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (267-269.html) - 5.12',
            "A byte of data, translated to a character in the ASCII chart is referred to as a data type char. A character can be assigned to a char variable, such as \x{2018}A\x{2019} or an equivalent ASCII number in decimal as #65 or hexadecimal such as \$41. In Listing <<5.12|5a:0>>, note that even though byte and char are entirely equivalent in storage (1 byte, same value in memory), the compiler interprets these types differently. To check this fact, information is shown later (Listing <<5.24|5a:0>>) to enable you to test the statement made.",
          ],
          [
            1,
            '[ap 05:12] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (267-269.html) - 5.12',
            "A byte of data, translated to a character in the ASCII chart is referred to as a data type char. A character can be assigned to a char variable, such as \x{2018}A\x{2019} or an equivalent ASCII number in decimal as #65 or hexadecimal such as \$41. In Listing <<5.12|5a:0>>, note that even though byte and char are entirely equivalent in storage (1 byte, same value in memory), the compiler interprets these types differently. To check this fact, information is shown later (Listing <<5.24|5a:0>>) to enable you to test the statement made.
Listing <<5.12|5a:0>>. An illustration of byte versus char.
program fig12;
 var
   character: char;
   byteinfo: byte;
 begin
   character := #65; { or character := \x{2018}A\x{2019} would be equivalent }
   byteinfo := 65;
   writeln(character);
   writeln(byteinfo);
 end.",
          ],
          [
            1,
            '[ap 05:13] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (269-272.html) - 5.13',
            'To define what the array syntax means with the first example above, buffer is an array of 1,024 bytes, each byte referred to in a range of 1 to 1024. The first byte is referred to as buffer[1], and the 100th byte is referred to as buffer[100]. An example of declaring and accessing an array in a proper manner is shown in Listing <<5.13|5a:0>>.',
          ],
          [
            1,
            '[ap 05:13] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (269-272.html) - 5.13',
            "To define what the array syntax means with the first example above, buffer is an array of 1,024 bytes, each byte referred to in a range of 1 to 1024. The first byte is referred to as buffer[1], and the 100th byte is referred to as buffer[100]. An example of declaring and accessing an array in a proper manner is shown in Listing <<5.13|5a:0>>.
Listing <<5.13|5a:0>>. An example of using a single-level table or array.
program fig13;
{ Single dimensional array demo:
  fills an array using a mathematical formula, then takes the
  average of all numbers in the array. Shows the proper way to
  access an array in Pascal, as well as process an array, and
  perform record-keeping in an array system with Pascal. }
var
 info: array[1..15] of integer;
 i, total_used: byte;
 addtemp: longint;
begin
 i := 1;
 total_used := 0;
 { use while or repeat when indefinite number of items placed in
   array }
 while (total_used * 3) < 12 do
   begin
     info[i] := total_used * 5 + 12;
     total_used := total_used + 1;
     i := i + 1;
   end;
 addtemp := 0;
 { may use for loop as well as while/repeat here. When not entirely
   filling an array, be sure to keep # of items currently used
   recorded somewhere }
 for i := 1 to total_used do
   begin
     write(info[i], \x{2018}, \x{2019});
     addtemp := addtemp + info[i];
   end;
 writeln(total_used, \x{2018} numbers.\x{2019});
 writeln(\x{2018}are averaged to \x{2019}, addtemp/total_used:0:3);
end.",
          ],
          [
            1,
            '[ap 05:13] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (269-272.html) - 5.13',
            "The next question you may ask is whether an array may be of an array. The answer here is \x{201c}yes.\x{201d} In referring to Listing <<5.13|5a:0>>, Info is an array[1..15] of integer. This array could easily be array[1..4] of array[1..15] of integer, meaning an array of four arrays of array[1\x{2026}15] of integer, all indexed by the range 1..4. The first declaration here can be expressed in shorthand to be the second, though both declarations are correct. The shorthand form is considered acceptable:",
          ],
          [
            1,
            '[ap 05:14] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (269-272.html) - 5.14',
            'An example of use of an array of beyond one level in a program is shown in Listing <<5.14|5a:0>>. If you keep in mind that memory storage is linear, programming for any level of array should not be difficult.',
          ],
          [
            1,
            '[ap 05:14] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (269-272.html) - 5.14',
            "An example of use of an array of beyond one level in a program is shown in Listing <<5.14|5a:0>>. If you keep in mind that memory storage is linear, programming for any level of array should not be difficult.
Listing <<5.14|5a:0>>. A demonstration of a double-level array or table.
program fig14;
 { two-level array demonstration determinant of a 3X3 matrix.
   The general formula is for a matrix of:
   [ A B C ]
   [ D E F ] is AEI + BFG + CDH - CEG - BDI - AFH = determinant
   [ G H I ]
 }
 var
   matrix: array[1..3,1..3] of integer;
   x, y, postx, posty1, posty2: byte;
   subadd1, subadd2, determinant: longint;
begin
   { load a sample matrix value }
   matrix[1,1] := 3;
   matrix[1,2] := 4;
   matrix[1,3] := 2;
   matrix[2,1] := 8;
   matrix[2,2] := 7;
   matrix[2,3] := 3;
   matrix[3,1] := 1;
   matrix[3,2] := 0;
   matrix[3,3] := 4;
    { perform matrix calculation\x{2014}note that y is not directly
     accessed within this for loop }
   for y := <<1 to 3|10a:0>> do
     begin
       posty1 := y;
       posty2 := y;
subadd1 := 1;
       subadd2 := 1;
       for postx := <<1 to 3|10a:0>> do
         begin
           if posty1 = 3 then
             posty1 := 1
           else
             posty1 := posty1 + 1;
           if posty2 = 1 then
              posty2 := 3
           else
              posty2 := posty2 - 1;
           subadd1 := subadd1 * matrix[postx, posty1];
           subadd2 := subadd2 * matrix[postx, posty2];
         end;
       determinant := determinant + subadd1 - subadd2;
     end;
   writeln(\x{2018}The determinant is: \x{2019}, determinant, \x{2018}.\x{2019});
 end.",
          ],
          [
            1,
            '[ap 02:59] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (269-272.html) - 1 to 3',
            "program fig14;
 { two-level array demonstration determinant of a 3X3 matrix.
   The general formula is for a matrix of:
   [ A B C ]
   [ D E F ] is AEI + BFG + CDH - CEG - BDI - AFH = determinant
   [ G H I ]
 }
 var
   matrix: array[1..3,1..3] of integer;
   x, y, postx, posty1, posty2: byte;
   subadd1, subadd2, determinant: longint;
begin
   { load a sample matrix value }
   matrix[1,1] := 3;
   matrix[1,2] := 4;
   matrix[1,3] := 2;
   matrix[2,1] := 8;
   matrix[2,2] := 7;
   matrix[2,3] := 3;
   matrix[3,1] := 1;
   matrix[3,2] := 0;
   matrix[3,3] := 4;
    { perform matrix calculation\x{2014}note that y is not directly
     accessed within this for loop }
   for y := <<1 to 3|10a:0>> do
     begin
       posty1 := y;
       posty2 := y;
subadd1 := 1;
       subadd2 := 1;
       for postx := <<1 to 3|10a:0>> do
         begin
           if posty1 = 3 then
             posty1 := 1
           else
             posty1 := posty1 + 1;
           if posty2 = 1 then
              posty2 := 3
           else
              posty2 := posty2 - 1;
           subadd1 := subadd1 * matrix[postx, posty1];
           subadd2 := subadd2 * matrix[postx, posty2];
         end;
       determinant := determinant + subadd1 - subadd2;
     end;
   writeln(\x{2018}The determinant is: \x{2019}, determinant, \x{2018}.\x{2019});
 end.",
          ],
          [
            1,
            '[ap 05:14] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (272-275.html) - 5.14',
            "For example, in Listing <<5.14|5a:0>>, a constant variable could be placed at the top with a variable identity and have it used to change the 3s in the control statements of the program to that constant variable, as well as the 3s in the array (a constant variable may be used for arrays because the value is specified at compile time). This would result in a very easy modification to change the 3 \x{d7} 3 nature of the matrix evaluation to an N \x{d7} N evaluation of any reasonable value for N.",
          ],
          [
            1,
            '[ap 05:15] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (272-275.html) - 5.15',
            'Data type definitions are used to help in modularity in certain ways, and are necessary to help define other data types that are described later. They are contained under a header denoted as type. When a type definition is made, generally variables that use this type definition exist in the var section or elsewhere. In essence, you are defining a new valid data type. Demonstrations of both constant variables and type data declarations are shown in Listing <<5.15|5a:0>>.',
          ],
          [
            1,
            '[ap 05:15] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (272-275.html) - 5.15',
            'Listing <<5.15|5a:0>>. A demonstration of constants and data type declarations.',
          ],
          [
            1,
            '[ap 05:16] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (272-275.html) - 5.16',
            'There are two possible ways to access such a record structure when defined as a variable in a program. One is to specify the name of the variable, followed by a dot, and then the subidentifier as defined in the type declaration. The other is to encompass the code dealing with the particular record type in a with-do construct. There is no technical difference in either method other than the reduced typing the second method can produce. A diagram of memory storage of this construct is shown in Figure 5.3, and a demonstration of defining and using records is shown in Listing <<5.16|5a:0>>.',
          ],
          [
            1,
            '[ap 05:16] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (275-278.html) - 5.16',
            "
Listing <<5.16|5a:0>>. A demonstration of the definition and use of records.
program fig16;
 type
   phonerecord = record
     firstname: string[15];
     lastname: string[10];
     midinit: char;
     areacode, exchange, number: integer;
     city: string[20];
   end;
 var
   phoneitem: phonerecord;
 begin
   { first method used to fill record variable }
   phoneitem.firstname := \x{2018}Joe\x{2019};
   phoneitem.lastname := \x{2018}Dialer\x{2019};
   phoneitem.midinit := \x{2018}K\x{2019};
   phoneitem.areacode := 513;
   phoneitem.exchange := 232;
   phoneitem.number := 2323;
   phoneitem.city := \x{2018}Jonestown\x{2019};
   { second method used to write record variables }
   with phoneitem do
     begin
       writeln(\x{2018}Firstname: \x{2019}, firstname);
       writeln(\x{2018}Lastname: \x{2019}, lastname);
       writeln(\x{2018}Middle Initial: \x{2019}, midinit);
       writeln(\x{2018}Phone Number: \x{2019}, areacode, \x{2018}-\x{2019}, exchange, \x{2018}-\x{2019},
                number);
       writeln(\x{2018}City: \x{2019}, city);
    end;
end.",
          ],
          [
            1,
            '[ap 05:17] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (275-278.html) - 5.17',
            "An enumerated type is a definition that can bring a degree of clarity to programs, if possible. These types can be specified in word terms, like a constant array definition, or set terms without the brackets. They are defined in the data type definition section, as records are, or in some cases can be placed in the var section. When an enumerated type is encountered, only values specified by the type can be placed into the variable. When stored in memory, an enumerated type\x{2019}s label is assigned an ordinal number starting from 0 on the left-hand side. To help you fully understand, Listing <<5.17|5a:0>> presents a short demonstration of the use of an enumerated type.",
          ],
          [
            1,
            '[ap 05:17] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (275-278.html) - 5.17',
            "An enumerated type is a definition that can bring a degree of clarity to programs, if possible. These types can be specified in word terms, like a constant array definition, or set terms without the brackets. They are defined in the data type definition section, as records are, or in some cases can be placed in the var section. When an enumerated type is encountered, only values specified by the type can be placed into the variable. When stored in memory, an enumerated type\x{2019}s label is assigned an ordinal number starting from 0 on the left-hand side. To help you fully understand, Listing <<5.17|5a:0>> presents a short demonstration of the use of an enumerated type.
Listing <<5.17|5a:0>>. A demonstration of the use of an enumerated type.
program fig17;
 type
   dirtype = (North, South, East, West);
 var
   i: dirtype;
   c: 1..5;
   { another enumerated type: May contain only 1, 2,3,4, or 5 }
 begin
{ actually in memory for i := <<0 to 3|10a:0>> do, but this situation can
 tend to have more clarity as words than ordinal digits }
   for i := North to West do
     writeln(\x{2018}Hello\x{2019});
 end.",
          ],
          [
            1,
            '[ap 03:00] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (275-278.html) - 0 to 3',
            "program fig17;
 type
   dirtype = (North, South, East, West);
 var
   i: dirtype;
   c: 1..5;
   { another enumerated type: May contain only 1, 2,3,4, or 5 }
 begin
{ actually in memory for i := <<0 to 3|10a:0>> do, but this situation can
 tend to have more clarity as words than ordinal digits }
   for i := North to West do
     writeln(\x{2018}Hello\x{2019});
 end.",
          ],
          [
            1,
            '[ap 05:18] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (275-278.html) - 5.18',
            'Examples of written procedures and procedure use are shown in Listing <<5.18|5a:0>>. Note that variable names used as local variables or procedure parameters may be the same as global variables or different. Variables at the same level must be identified uniquely, but variables at different levels may be identified using the same identifiers. The benefit of the organization of code may be seen in this listing. Also, as a function of modularity, determinants for more than one matrix could be found using the procedure, and not by recoding the determinant code.',
          ],
          [
            1,
            '[ap 05:18] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (278-281.html) - 5.18',
            "
Listing <<5.18|5a:0>>. A demonstration of writing and using procedures.
program fig18;
 { two-level array demonstration rewritten as a procedures
   demonstration determinant of a 3X3 matrix. The general
   formula is for a matrix of:
   [ A B C ]
   [ D E F ] is AEI + BFG + CDH - CEG - BDI - AFH = determinant
   [ G H I ]
 }
 type
   matrixtype = array[1..3,1..3] of integer;
 var
   matrix: matrixtype;
   result: longint;
 procedure loadmatrix(var thematrix: matrixtype);
   { var must be in front of declaration above so matrix
     declarations can survive end of procedure }
   begin
     thematrix[1,1] := 3;
     thematrix[1,2] := 4;
     thematrix[1,3] := 2;
     thematrix[2,1] := 8;
     thematrix[2,2] := 7;
     thematrix[2,3] := 3;
     thematrix[3,1] := 1;
     thematrix[3,2] := 0;
     thematrix[3,3] := 4;
   end;
 procedure determinant(thematrix: matrixtype;
                         var theresult: longint);
 { local variables defined: scope is only within procedure
   determinant }
   var
     x, y, postx, posty1, posty2: byte;
     subadd1, subadd2: longint;
   begin
     for y := <<1 to 3|10a:0>> do
       begin
         posty1 := y;
         posty2 := y;
         subadd1 := 1;
         subadd2 := 1;
         for postx := <<1 to 3|10a:0>> do
           begin
             if posty1 = 3 then
               posty1 := 1
             else
               posty1 := posty1 + 1;
             if posty2 = 1 then
                posty2 := 3
            else
                posty2 := posty2 - 1;
             subadd1 := subadd1 * thematrix[postx, posty1];
             subadd2 := subadd2 * thematrix[postx, posty2];
           end;
         theresult := theresult + subadd1 - subadd2;
       end;
  end;
begin
  loadmatrix(matrix);
  determinant(matrix, result);
  writeln(\x{2018}The determinant is: \x{2019}, result,    \x{2018}.\x{2019});
           end.",
          ],
          [
            1,
            '[ap 02:59] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (278-281.html) - 1 to 3',
            "program fig18;
 { two-level array demonstration rewritten as a procedures
   demonstration determinant of a 3X3 matrix. The general
   formula is for a matrix of:
   [ A B C ]
   [ D E F ] is AEI + BFG + CDH - CEG - BDI - AFH = determinant
   [ G H I ]
 }
 type
   matrixtype = array[1..3,1..3] of integer;
 var
   matrix: matrixtype;
   result: longint;
 procedure loadmatrix(var thematrix: matrixtype);
   { var must be in front of declaration above so matrix
     declarations can survive end of procedure }
   begin
     thematrix[1,1] := 3;
     thematrix[1,2] := 4;
     thematrix[1,3] := 2;
     thematrix[2,1] := 8;
     thematrix[2,2] := 7;
     thematrix[2,3] := 3;
     thematrix[3,1] := 1;
     thematrix[3,2] := 0;
     thematrix[3,3] := 4;
   end;
 procedure determinant(thematrix: matrixtype;
                         var theresult: longint);
 { local variables defined: scope is only within procedure
   determinant }
   var
     x, y, postx, posty1, posty2: byte;
     subadd1, subadd2: longint;
   begin
     for y := <<1 to 3|10a:0>> do
       begin
         posty1 := y;
         posty2 := y;
         subadd1 := 1;
         subadd2 := 1;
         for postx := <<1 to 3|10a:0>> do
           begin
             if posty1 = 3 then
               posty1 := 1
             else
               posty1 := posty1 + 1;
             if posty2 = 1 then
                posty2 := 3
            else
                posty2 := posty2 - 1;
             subadd1 := subadd1 * thematrix[postx, posty1];
             subadd2 := subadd2 * thematrix[postx, posty2];
           end;
         theresult := theresult + subadd1 - subadd2;
       end;
  end;
begin
  loadmatrix(matrix);
  determinant(matrix, result);
  writeln(\x{2018}The determinant is: \x{2019}, result,    \x{2018}.\x{2019});
           end.",
          ],
          [
            1,
            '[ap 05:19] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (278-281.html) - 5.19',
            'Functions, when defined, start with the reserved word function and then a parameter list, as with procedures. The final part is a : followed by a data type that the function will return when enacted. An example of a function is shown in Listing <<5.19|5a:0>>. Functions may be used exactly in place of where a value might be, as that data type, and in that sense they function as variables of the data type they return, though some input values and code exist to evaluate or return the value.',
          ],
          [
            1,
            '[ap 05:19] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (278-281.html) - 5.19',
            "Functions can have great value in simplifying and streamlining the coding process. Though it is hard to describe when to use functions over procedures, when you gain some slight experience in coding, the situations to use functions will become evident.
Listing <<5.19|5a:0>>. A demonstration of function use.
program fig19;
 var
   i: byte;
 function power(x: real; y: integer): real;
   { function: returns result of x^y where x and y are integers }
   var
     i: integer;
     result: real;
   begin
     result := 1;
     for i := 1 to y do
       result := result * x;
     power := result;
   end;
begin
  for i := <<1 to 10|10a:0>> do
    writeln(i, \x{2018} squared is \x{2019}, power(i,2):0:2);
    { function call is treated exactly like a real number }
end.",
          ],
          [
            1,
            '[ap 09:59] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (278-281.html) - 1 to 10',
            "program fig19;
 var
   i: byte;
 function power(x: real; y: integer): real;
   { function: returns result of x^y where x and y are integers }
   var
     i: integer;
     result: real;
   begin
     result := 1;
     for i := 1 to y do
       result := result * x;
     power := result;
   end;
begin
  for i := <<1 to 10|10a:0>> do
    writeln(i, \x{2018} squared is \x{2019}, power(i,2):0:2);
    { function call is treated exactly like a real number }
end.",
          ],
          [
            1,
            '[ap 05:20] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (278-281.html) - 5.20',
            'Listing <<5.20|5a:0>> demonstrates a function written to operate recursively. A description of the execution path of the function, which is an integer power function just like the one in Listing <<5.19|5a:0>>, appears after the listing.',
          ],
          [
            1,
            '[ap 05:20] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (282-285.html) - 5.20',
            "
Listing <<5.20|5a:0>>. A demonstration of recursion and forwards.
program fig20;
 var
   i: byte;
   result: real;
 function power(x: real; y: integer): real;
   { function: returns result of x^y where x and y are integers }
   { written recursively }
   begin
     if y >= 1 then
       power := x * power(x,y-1)
     else
       power := 1;
   end;
 begin
   for i := <<1 to 10|10a:0>> do
     begin
       result := power(i,2);
       writeln(i, \x{2018} squared is \x{2019}, result:0:2);
     end;
 end.",
          ],
          [
            1,
            '[ap 09:59] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (282-285.html) - 1 to 10',
            "program fig20;
 var
   i: byte;
   result: real;
 function power(x: real; y: integer): real;
   { function: returns result of x^y where x and y are integers }
   { written recursively }
   begin
     if y >= 1 then
       power := x * power(x,y-1)
     else
       power := 1;
   end;
 begin
   for i := <<1 to 10|10a:0>> do
     begin
       result := power(i,2);
       writeln(i, \x{2018} squared is \x{2019}, result:0:2);
     end;
 end.",
          ],
          [
            1,
            '[ap 05:20] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (282-285.html) - 5.20',
            'A recursive function, such as the one in Listing <<5.20|5a:0>>, always has a condition to stop recursion and return some alternate value. In this case, when y becomes 0 when it is called in the function, the value 1 is returned, in signification that when x is anything and y is 0 in a power function, the result is always 1. Figure 5.5 illustrates the variable values and actions when power() is called.',
          ],
          [
            1,
            '[ap 05:21] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (282-285.html) - 5.21',
            'In Listing <<5.21|5a:0>>, note the format of a unit. Units include procedures and functions, which are generally related, in the entire listing. The interface section lists the headers of the procedures and functions, as well as any data type definitions, constant definitions, and initialization code that may be required to call any of the code that is in the unit. Note that data types cannot be duplicated.',
          ],
          [
            1,
            '[ap 05:21] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (282-285.html) - 5.21',
            'Any type functions that are needed for unit-related functions and procedures must be declared in that unit and that unit only. The implementation section lists all the headers of the procedures and functions again, as well as the code associated with each of the headers. In implementation of a unit, all items in the interface section are made aware of the program, including type and constant declarations. Because Pascal is a strongly typed language, if a type is referred to in two locations with the same name and same description, they are still different.
Listing <<5.21|5a:0>>. An example of a unit file.
unit fig21;
{ note, the identifier here must match the name of the file }
 interface
   function power(x:real; y: integer):real;
 implementation
   function power(x:real; y: integer):real;
   { must be exactly as above }
     var
       i: integer;
       result: real;
     begin
       result := 1;
       for i := 1 to y do
         result := result * x;
       power := result;
     end;
end.',
          ],
          [
            1,
            '[ap 05:22] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (282-285.html) - 5.22',
            "For you to use this unit, or any other unit, it must be specified after the program clause of the code in a uses clause, followed by the exact name of the identifier used in the unit clause of the unit\x{2019}s code. In Listing <<5.22|5a:0>>, note how the unit just created is registered and used in the resulting program. The compiled unit, as specified in Listing <<5.21|5a:0>>, should be made available to this program when created.",
          ],
          [
            1,
            '[ap 05:22] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (282-285.html) - 5.22',
            "For you to use this unit, or any other unit, it must be specified after the program clause of the code in a uses clause, followed by the exact name of the identifier used in the unit clause of the unit\x{2019}s code. In Listing <<5.22|5a:0>>, note how the unit just created is registered and used in the resulting program. The compiled unit, as specified in Listing <<5.21|5a:0>>, should be made available to this program when created.
Listing <<5.22|5a:0>>. The use of a unit file in a program.
program fig22; uses fig21;
{if more than 1 unit put commas between each id}
 var
   i: byte;
 begin
   for i := <<1 to 10|10a:0>> do
     writeln(i, \x{2018} squared is \x{2019}, power(i,2):0:2);
 end.",
          ],
          [
            1,
            '[ap 09:59] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (282-285.html) - 1 to 10',
            "program fig22; uses fig21;
{if more than 1 unit put commas between each id}
 var
   i: byte;
 begin
   for i := <<1 to 10|10a:0>> do
     writeln(i, \x{2018} squared is \x{2019}, power(i,2):0:2);
 end.",
          ],
          [
            1,
            '[ap 05:19] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (282-285.html) - 5.19',
            'Here, the program executes in the same manner as Listings <<5.19|5a:0>> and <<5.20|5a:0>>. The advantage here is that, if the unit fig21 is available, the power function does not have to be retyped and retested, just the uses clause must be typed. This kind of modularity and ability to organize code can be very useful. Also, in very large programs, units must be used, as the executable created must have a number of code segments that are a maximum of 64 KB each.',
          ],
          [
            1,
            '[ap 05:23] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (285-287.html) - 5.23',
            'Typecasting is exactly what it implies: the interpretation of one type into another type. Generally, it is done with the typical variable types that are defined, with the type name used as a function. It is done in a function style, where the interpretation of the variable is changed, and not its format in memory. An example of typecasting (and one case in which it might be used) is shown in Listing <<5.23|5a:0>>.',
          ],
          [
            1,
            '[ap 05:23] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (285-287.html) - 5.23',
            "Typecasting is exactly what it implies: the interpretation of one type into another type. Generally, it is done with the typical variable types that are defined, with the type name used as a function. It is done in a function style, where the interpretation of the variable is changed, and not its format in memory. An example of typecasting (and one case in which it might be used) is shown in Listing <<5.23|5a:0>>.
Listing <<5.23|5a:0>>. A demonstration of typecasting.
program fig23;
 { demonstrates type casting and what can be done }
 var
   a: char;
   b: byte;
 begin
   a := \x{2018}C\x{2019};
   b := 45;
   writeln(\x{2018}a is: \x{2019}, a);
   writeln(\x{2018}b is: \x{2019}, b);
   writeln(\x{2018}b char: \x{2019}, char(b));
   writeln(\x{2018}a byte: \x{2019}, byte(a));
   writeln(\x{2018}a byte + b: \x{2019}, byte(a) + b);
   writeln(\x{2018}a + b char: \x{2019}, a + char(b));
 end.",
          ],
          [
            1,
            '[ap 05:24] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (285-287.html) - 5.24',
            "For example, ord(\x{2018}A\x{2019}) returns 65, and chr(65) returns \x{2018}A\x{2019}. An example of use is shown in Listing <<5.24|5a:0>>.",
          ],
          [
            1,
            '[ap 05:24] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (285-287.html) - 5.24',
            "For example, ord(\x{2018}A\x{2019}) returns 65, and chr(65) returns \x{2018}A\x{2019}. An example of use is shown in Listing <<5.24|5a:0>>.
Listing <<5.24|5a:0>>. An example of the use of ord() and chr().
program fig24;
 { a demonstration of ord() and chr() to prove that \x{2018}A\x{2019} is a byte by
 the value of 65 }
 begin
   if ord(\x{2018}A\x{2019}) = 65 then
     writeln(\x{2018}A character \x{201d}A\x{201d} is stored as a byte = 65 according \x{2019},
             \x{2018}to ord\x{2019});
   if chr(65) = \x{2018}A\x{2019} then
     writeln(\x{2018}A byte = 65 is stored as a character \x{2019}\x{2018}A\x{2019} \x{2018} according \x{2019},
             \x{2018}to chr\x{2019});
 end.",
          ],
          [
            1,
            '[ap 05:25] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (285-287.html) - 5.25',
            'val() takes a string, which should have only numeric characters, as well as periods, and a numeric variable, as well as an integer-related error variable. It places the numeric equivalent of s into the variable x. errorcode is not 0, denoting the position of error if it is non-numeric, if the string s was not convertible. This variable must be checked after each and every call of val.
Demonstrations of these procedures are shown in Listing <<5.25|5a:0>>.
Listing <<5.25|5a:0>>. A demonstration of val and str.',
          ],
          [
            1,
            '[ap 05:25] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (285-287.html) - 5.25',
            "Demonstrations of these procedures are shown in Listing <<5.25|5a:0>>.
Listing <<5.25|5a:0>>. A demonstration of val and str.
program fig25;
 { demonstrates and writes results of the use of val and str }
 var
   entry: string;
   number: real;
   error: integer;
 begin
   write(\x{2018}Enter something: \x{2019});
   readln(entry);
   val(entry, number, error);
   if error <> 0 then { show error at position }
     writeln(\x{2018}Non-numeric character found at position \x{2019}, error)
   else
     writeln(number);
   number := 5.23342;
   str(number:0:2, entry); { format string may be used here}
   writeln(entry);
 end.",
          ],
          [
            1,
            '[ap 05:26] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (287-290.html) - 5.26',
            'upcase() returns the uppercased version of a letter in the alphabet, if x is a letter of the alphabet. Otherwise, it returns the exact character passed to it. length() returns the literal equivalent of ord(s[0]) in a string s, or the current real length of the string stored. length() may be preferable over ord(s[0]) in some situations, but either is usually good. An example of using both of these functions is shown in Listing <<5.26|5a:0>>.',
          ],
          [
            1,
            '[ap 05:26] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (287-290.html) - 5.26',
            "upcase() returns the uppercased version of a letter in the alphabet, if x is a letter of the alphabet. Otherwise, it returns the exact character passed to it. length() returns the literal equivalent of ord(s[0]) in a string s, or the current real length of the string stored. length() may be preferable over ord(s[0]) in some situations, but either is usually good. An example of using both of these functions is shown in Listing <<5.26|5a:0>>.
Listing <<5.26|5a:0>>. A demonstration of upcase() and length().
program fig26;
 function upstr(s: string): string;
   var
     i: byte;
     outstr: string;
   begin
     for i := 1 to length(s) do
       upstr[i] := upcase(s[i]);
     upstr[0] := s[0];
   end;
 begin
   writeln(upstr(\x{2018}San Francisco\x{2019}));
 end.",
          ],
          [
            1,
            '[ap 05:27] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (287-290.html) - 5.27',
            'pos() returns the starting position of a string s, in the full string t, if it exists. Otherwise, it returns 0. copy() returns the partial substring described by the starting position and length byte specified in an entire string. Listing <<5.27|5a:0>> demonstrates both functions, in a situation in which these functions are most often used, text parsing and processing.',
          ],
          [
            1,
            '[ap 05:27] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (287-290.html) - 5.27',
            "pos() returns the starting position of a string s, in the full string t, if it exists. Otherwise, it returns 0. copy() returns the partial substring described by the starting position and length byte specified in an entire string. Listing <<5.27|5a:0>> demonstrates both functions, in a situation in which these functions are most often used, text parsing and processing.
Listing <<5.27|5a:0>>. A demonstration of copy() and pos().
program fig27;
 { demo of copy and pos }
 const
   s: string = \x{2018}The brown dog jumped over the lazy cow.\x{2019};
 var
   result: byte;
   subst: string;
 begin
   result := 11;
   subst := s;
   while result <> 0 do { while there still are spaces }
      begin
        result := pos(\x{2018} \x{2019}, subst);
        if result > 0 then
          writeln(copy(subst, 1, result));
        subst := copy(subst, result+1, length(subst) - result);
      end;
    writeln(subst);
{ this means the last word has occurred, write it }
  end.",
          ],
          [
            1,
            '[ap 05:28] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (287-290.html) - 5.28',
            "\x{2022}\x{a0}\x{a0}function trunc\x{2014}Truncates a real number to a whole number.
Listing <<5.28|5a:0>>. Some mathematical functions.
program fig28;
 { demonstrates some mathematical functions }
 const
   { pi = 3.1415; DO NOT DEFINE THIS!
     It is already defined for you. }
   rad: real = pi/180; { one degree = pi / 180 radians }
   degreeparts: array[1..17] of integer =
    (0,30,45,60,90,120,135,150,180,210,225,240,270,300,315,330,360);
 var
   i: byte;
   sresult, cresult: real;
 begin
   writeln(\x{2018}Simple Trigonometry Table\x{2019});
   writeln(\x{2018}Degrees\x{2019},\x{2019}Sin\x{2019}:5,
   \x{2019}Cos\x{2019}:10,\x{2019}Tan\x{2019}:10);
   for i := <<1 to 17|10a:0>> do
     begin
       sresult := sin(degreeparts[i]*rad);
       cresult := cos(degreeparts[i]*rad);
       write(degreeparts[i]:4, sresult:10:3,cresult:10:3);
       { note due to the conversion from radians that these are not
         *exactly* accurate, as denoted by the negatives on the 0
         values. }
       { done to indicate the exception in the formula for tan x,
         which is sin x / cos x ; cos x <> 0 , set won\x{2019}t handle
         anything beyond byte, so 30 is subtracted, and other
         values are used. }
       if (degreeparts[i] - 30) in [60, 240] then
         writeln(\x{2018}Invalid\x{2019}:10)
       else
         writeln(sresult/cresult :10:3);
       end;
  end.",
          ],
          [
            1,
            '[16:59] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (287-290.html) - 1 to 17',
            "program fig28;
 { demonstrates some mathematical functions }
 const
   { pi = 3.1415; DO NOT DEFINE THIS!
     It is already defined for you. }
   rad: real = pi/180; { one degree = pi / 180 radians }
   degreeparts: array[1..17] of integer =
    (0,30,45,60,90,120,135,150,180,210,225,240,270,300,315,330,360);
 var
   i: byte;
   sresult, cresult: real;
 begin
   writeln(\x{2018}Simple Trigonometry Table\x{2019});
   writeln(\x{2018}Degrees\x{2019},\x{2019}Sin\x{2019}:5,
   \x{2019}Cos\x{2019}:10,\x{2019}Tan\x{2019}:10);
   for i := <<1 to 17|10a:0>> do
     begin
       sresult := sin(degreeparts[i]*rad);
       cresult := cos(degreeparts[i]*rad);
       write(degreeparts[i]:4, sresult:10:3,cresult:10:3);
       { note due to the conversion from radians that these are not
         *exactly* accurate, as denoted by the negatives on the 0
         values. }
       { done to indicate the exception in the formula for tan x,
         which is sin x / cos x ; cos x <> 0 , set won\x{2019}t handle
         anything beyond byte, so 30 is subtracted, and other
         values are used. }
       if (degreeparts[i] - 30) in [60, 240] then
         writeln(\x{2018}Invalid\x{2019}:10)
       else
         writeln(sresult/cresult :10:3);
       end;
  end.",
          ],
          [
            1,
            '[ap 05:29] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (290-293.html) - 5.29',
            "The seed for the PRNG is held in a longint variable called randseed, which may be set directly, if a repeating constant stream of numbers is desired. Otherwise, a procedure named \x{201c}randomize\x{201d} may be used in order to randomize the variable randseed in memory. Then to generate one number of the series, a function named random() may be used. Without parameters, it generates a real number between 0 and 1. With a parameter, it generates a number between 0 and (parameter \x{2013} 1). For example, random(100) generates an integer between 0 and 99. A sample use of the PRNG is shown in Listing <<5.29|5a:0>>.",
          ],
          [
            1,
            '[ap 05:29] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (290-293.html) - 5.29',
            "The seed for the PRNG is held in a longint variable called randseed, which may be set directly, if a repeating constant stream of numbers is desired. Otherwise, a procedure named \x{201c}randomize\x{201d} may be used in order to randomize the variable randseed in memory. Then to generate one number of the series, a function named random() may be used. Without parameters, it generates a real number between 0 and 1. With a parameter, it generates a number between 0 and (parameter \x{2013} 1). For example, random(100) generates an integer between 0 and 99. A sample use of the PRNG is shown in Listing <<5.29|5a:0>>.
Listing <<5.29|5a:0>>. A demonstration of the PRNG.
program fig29;
 { demonstration of the PRNG, distribution of 100 pseudo-randomly
   generated numbers between 1 and 10\x{2014}count of occurrences }
 var
   pcount: array[1..10] of byte;
   i: byte;
 begin
   randomize;
{ call this only *once* at the beginning of the program }
   for i := <<1 to 10|10a:0>> do
     pcount[i] := 0;
   for i := 1 to 100 do
       inc(pcount[random(10)+1]);
   for i := <<1 to 10|10a:0>> do
     writeln(i, \x{2018} occurred \x{2019}, pcount[i], \x{2018} times.\x{2019});
 end.",
          ],
          [
            1,
            '[ap 09:59] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (290-293.html) - 1 to 10',
            "program fig29;
 { demonstration of the PRNG, distribution of 100 pseudo-randomly
   generated numbers between 1 and 10\x{2014}count of occurrences }
 var
   pcount: array[1..10] of byte;
   i: byte;
 begin
   randomize;
{ call this only *once* at the beginning of the program }
   for i := <<1 to 10|10a:0>> do
     pcount[i] := 0;
   for i := 1 to 100 do
       inc(pcount[random(10)+1]);
   for i := <<1 to 10|10a:0>> do
     writeln(i, \x{2018} occurred \x{2019}, pcount[i], \x{2018} times.\x{2019});
 end.",
          ],
          [
            1,
            '[ap 02:00] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (290-293.html) - 2',
            "In shifting bits, they can either be shifted left or right. The corresponding operators to do that in Turbo Pascal are shl, or shift left, and shr, or shift right. In shifting, the bits are physically moved, with 0s assumed on the remaining portions. If any relevant bytes are \x{201c}pushed\x{201d} out of the data\x{2019}s range for storage, they are lost. Note, in the following examples, that within storable limits, shifting bits can be equivalent to multiplying or integer division by the power of <<2|3j>> the bits are shifted by in the operation.",
          ],
          [
            1,
            '[23:59] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (290-293.html) - 1 to 0',
            'In using the boolean operators, the patterns of the answers can reveal the use of these operators. AND can be used quite well to test the existence of a bit or bits at specific positions. Note in the example for AND that the bytes which remain 1s or true are the ones that appear in both columns. With the OR example, any bits that are true and dissimilar are forced to true. In the XOR example, it could that in the positions the 1s are in the second object of the operator, the bits were toggled from <<1 to 0|10a:0>>, or 0 to 1. A coded example of the boolean bit operators and bit shifting are shown in Listing <<5.30|5a:0>>.',
          ],
          [
            1,
            '[ap 05:30] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (293-295.html) - 5.30',
            "
Listing <<5.30|5a:0>>. An example of bitwise operators.
program fig30; uses wconv;
 { visual demonstrator of effects of all bitwise evaluators,
   actually, a good tutorial/flash card program for learning
   these operators. function writebinary(inbyte: byte):string;
   is from wconv, a utility unit I have written for writing
   values in different common bases for my personal use. Code not
   included because it does not further the topic of this program.
   Such a function may be created easily with the knowledge of
   base conversions. }
 var
   option, num1, num2: byte;
 procedure processinfo(option, num1, num2: byte);
   begin
     writeln(writebinary(num1):23);
     case option of
       1: write(\x{2018}SHL\x{2019});
       2: write(\x{2018}SHR\x{2019});
       3: write(\x{2018}AND\x{2019});
       4: write(\x{2018} OR\x{2019});
       5: write(\x{2018}XOR\x{2019});
     end;
     { no point in writing out bits for 2nd number if SHL or SHR }
     if option in [1..2] then
       writeln(num2:10)
     else
       writeln(writebinary(num2):20);
     writeln(\x{2018}======================\x{2019});
     case option of
     1: writeln(writebinary(num1 shl num2):23);
     2: writeln(writebinary(num1 shr num2):23);
     3: writeln(writebinary(num1 and num2):23);
     4: writeln(writebinary(num1 or num2):23);
     5: writeln(writebinary(num1 xor num2):23);
   end;
 end;
begin
 option := 10;
 while option <> 6 do
   begin
     writeln;writeln;
     writeln(\x{2018}Enter a number from the list below:\x{2019});
     writeln(\x{2018}1) SHL 2) SHR 3) AND 4) OR 5) XOR 6) QUT\x{2019});
     write(\x{2018}Enter an option [1-6]: \x{2019});
     readln(option);
     if option <> 6 then
       begin
         write(\x{2018}Enter first number: \x{2019});
         readln(num1);
         write(\x{2018}Enter second number: \x{2019});
         readln(num2);
         writeln;
         processinfo(option, num1, num2);
       end;
  end;
end.",
          ],
          [
            1,
            '[ap 05:31] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (295-298.html) - 5.31',
            'new() creates or assigns a position in the heap for a variable type specified in the data type for that variable, and dispose() removes the position from the heap previously allocated with new(). The designation in a program that indicates a variable is a pointer is the caret symbol (^) as part of the type or variable name. For example, observe the methods by which the simpler structures in Listing <<5.31|5a:0>> are created and accessed. Note that this is a very inefficient way, memory wise, to use pointers (they are usually used in more complex variable types).',
          ],
          [
            1,
            '[ap 05:31] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (295-298.html) - 5.31',
            'Listing <<5.31|5a:0>>. A rudimentary demonstration of pointer-based structures.',
          ],
          [
            1,
            '[ap 05:32] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (295-298.html) - 5.32',
            'An example of doing this is shown in Listing <<5.32|5a:0>>. Far procedures must be used as illustrated to make something like this routine work. For example, a sort routine with options to sort by multiple functions would be ideal for this kind of coding, though this case would be ludicrous. Note that a pointer is also addressed in this listing to a static variable position in memory.',
          ],
          [
            1,
            '[ap 05:32] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (295-298.html) - 5.32',
            "An example of doing this is shown in Listing <<5.32|5a:0>>. Far procedures must be used as illustrated to make something like this routine work. For example, a sort routine with options to sort by multiple functions would be ideal for this kind of coding, though this case would be ludicrous. Note that a pointer is also addressed in this listing to a static variable position in memory.
Listing <<5.32|5a:0>>. Demonstration of the \@ operator.
program fig32;
 type
   intptr = ^integer;
   proctype = procedure(a: string);
 var
   c: integer;
   d: intptr;
   callit: proctype;
  {\$F+}    { this can be used or \x{201c}far;\x{201d} after each procedure }
  procedure yesitisafive(a: string);
    begin
      writeln(\x{2018}D is a 5.\x{2019});
      writeln(a);
    end;
  procedure noitisnotafive(a: string);
    begin
      writeln(\x{2018}D is not a 5.\x{2019});
      writeln(a);
    end;
  {\$F-}
  begin
    \@callit := nil;     { requirement to make it work }
    c := 5;
    d := \@c;
    writeln(\x{2018}Pointer contents of d are \x{2019}, d^);
    if d^ = 5 then
      \@callit := \@yesitisafive
    else
      \@callit := \@noitisnotafive;
    callit(\x{2018}Whatever works is fine.\x{2019});
  end.",
          ],
          [
            1,
            '[ap 05:33] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (298-300.html) - 5.33',
            'exitproc is a procedure that is set up as an address system, which is executed on the compiler automatically upon completion of the program, no matter what kind of error may happen, but before a runtime error code message. A common application for this feature is the addition of runtime error-description code, or diagnostic logging features for a program, or clean-up functions for working with files. Listing <<5.33|5a:0>> shows an example.',
          ],
          [
            1,
            '[ap 05:33] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (298-300.html) - 5.33',
            "exitproc is a procedure that is set up as an address system, which is executed on the compiler automatically upon completion of the program, no matter what kind of error may happen, but before a runtime error code message. A common application for this feature is the addition of runtime error-description code, or diagnostic logging features for a program, or clean-up functions for working with files. Listing <<5.33|5a:0>> shows an example.
Listing <<5.33|5a:0>>. An example of the use of exitproc.
program fig33;
 const
   a: integer = 3;
   b: integer = 0;
 var
   exitsave: procedure;
 {\$F+}          { must be far }
 procedure myexit; {must be parameterless}
   begin
     writeln;
     writeln(\x{2018}Exit.\x{2019});
     if exitcode <> 0 then
     { exitcode used to hold run-time error number}
       writeln(\x{2018}There was a problem.\x{2019})
     else
       writeln(\x{2018}Successful termination.\x{2019});
   end;
 {\$F-}
 begin
   \@exitsave := exitproc; { saving the original exit procedure }
   exitproc := \@myexit;   { set to new exit procedure}
   writeln(\x{2018}Hello!\x{2019});
   { force a division by zero RUNTIME error }
   writeln(\x{2018}Divide by Zero: \x{2019}, a/b);
   exitproc := \@exitsave; { set the original exit procedure back }
 end.",
          ],
          [
            1,
            '[ap 05:34] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (300-303.html) - 5.34',
            'The text at the particular position is translated into whatever variable is desired. A full example of reading and writing to text files is shown in Listing <<5.34|5a:0>>, as well as proper use of the functions eof() and eoln(). These functions perform status checking to determine whether the reading is at the end of the file or the end of the line of text (in that order). These functions should always be used, as you do not always know the exact description of a file that is accessed.',
          ],
          [
            1,
            '[ap 05:34] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (300-303.html) - 5.34',
            "The text at the particular position is translated into whatever variable is desired. A full example of reading and writing to text files is shown in Listing <<5.34|5a:0>>, as well as proper use of the functions eof() and eoln(). These functions perform status checking to determine whether the reading is at the end of the file or the end of the line of text (in that order). These functions should always be used, as you do not always know the exact description of a file that is accessed.
Listing <<5.34|5a:0>>. A demonstration of reading and writing text files.
program fig34;
 { demonstration of text file usage, along with eof() and eoln() }
 { Uses INTDATA.TXT as generated by TESTTEXT.EXE }
 var
   infile, outfile: text;
   total: longint;
   number_line, total_line: integer;
   objnum: integer;
 begin
   assign(infile, \x{2018}INTDATA.TXT\x{2019});
   assign(outfile, \x{2018}DATARPT.TXT\x{2019});
   reset(infile);
   rewrite(outfile);
   total_line := 0;
   while not eof(infile) do
     begin
       number_line := 0;
       total := 0;
       while not eoln(infile) do
         begin
           read(infile, objnum);
           inc(total, objnum);
           inc(number_line);
         end;
       readln(infile);
       inc(total_line);
    writeln(outfile, \x{2018}Line \x{2019}, total_line:3, \x{2018}: \x{2019}, number_line:2,
              \x{2018} numbers \x{2014} Average: \x{2019}, (total/number_line):10:4);
  end;
close(infile);
close(outfile);
end.",
          ],
          [
            1,
            '[ap 05:35] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (300-303.html) - 5.35',
            'Another way to access a file is as a typed binary file. Binary files contain data that is stored in the file exactly as it is stored in memory. A typed binary file is a binary file in which the type of the data that is read or written is described beforehand. Therefore, the reads and writes to this type of file are always of the variable type specified (attempting to read/write any other type results in a runtime error). An example of the use of typed binary files is shown in Listing <<5.35|5a:0>>.',
          ],
          [
            1,
            '[ap 05:35] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (300-303.html) - 5.35',
            "A procedure named seek(<binary file var>, <# of vars forward>) is used for adding random access to a binary file for purposes of reading or overwriting a position in the file, and filesize(<typed binary filevar>) returns the total number of typed variables in the file (if 38 integers are in a file, it returns 38, and not the physical size of the file on the drive). Note that eoln()\x{2019}s usefulness is eliminated in this file type, but eof() is still useful in the case of reading a typed binary file.
Listing <<5.35|5a:0>>. An example of typed binary file use.
program fig35;
 { demonstration of usage of typed binary file }
 { uses intdata.txt as input, outputs binary integer data }
 var
   infile: text;
   outfile: file of integer;
   int: integer;
 begin
   assign(infile, \x{2018}INTDATA.TXT\x{2019});
   assign(outfile, \x{2018}TYPEDATA.DAT\x{2019});
   reset(infile);
   rewrite(outfile);
   while not eof(infile) do
     begin
       while not eoln(infile) do
         begin
           read(infile, int);
           write(outfile, int);
         end;
       readln(infile);
     end;
   close(infile);
   close(outfile);
 end.",
          ],
          [
            1,
            '[ap 05:36] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (303-306.html) - 5.36',
            'A file can also be accessed as an untyped binary file. Here, no type is given in the file variable. In this case, filesize and seek units are always in bytes. Also, because no types are used, different procedures must be used for reading and writing to these files, as read and write work only with typed variables. blockread and blockwrite function for this purpose. The way to call these procedures is readily apparent in Listing <<5.36|5a:0>>. Note the use of sizeof(), which is the best way to indicate the size of whatever structure is used.',
          ],
          [
            1,
            '[ap 05:36] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (303-306.html) - 5.36',
            "Untyped binary files have the advantage of speed and the ability to read varying data types. When the same data type is stored throughout the file, typed binary files are better.
Listing <<5.36|5a:0>>. An example of the use of untyped files.
program fig36;
 { demonstration: untyped files, blockread, blockwrite }
 { uses TYPEDATA.DAT }
 var
   infile2, outfile: file;
   buffer: array[1..1024] of integer;
   amtread, amtwritten: integer;
 begin
   assign(infile2, \x{2018}TYPEDATA.DAT\x{2019});
   assign(outfile, \x{2018}VERIFIED.DAT\x{2019});
   reset(infile2, 1);
   rewrite(outfile, 1);
   repeat
     blockread(infile2, buffer, sizeof(buffer), amtread);
     blockwrite(outfile, buffer, amtread, amtwritten);
   until amtread = 0;
   close(infile2);
   close(outfile);
 end.",
          ],
          [
            1,
            '[ap 05:37] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (303-306.html) - 5.37',
            'The printer can also be used as a file. The printer is assigned as a write-only text file, generally to the file lptX (where X is the port number) or prn. But the printer unit is available to do this job for us, assigning a file variable named lst to the printer. Note in Listing <<5.37|5a:0>>, that a form-feed character, defined as a constant, must be written after each page.',
          ],
          [
            1,
            '[ap 05:37] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (303-306.html) - 5.37',
            "The printer can also be used as a file. The printer is assigned as a write-only text file, generally to the file lptX (where X is the port number) or prn. But the printer unit is available to do this job for us, assigning a file variable named lst to the printer. Note in Listing <<5.37|5a:0>>, that a form-feed character, defined as a constant, must be written after each page.
Listing <<5.37|5a:0>>. An example of using the printer.
program fig37; uses printer;
{ printer unit defaults to LPT 1 as the location of the printer }
 const
   ff = #12;
 var
   i: byte;
 begin
   for i := <<1 to 15|10a:0>> do
     writeln(lst, \x{2018}Hello World! From my Printer!\x{2019});
   writeln(lst,ff);
 end.",
          ],
          [
            1,
            '[14:59] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (303-306.html) - 1 to 15',
            "program fig37; uses printer;
{ printer unit defaults to LPT 1 as the location of the printer }
 const
   ff = #12;
 var
   i: byte;
 begin
   for i := <<1 to 15|10a:0>> do
     writeln(lst, \x{2018}Hello World! From my Printer!\x{2019});
   writeln(lst,ff);
 end.",
          ],
          [
            1,
            '[ap 05:38] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (303-306.html) - 5.38',
            "The function readkey is a parameterless one; it reads the equivalent of a character from the keyboard. It does not echo to the screen when a character is read. Also, it continues control upon a keypress. Generally, readkey pulls in a character, or series of characters from the keyboard buffer. If it is a regular ASCII character, the function puts it into the character assigned. Otherwise, for extended keys (F1\x{2013}F10, Insert, Home, Delete, PageUp, PageDown, End, Arrow Keys), a character #0 is returned, and a subsequent call to readkey returns a unique character for each of these keys. An example of readkey and the reading of extended keys is shown in Listing <<5.38|5a:0>>.",
          ],
          [
            1,
            '[ap 05:38] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (303-306.html) - 5.38',
            "In addition, a variable called keypressed exists. This can be used to run a process until a key is pressed.
Listing <<5.38|5a:0>>. A demonstration of readkey.
program fig38; uses crt;
 { Demonstration of readkey }
 var
   c: char;
 begin
   write(\x{2018}Hit a key: \x{2019});
   c := readkey;
   writeln; {remember readkey doesn\x{2019}t behave like read/readln}
   write(\x{2018}Key codes returned by the key you pressed are: \x{2019});
   write(\x{2018}#\x{2019}, ord(c), \x{2018} \x{2019});
   if c = #0 then
     begin
       c := readkey;
       write(\x{2018}#\x{2019}, ord(c));
     end;
   writeln;
 end.",
          ],
          [
            1,
            '[ap 05:39] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (303-306.html) - 5.39',
            "Note, in addition, that a current problem with TP/BP 7.0 (since there was no such thing as a Pentium II when released) is that the delay procedure has been known to crash. Borland\x{2019}s position on TP 7 is to not fix this error but refer people to upgrade to Delphi. Even though Borland claims this, note that this problem can be fixed, and a description of options to fix this error (Runtime Error 200: Division by Zero) can be found at the URLs specified at the beginning of this chapter.
Listing <<5.39|5a:0>>. A demonstration of activating the PC speaker.
program fig39; uses crt;
 const
   min = 250;
   max = 3000;
 var
   index: word;
 procedure pcsound(hertz, milliseconds: word);
   begin
     sound(hertz);
     delay(milliseconds);
     nosound;
   end;
 begin
   index := min;
   while index < max do
     begin
       pcsound(index,250);
       inc(index, 250);
     end;
   while index > min do
     begin
       pcsound(index,250);
       dec(index, 250);
     end;
 end.",
          ],
          [
            1,
            '[ap 05:40] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (306-308.html) - 5.40',
            "textmode accepts integers that are defined as constants to be BW40, CO40, BW80, and CO80, as the most common ones (BW = black and white, CO = color, 40 = 40\x{d7}25 screen, 80 = 80\x{d7}25 screen). In addition, with EGA and VGA cards, a parameter named Font8X8 changes the screen to 43 or 50 line mode when it is added. The default is CO80. A well-behaved program accesses the variable LastMode to store the current mode before changing it. These procedures are shown in Listing <<5.40|5a:0>>. Note that all attributes are reset when textmode and window are called.",
          ],
          [
            1,
            '[ap 05:40] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (306-308.html) - 5.40',
            "textmode accepts integers that are defined as constants to be BW40, CO40, BW80, and CO80, as the most common ones (BW = black and white, CO = color, 40 = 40\x{d7}25 screen, 80 = 80\x{d7}25 screen). In addition, with EGA and VGA cards, a parameter named Font8X8 changes the screen to 43 or 50 line mode when it is added. The default is CO80. A well-behaved program accesses the variable LastMode to store the current mode before changing it. These procedures are shown in Listing <<5.40|5a:0>>. Note that all attributes are reset when textmode and window are called.
Listing <<5.40|5a:0>>. A demonstration of active window manipulation.
program fig40; uses crt;
var
  origmode: integer;
procedure screen(inptype: string);
  var
    j: byte;
  begin
    clrscr;
    writeln(\x{2018}Text Box (Active Window at 5,5 and 20,20) textmode \x{2019},
             inptype);
    window(5,5,20,20);
    for j := 1 to 40 do
      write(\x{2018}Fill!\x{2019});
  end;
begin
 origmode := LastMode;
 textmode(CO80);
 screen(\x{2018}CO80\x{2019});
 readln;
 textmode(CO40);
 screen(\x{2018}CO40\x{2019});
 readln;
 textmode(Font8X8 + CO80);
 screen(\x{2018}Font8X8 CO80\x{2019});
 readln;
 textmode(Font8X8 + CO40);
 screen(\x{2018}Font8X8 CO40\x{2019});
 readln;
 textmode(origmode);
 writeln(\x{2018}Good-Bye and Have a Nice Day!\x{2019});
end.",
          ],
          [
            1,
            '[15:00] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (306-308.html) - 0 to 15',
            "textcolor(color)\x{2014}Sets a foreground color from <<0 to 15|10a:0>>, as listed below",
          ],
          [
            1,
            '[15:00] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (306-308.html) - 0 to 15',
            "textcolor(color)\x{2014}Sets a foreground color from <<0 to 15|10a:0>>, as listed below
textbackground(color)\x{2014}Sets a background color from <<0 to 8|10a:0>>
highvideo, normvideo\x{2014}All these, as implied, change intensity of video",
          ],
          [
            1,
            '[ap 05:41] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (306-308.html) - 5.41',
            'The defaults are normvideo, textcolor(15), and textbackground(0). A demonstration is shown in Listing <<5.41|5a:0>>. Note that rote screen and color manipulation can get very lengthy in coding; also note that the designations on the colors are defined as constants in the CRT unit to represent each color, either the number as used in this program or the textmode constant seen beside the color block may be used.',
          ],
          [
            1,
            '[ap 05:41] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (309-311.html) - 5.41',
            "
Listing <<5.41|5a:0>>. A demonstration of text appearance procedures.
program fig41; uses crt;
 { Demonstration along with listing of equivalent constants }
 type
   string19 = string[19];
 var
   i: byte;
 function returntextconstant(color: byte):string19;
   var
     rtrn: string19;
   begin
     rtrn := \x{2018}\x{2019};
     if color >= 128 then
       begin
         rtrn := \x{2018}Blink+\x{2019};
         dec(color, 128);
       end;
     case color of
        0: rtrn := rtrn + \x{2018}Black        \x{2019};
        1: rtrn := rtrn + \x{2018}Blue         \x{2019};
        2: rtrn := rtrn + \x{2018}Green        \x{2019};
        3: rtrn := rtrn + \x{2018}Cyan         \x{2019};
        4: rtrn := rtrn + \x{2018}Red          \x{2019};
        5: rtrn := rtrn + \x{2018}Magenta      \x{2019};
        6: rtrn := rtrn + \x{2018}Brown        \x{2019};
        7: rtrn := rtrn + \x{2018}LightGray    \x{2019};
        8: rtrn := rtrn + \x{2018}DarkGray     \x{2019};
        9: rtrn := rtrn + \x{2018}LightBlue    \x{2019};
       10: rtrn := rtrn + \x{2018}LightGreen   \x{2019};
       11: rtrn := rtrn + \x{2018}LightCyan    \x{2019};
       12: rtrn := rtrn + \x{2018}LightRed     \x{2019};
       13: rtrn := rtrn + \x{2018}LightMagenta \x{2019};
       14: rtrn := rtrn + \x{2018}Yellow       \x{2019};
       15: rtrn := rtrn + \x{2018}White        \x{2019};
     end;
     returntextconstant := rtrn;
   end;
 procedure writeblock(color:byte);
   begin
     write(#219:6,#219,#219,#219, \x{2018} - \x{2019});
     write(returntextconstant(color));
  end;
 procedure writescreenpage(start: byte);
   var
     i: byte;
   begin
     for i := start to start+15 do
       begin
         textcolor(i);
         writeblock(i);
         if (i+1) mod 2 = 0 then
           begin writeln;writeln;end;
       end;
  end;
procedure textcolordemo;
  begin
    { Does the 8 screens with backgrounds changed }
    for i := <<0 to 7|10a:0>> do
      begin
        textbackground(i);
        clrscr;
        textcolor(white);
        writeln(\x{2018}Screen Demonstration: Text Background = \x{2019},
                  returntextconstant(i));
        writeln;
        writescreenpage(0);
        readln;
      end;
    { does blinking screen demo}
    textcolor(white);
    textbackground(black);
    clrscr;
    writeln(\x{2018}Screen Demonstration: Blinking Text\x{2019});
    writeln;
    writescreenpage(128);
    { start from <<128|9c:0>>; textattribute + 128 is blink }
    readln;
  end;
procedure gotoxydemo;
  begin
    clrscr;
    randomize;
    textcolor(white);
    writeln(\x{2018}Screen Positioning Demo: press a key when done\x{2019});
    repeat
      textcolor(random(15)+1);
      gotoxy(random(79)+1, random(23)+2);
      write(#254);
      delay(500);
      gotoxy(wherex-1, wherey);
      textcolor(black);
      write(#216);
    until keypressed;
    textbackground(black);
  end;
begin
  textbackground(black);
  writeln;
  textcolordemo;
  gotoxydemo;
  clrscr;
  textcolor(white);
  clrscr;
  writeln(\x{2018}Thanks for your time!\x{2019});
end.",
          ],
          [
            1,
            '[ap 07:00] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (309-311.html) - 0 to 7',
            "program fig41; uses crt;
 { Demonstration along with listing of equivalent constants }
 type
   string19 = string[19];
 var
   i: byte;
 function returntextconstant(color: byte):string19;
   var
     rtrn: string19;
   begin
     rtrn := \x{2018}\x{2019};
     if color >= 128 then
       begin
         rtrn := \x{2018}Blink+\x{2019};
         dec(color, 128);
       end;
     case color of
        0: rtrn := rtrn + \x{2018}Black        \x{2019};
        1: rtrn := rtrn + \x{2018}Blue         \x{2019};
        2: rtrn := rtrn + \x{2018}Green        \x{2019};
        3: rtrn := rtrn + \x{2018}Cyan         \x{2019};
        4: rtrn := rtrn + \x{2018}Red          \x{2019};
        5: rtrn := rtrn + \x{2018}Magenta      \x{2019};
        6: rtrn := rtrn + \x{2018}Brown        \x{2019};
        7: rtrn := rtrn + \x{2018}LightGray    \x{2019};
        8: rtrn := rtrn + \x{2018}DarkGray     \x{2019};
        9: rtrn := rtrn + \x{2018}LightBlue    \x{2019};
       10: rtrn := rtrn + \x{2018}LightGreen   \x{2019};
       11: rtrn := rtrn + \x{2018}LightCyan    \x{2019};
       12: rtrn := rtrn + \x{2018}LightRed     \x{2019};
       13: rtrn := rtrn + \x{2018}LightMagenta \x{2019};
       14: rtrn := rtrn + \x{2018}Yellow       \x{2019};
       15: rtrn := rtrn + \x{2018}White        \x{2019};
     end;
     returntextconstant := rtrn;
   end;
 procedure writeblock(color:byte);
   begin
     write(#219:6,#219,#219,#219, \x{2018} - \x{2019});
     write(returntextconstant(color));
  end;
 procedure writescreenpage(start: byte);
   var
     i: byte;
   begin
     for i := start to start+15 do
       begin
         textcolor(i);
         writeblock(i);
         if (i+1) mod 2 = 0 then
           begin writeln;writeln;end;
       end;
  end;
procedure textcolordemo;
  begin
    { Does the 8 screens with backgrounds changed }
    for i := <<0 to 7|10a:0>> do
      begin
        textbackground(i);
        clrscr;
        textcolor(white);
        writeln(\x{2018}Screen Demonstration: Text Background = \x{2019},
                  returntextconstant(i));
        writeln;
        writescreenpage(0);
        readln;
      end;
    { does blinking screen demo}
    textcolor(white);
    textbackground(black);
    clrscr;
    writeln(\x{2018}Screen Demonstration: Blinking Text\x{2019});
    writeln;
    writescreenpage(128);
    { start from <<128|9c:0>>; textattribute + 128 is blink }
    readln;
  end;
procedure gotoxydemo;
  begin
    clrscr;
    randomize;
    textcolor(white);
    writeln(\x{2018}Screen Positioning Demo: press a key when done\x{2019});
    repeat
      textcolor(random(15)+1);
      gotoxy(random(79)+1, random(23)+2);
      write(#254);
      delay(500);
      gotoxy(wherex-1, wherey);
      textcolor(black);
      write(#216);
    until keypressed;
    textbackground(black);
  end;
begin
  textbackground(black);
  writeln;
  textcolordemo;
  gotoxydemo;
  clrscr;
  textcolor(white);
  clrscr;
  writeln(\x{2018}Thanks for your time!\x{2019});
end.",
          ],
          [
            1,
            '[ap 05:42] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (311-314.html) - 5.42',
            "Executing another program from your program can be a simple matter, if you keep in mind the properties of DOS. The DOS command interpreter is always found defined in the environment variable COMSPEC. After spawning a command interpreter, which is what happens in Listing <<5.42|5a:0>>, the /C command parameter must be given before the command line desired. The command interpreter doesn\x{2019}t have to be spawned for specific programs, but for batch files and any command that uses any DOS features (such as redirection), the command interpreter must be called.",
          ],
          [
            1,
            '[ap 05:42] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (311-314.html) - 5.42',
            "All functions and procedures related to executing another program make use of the DOS unit.
Listing <<5.42|5a:0>>. A demonstration of shelling to execute another program.
{\$M 16382,0,4000}
program fig42; uses dos;
 { Demonstration of executing another program }
 var
   command: string;
 begin
   write(\x{2018}Enter your DOS command line here: \x{2019});
   readln(command);
   command := \x{2018} /C \x{2019} + command; { requirement for COMMAND.COM }
   swapvectors;
   exec(getenv(\x{2018}COMSPEC\x{2019}), command);
   swapvectors;
   {an example of a command line, if it were DOS issued, would be
   c:\\dos\\command.com /c chkdsk /f }
   writeln;
   writeln(\x{2018}End of program execution.\x{2019});
 end.",
          ],
          [
            1,
            '[ap 05:43] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (311-314.html) - 5.43',
            'The existence of a file on a drive can be determined in one of two ways, as described in Listing <<5.43|5a:0>>, with the two sample functions, in the order described. One is faster than the other for obvious reasons (presence of disk I/O), but both are in widespread use.',
          ],
          [
            1,
            '[ap 05:43] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (311-314.html) - 5.43',
            'Listing <<5.43|5a:0>>. Demonstration of two methods to find whether a file exists.',
          ],
          [
            1,
            '[ap 05:44] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (311-314.html) - 5.44',
            'In processing, if command-line parameters are expected, paramcount is called first, and then if paramcount is 0, then generally a call to halt() is issued, but not always. halt() terminates the program with a DOS error equivalent to the number in the parameter. Afterward, all valid paramstr() calls are returned into a string, and proper actions are taken depending on the parameters. An example of a proper way to handle command-line parameters is shown in Listing <<5.44|5a:0>>.',
          ],
          [
            1,
            '[ap 05:44] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (311-314.html) - 5.44',
            "In processing, if command-line parameters are expected, paramcount is called first, and then if paramcount is 0, then generally a call to halt() is issued, but not always. halt() terminates the program with a DOS error equivalent to the number in the parameter. Afterward, all valid paramstr() calls are returned into a string, and proper actions are taken depending on the parameters. An example of a proper way to handle command-line parameters is shown in Listing <<5.44|5a:0>>.
Listing <<5.44|5a:0>>. A demonstration of command-line parameters.
{\$M 16382,0,4000}
program fig44; uses dos;
 { Demonstration of parameter strings. Note the DOS unit is *NOT*
   required for the parameter systems. }
 var
   command: string;
   i: byte;
 begin
   if paramcount <> 0 then
     begin
       command := \x{2018} /C \x{2019};
       for i := 1 to paramcount do
         command := command + paramstr(i);
       swapvectors;
       exec(getenv(\x{2018}COMSPEC\x{2019}), command);
       swapvectors;
       writeln;
       writeln(\x{2018}End of program execution.\x{2019});
     end
   else
     begin
       writeln(\x{2018}Incorrect # of parameters specified.\x{2019});
       halt(10);
     end;
 end.",
          ],
          [
            1,
            '[ap 05:45] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (314-317.html) - 5.45',
            'findfirst and findnext are called in a manner described in Listing <<5.45|5a:0>>, using a variable defined as searchrec earlier. findfirst takes a path, attribute type, and searchrec variable and returns the first file that fits the description. A subsequent call to findnext returns the next file that fits the original description.',
          ],
          [
            1,
            '[ap 05:45] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (314-317.html) - 5.45',
            "ReadOnly := \$01
Hidden := \$02
SysFile := \$04
VolumeID := \$08
Directory := \$10
Archive := \$20
AnyFile := \$3F
Listing <<5.45|5a:0>>. A demonstration of findfirst and findnext.
program fig45; uses dos;
 var
   fileinfo: searchrec;
 begin
   findfirst(\x{2018}*.*\x{2019},AnyFile, fileinfo);
   while doserror = 0 do { doserror = 18 = no more files to list }
     begin
       write(fileinfo.name);
       if (fileinfo.attr and Directory) = Directory then
         writeln(\x{2018}[DIR]\x{2019}:18)
       else
         writeln(fileinfo.size:18);
       findnext(fileinfo);
     end;
end.",
          ],
          [
            1,
            '[ap 06:22] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (314-317.html) - 6.22',
            'var dosversion: word; { if DOS <<6.22|5a:0>>, Hi(dosversion) = 22, Lo(dosversion) = 6 }',
          ],
          [
            1,
            '[ap 05:36] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (314-317.html) - 5.36',
            'Listing <<5.36|5a:0>> shows an example of a good way to copy a file. Moving a file on a drive can be accomplished by renaming the file (it works on paths), or by copying the file and then deleting it across drives.',
          ],
          [
            1,
            '[ap 05:46] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (317-320.html) - 5.46',
            'Listing <<5.46|5a:0>> and Listing <<5.47|5a:0>> show an example of assembling an overlaid application. Generally, because the size of an application that should be overlaid is large, this example is a ludicrous one, yet good to show such a situation. Also, complete error-checking statements have been left out but may be found in the manuals or online help.',
          ],
          [
            1,
            '[ap 05:46] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (317-320.html) - 5.46',
            'Listing <<5.46|5a:0>> and Listing <<5.47|5a:0>> show an example of assembling an overlaid application. Generally, because the size of an application that should be overlaid is large, this example is a ludicrous one, yet good to show such a situation. Also, complete error-checking statements have been left out but may be found in the manuals or online help.
Listing <<5.46|5a:0>>. A sample unit for an overlaid application.
{$O+}
unit fig46; { note, the identifier must match the name of the file }
 interface
   function power(x:real; y: integer):real;
 implementation
   function power(x:real; y: integer):real; { exactly as above }
     var
       i: integer;
       result: real;
     begin
       result := 1;
       for i := 1 to y do
         result := result * x;
       power := result;
     end;
end.',
          ],
          [
            1,
            '[ap 05:47] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (317-320.html) - 5.47',
            "{\$O+}
unit fig46; { note, the identifier must match the name of the file }
 interface
   function power(x:real; y: integer):real;
 implementation
   function power(x:real; y: integer):real; { exactly as above }
     var
       i: integer;
       result: real;
     begin
       result := 1;
       for i := 1 to y do
         result := result * x;
       power := result;
     end;
end.
Listing <<5.47|5a:0>>. A sample base program for an overlaid application.
program fig47; uses fig46, overlay;
{if more than 1 unit put commas between each id}
 var
   i: byte;
 {\$O FIG46.TPU } { list units to be overlaid }
 begin
   OvrInit(\x{2018}FIG47.OVR\x{2019});
   if OvrResult <> 0 then
     begin
       { note specific reasons can be stated }
       writeln(\x{2018}Error loading overlay!\x{2019});
       halt(100);
     end
   else
     begin
       OvrInitEMS; { if overlay loadable, then try to load in EMS }
       if OvrResult <> 0 then
         writeln(#254, \x{2018} Not loaded in EMS for some reason.\x{2019})
       else
         writeln(#254, \x{2018} Overlay loaded in EMS\x{2019});
     end;
   writeln;
   for i := <<1 to 10|10a:0>> do
     writeln(i, \x{2018} squared is \x{2019}, power(i,2):0:2);
 end.",
          ],
          [
            1,
            '[ap 09:59] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (317-320.html) - 1 to 10',
            "program fig47; uses fig46, overlay;
{if more than 1 unit put commas between each id}
 var
   i: byte;
 {\$O FIG46.TPU } { list units to be overlaid }
 begin
   OvrInit(\x{2018}FIG47.OVR\x{2019});
   if OvrResult <> 0 then
     begin
       { note specific reasons can be stated }
       writeln(\x{2018}Error loading overlay!\x{2019});
       halt(100);
     end
   else
     begin
       OvrInitEMS; { if overlay loadable, then try to load in EMS }
       if OvrResult <> 0 then
         writeln(#254, \x{2018} Not loaded in EMS for some reason.\x{2019})
       else
         writeln(#254, \x{2018} Overlay loaded in EMS\x{2019});
     end;
   writeln;
   for i := <<1 to 10|10a:0>> do
     writeln(i, \x{2018} squared is \x{2019}, power(i,2):0:2);
 end.",
          ],
          [
            1,
            '[ap 05:48] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (317-320.html) - 5.48',
            'OBJ files, which contain procedures or functions, may be used in Turbo Pascal. They should be compiled in the standard Pascal style (far, pascal). The $L variable is used to link in the OBJ file, and then the procedure or function must be restated as an external function, with types matching that in the object. Nothing may be used that is not compiled in the far pascal mode (see Listing <<5.48|5a:0>>).',
          ],
          [
            1,
            '[ap 05:48] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (317-320.html) - 5.48',
            "OBJ files, which contain procedures or functions, may be used in Turbo Pascal. They should be compiled in the standard Pascal style (far, pascal). The \$L variable is used to link in the OBJ file, and then the procedure or function must be restated as an external function, with types matching that in the object. Nothing may be used that is not compiled in the far pascal mode (see Listing <<5.48|5a:0>>).
Listing <<5.48|5a:0>>. Linking in an object file.
{source for OBJ file must appear this way,
no things linked in not compiled far, pascal }
int far pascal writeaverage(int a, int b, int c)
 {
   int temp;
   temp = a + b + c;
   return(temp / 3);
 }
Linked in program:
program fig48;
{\$F+}
{\$L FIG48.OBJ}
function writeaverage(a,b,c: integer):integer;external;
begin
 write(\x{2018}The average of 1,3, and 2 (rounded to nearest whole 1umber) \x{2019});
 writeln(\x{2018}is \x{2019}, writeaverage(1,3,2));
end.",
          ],
          [
            1,
            '[ap 05:49] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (317-320.html) - 5.49',
            'The example shown in Listing <<5.49|5a:0>> is a little program that returns the cluster size of the current drive.',
          ],
          [
            1,
            '[ap 05:49] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (317-320.html) - 5.49',
            "The example shown in Listing <<5.49|5a:0>> is a little program that returns the cluster size of the current drive.
Listing <<5.49|5a:0>>. An example of an interrupt call.
program fig49; uses dos;
function getclustersize(drive: byte): Word;
 var
   register: registers;
 begin
   register.ax := \$3600;
   register.cx := 0;
   register.dx := drive;
   Intr(\$21, register);
   getclustersize := register.ax * register.cx;
 end;
begin
 writeln(\x{2018}Cluster size of current drive is: \x{2019}, getclustersize(0));
end.",
          ],
          [
            1,
            '[ap 02:59] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (340-343.html) - 1 to 3',
            'This can be useful for producing sequences, as in
|(<<1 to 3|10a:0>>)
which generates 1, 2, 3, 1, 2, 3,  and so on.',
          ],
          [
            1,
            '[ap 01:00] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (346-348.html) - 1',
            'Positions in strings are between characters, numbered starting at <<1|9g>> before the first character, and there is a position after the last character, as shown by this example:',
          ],
          [
            1,
            '[00:00] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (346-348.html) - 0',
            'There also are nonpositive position specifications starting at <<0|9g>> after the last character and decreasing toward the left:',
          ],
          [
            1,
            '[ap 01:00] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (354-357.html) - 1',
            'Every structure has a serial number, and each structure type has a separate series of serial numbers. Serial numbers start at <<1|9g>> for the first structure created of that type and increase as new structures are created. Each record type has its own series.',
          ],
          [
            1,
            '[ap 03:00] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (362-364.html) - 0 to 3',
            'As another example, consider producing a file in which the octal, decimal, and hexadecimal numbers for the 256 characters are given in columns. The expression
(<<0 to 3|10a:0>>) || (<<0 to 7|10a:0>>) || (<<0 to 7|10a:0>>)
generates the octal numbers 0 through 377 in order. The expression',
          ],
          [
            1,
            '[ap 03:00] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (362-364.html) - 0 to 3',
            "octal := create (<<0 to 3|10a:0>>) || (<<0 to 7|10a:0>>) || (<<0 to 7|10a:0>>)
decimal := create 0 to 255
hexadecimal := !\x{201d}0123456789abcdef\x{201d} || !\x{201d}0123456789abcdef\x{201d}
while write(\@octal, \x{201c} \x{201c}, \@decimal, \x{201c} \x{201c}, \@hexadecimal)",
          ],
          [
            1,
            '[00:00] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (364-368.html) - 0',
            'Because pixel numbering starts at <<0|9g>>, the lower-right pixel in the window shown is numbered (499,199).',
          ],
          [
            1,
            '[ap 02:59] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (382-386.html) - 1 to 3',
            "1.\x{a0}\x{a0}(<<1 to 3|10a:0>>) | (<<3 to 1|10a:0>> by \x{2013}1)
Solution: 1, 2, 3, 3, 2, 1. The sequence for alternation consists of the sequence for its first operand followed by the sequence for its second operand.",
          ],
          [
            1,
            '[ap 02:59] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (382-386.html) - 1 to 3',
            "2.\x{a0}\x{a0}(1 | 2) to 3
Solution: 1, 2, 3, 2, 3. The expression (1 | 2) to 3 is equivalent to (<<1 to 3|10a:0>>) | (<<2 to 3|10a:0>>).",
          ],
          [
            1,
            '[ap 01:59] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (382-386.html) - 1 to 2',
            "3.\x{a0}\x{a0}1 to (2 | 3)
Solution: 1, 2, 1, 2, 3. The expression 1 to (2 | 3) is equivalent to (<<1 to 2|10a:0>>) | (<<1 to 3|10a:0>>).",
          ],
          [
            1,
            '[ap 01:59] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (382-386.html) - 1 to 2',
            "3.\x{a0}\x{a0}1 to (2 | 3)
Solution: 1, 2, 1, 2, 3. The expression 1 to (2 | 3) is equivalent to (<<1 to 2|10a:0>>) | (<<1 to 3|10a:0>>).
4.\x{a0}\x{a0}(<<1 to 3|10a:0>>) | (<<3 to 1|10a:0>> by \x{2013}2)
Solution: 1, 2, 3, 3, 1.
5.\x{a0}\x{a0}3 to (1 | 2)
Solution: Nothing. If the first operand of to-by is greater than the second and the increment is positive (1 by default here), no value is produced.",
          ],
          [
            1,
            '[ap 02:59] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (382-386.html) - 1 to 3',
            "7.\x{a0}\x{a0}(<<1 to 3|10a:0>>) & 2
Solution: 2, 2, 2. In the expression, (<<1 to 3|10a:0>>) & 2, (<<1 to 3|10a:0>>) generates three results; for each one the conjunction is evaluated, producing its second operand, 2. This expression is equivalent to (1 & 2) | (2 & 2) | (3 & 2).",
          ],
          [
            1,
            '[ap 02:59] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (382-386.html) - 1 to 3',
            "9.\x{a0}\x{a0}1 & (<<1 to 3|10a:0>>)
Solution: 1, 2, 3. See the comment in the solution to problem 6.",
          ],
          [
            1,
            '[ap 04:57] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (382-386.html) - 3 to 5',
            "10.\x{a0}\x{a0}(<<3 to 5|10a:0>>) & (<<1 to 3|10a:0>>)
Solution: 1, 2, 3, 1, 2, 3, 1, 2, 3. Because the first operand of the conjunction, (<<3 to 5|10a:0>>), produces three results, and the second argument, (<<1 to 3|10a:0>>), is evaluated three times. The values produced by the first operand of conjunction are irrelevant.",
          ],
          [
            1,
            '[ap 02:59] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (382-386.html) - 1 to 3',
            "11.\x{a0}\x{a0}|(<<1 to 3|10a:0>>)
Solution: 1, 2, 3, 1, 2, 3, 1, 2, 3, \x{2026}. Repeated alternation produces the sequence for its operand repeatedly. In this case, it is equivalent to (<<1 to 3|10a:0>>) | (<<1 to 3|10a:0>>) | (<<1 to 3|10a:0>>)\x{2026}. Although the sequence is infinite, the number of results actually produced depends on the context in which it is evaluated.",
          ],
          [
            1,
            '[ap 02:59] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (382-386.html) - 1 to 3',
            "12.\x{a0}\x{a0}|((<<1 to 3|10a:0>>) | (<<3 to 1|10a:0>> by \x{2013}1))
Solution: 1, 2, 3, 3, 2, 1, 1, 2, 3, 3, 2, 1, 1, 2, 3, 3, 2, 1, \x{2026}. See the comments on the solution to problem 1.",
          ],
          [
            1,
            '[ap 01:59] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (382-386.html) - 1 to two',
            "17.\x{a0}\x{a0}|(1 \\ 2)
Solution: 1, 1, 1, \x{2026}. Limiting the expression <<1 to two|10a:0>> values has no effect because 1 produces only one value.",
          ],
          [
            1,
            '[ap 04:57] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (382-386.html) - 3 to 5',
            "18.\x{a0}\x{a0}|((<<3 to 5|10a:0>>) & (1 | 2))
Solution: 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, \x{2026}. See the solution to problem 10.",
          ],
          [
            1,
            '[ap 02:59] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (382-386.html) - 1 to 3',
            "19.\x{a0}\x{a0}(|((<<1 to 3|10a:0>>) & (1 | 2))) \\ 5
Solution: 1, 2, 1, 2, 1. The operand of repeated alternation produces 1, 2, 1, 2, 1, 2, and repeated alternation would produce this repeatedly except for the limitation to five values, which occurs before any repetition.",
          ],
          [
            1,
            '[ap 02:59] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (382-386.html) - 1 to 3',
            "27.\x{a0}\x{a0}!(<<1 to 3|10a:0>>)
Solution: \x{201c}1\x{201d}, \x{201c}2\x{201d}, \x{201c}3\x{201d}. The expression (<<1 to 3|10a:0>>) produces the integers 1, 2, and 3. Each is converted to a string as described in the solution to the preceding problem. Element generation applied to a one-character string just produces the string.",
          ],
          [
            1,
            '[ap 02:59] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (382-386.html) - 1 to 3',
            "29.\x{a0}\x{a0}(1 to |3)
Solution: 1, 2, 3, 1, 2, 3, 1, 2, 3, \x{2026}. The expression |3 produces 3, 3, 3, \x{2026}, so the repeated alternation is equivalent to (<<1 to 3|10a:0>>) | (<<1 to 3|10a:0>>) | (<<1 to 3|10a:0>>)\x{2026}. Note that (1 to |3) is equivalent to |(<<1 to 3|10a:0>>).",
          ],
          [
            1,
            '[ap 02:59] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (382-386.html) - 1 to 3',
            "30.\x{a0}\x{a0}!12 to 3
Solution: 1, 2, 3, 2, 3. The expression !12 has the sequence \x{201c}1\x{201d}, \x{201c}2\x{201d}. Therefore !12 to 3 is equivalent to (\x{201c}1\x{201d} | \x{201c}2\x{201d}) to 3, which is equivalent to ((1 | 2) to 3), which is equivalent to (<<1 to 3|10a:0>>) | (<<2 to 3|10a:0>>).",
          ],
          [
            1,
            '[00:00] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (386-389.html) - midnight',
            "38.\x{a0}\x{a0}A sequence consisting of strings representing the times in minutes in the 24-hour day, starting at <<midnight|9g>> and ending at the minute <<before midnight|13>>: \x{201c}<<00:00|2>>\x{201d}, \x{201c}<<00:01|2>>\x{201d}, \x{2026} \x{201c}<<00:59|2>>\x{201d}, \x{201c}<<01:00|2>>\x{201d}, \x{2026} \x{201c}<<23:59|2>>\x{201d}.
Solution: The solution to this problem has two components: a generator for the hours and a generator for the minutes. <<0 to 23|10a:1>> generates the hours, and 0 to 59 generates the minutes, but the values need to be padded with zeros:
    right(<<0 to 23|10a:1>>, 2, \x{201c}0\x{201d})
    right(0 to 59, 2, \x{201c}0\x{201d})",
          ],
          [
            1,
            '[23:00] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (386-389.html) - 0 to 23',
            "All that remains is a concatenation with colons added as separators:
   right(<<0 to 23|10a:0>>, 2, \x{201c}0\x{201d}) || \x{201c}:\x{201d} ||
      right(0 to 59, 2, \x{201c}0\x{201d})",
          ],
          [
            1,
            '[ap 11:21] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (418-420.html) - 11:21',
            "Farber, D. J., R. E. Griswold, and I. P. Polonsky. 1964. SNOBOL, a string manipulation language. Journal of the ACM, <<11:21|2>>\x{2013}30.",
          ],
          [
            1,
            '[ap 05:25] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (418-420.html) - 5:25',
            "Yngve, V. H. 1958. A programming language for mechanical translation. Mechanical Translation <<5:25|2>>\x{2013}41.",
          ],
          [
            1,
            '[20:00] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (about_split_001.html) - 1960',
            'Just over 40 years ago there were no programming languages. In 1954 programming was still a function of hardware. Fortran was invented in 1957. It was soon being taught. By <<1960|9:0>>, not only had COBOL and Lisp joined the roster, but so had others, many now thankfully forgotten. Over the past 40 years, nearly 4,000 computer languages have been produced. Only a tithe of these are in use today, but the growth and development of them has been progressive and organic.',
          ],
          [
            1,
            '[13:14] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (book-index_split_001.html) - 13-14',
            'parameters, 37
special, <<13-14|5a:0>>
string length, 37',
          ],
          [
            1,
            '[21:24] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (book-index_split_001.html) - 21-24',
            'flow control
C, 129-135
Fortran 95, <<21-24|5a:0>>
Icon, 333-334',
          ],
          [
            1,
            '[13:14] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (book-index_split_001.html) - 13-14',
            'parameters, 37
special, <<13-14|5a:0>>
string length, 37',
          ],
          [
            1,
            '[21:24] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (book-index_split_001.html) - 21-24',
            'extensibility, 7
flow control, <<21-24|5a:0>>
functions, 28
arguments, 28-29',
          ],
          [
            1,
            '[ap 10:11] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (book-index_split_001.html) - 10-11',
            'shape, 32
HFP extensions, <<10-11|5a:0>>
legacy code, 7',
          ],
          [
            1,
            '[ap 00:14] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (book-index_split_001.html) - 12-14',
            'programs
example, 12
form, <<12-14|5a:0>>
record files, 52
accessing, 53',
          ],
          [
            1,
            '[ap 09:10] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (book-index_split_001.html) - 9-10',
            'unformatted, 51
standards, 7-8
permissiveness of, <<9-10|5a:0>>
portability, 9',
          ],
          [
            1,
            '[22:23] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (book-index_split_001.html) - 22-23',
            'I/O statements, 51
if, <<22-23|5a:0>>
inquire, 55',
          ],
          [
            1,
            '[ap 10:11] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (book-index_split_001.html) - 10-11',
            'Hello World program (C), 87
HFP extensions (Fortran 95), <<10-11|5a:0>>
Highvideo procedure (Turbo Pascal), 308',
          ],
          [
            1,
            '[22:23] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (book-index_split_001.html) - 22-23',
            'If statement
C, 125-128
Fortran 95, <<22-23|5a:0>>
Turbo Pascal, 262',
          ],
          [
            1,
            '[ap 00:14] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (book-index_split_001.html) - 12-14',
            'Fortran 95
example, 12
form, <<12-14|5a:0>>
Icon
command-line arguments, 374-375',
          ],
          [
            1,
            '[13:14] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (book-index_split_001.html) - 13-14',
            'Icon programs, 373
special characters (Fortran 95), <<13-14|5a:0>>
Sprintf function (C), 197',
          ],
          [
            1,
            '[ap 09:10] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (book-index_split_001.html) - 9-10',
            'Fortran, 4-6
Fortran 95, 7-8
permissiveness of, <<9-10|5a:0>>
portability, 9',
          ],
          [
            1,
            '[22:23] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (book-index_split_001.html) - 22-23',
            'I/O statements, 51
if, <<22-23|5a:0>>
keywords, 12',
          ],
          [
            1,
            '[ap 03:10] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (ewtoc.html) - 3.10',
            '3.9.2. Exit Status
<<3.10|5a:0>>. The Standard C Library
3.10.1. <stdio.h>
3.10.2. <string.h>',
          ],
          [
            1,
            '[ap 03:11] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (ewtoc.html) - 3.11',
            '3.10.18. <wctype.h>
<<3.11|5a:0>>. Acknowledgments
<<3.12|5a:0>>. Bibliography',
          ],
          [
            1,
            '[ap 03:11] Handbook of Programming Languages Volume 2 - Peter H. Salus.epub (ewtoc.html) - 3.11',
            '<<3.11|9p>>. Acknowledgments
<<3.12|5a:0>>. Bibliography
',
          ],
        ];
