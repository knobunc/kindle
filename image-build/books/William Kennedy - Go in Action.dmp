$VAR1 = [
          [
            1,
            '[ap 02:10] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.10',
            "The log package provides support for logging messages to the stdout, stderr, or even custom devices. The sync package provides support for synchronizing goroutines, which is required by our program. On line 09 you\x{2019}ll see our first variable declaration.
Listing <<2.10|5a:0>>. search/search.go: lines 08\x{2013}09
08 // A map of registered matchers for searching.
09 var matchers = make(map[string]Matcher)",
          ],
          [
            1,
            '[ap 02:11] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.11',
            'This variable declaration also contains an initialization of the variable via the assignment operator and a special built-in function called make.
Listing <<2.11|5a:0>>. Making a map
make(map[string]Matcher)',
          ],
          [
            1,
            '[ap 02:12] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.12',
            "Now let\x{2019}s walk through the Run function that\x{2019}s called by the main function, which you saw earlier.
Listing <<2.12|5a:0>>. search/search.go: lines 11\x{2013}57
11 // Run performs the search logic.
12 func Run(searchTerm string) {
13     // Retrieve the list of feeds to search through.
14     feeds, err := RetrieveFeeds()
15     if err != nil {
16         log.Fatal(err)
17     }
18
19     // Create a unbuffered channel to receive match results.
20     results := make(chan *Result)
21
22     // Setup a wait group so we can process all the feeds.
23     var waitGroup sync.WaitGroup
24
25     // Set the number of goroutines we need to wait for while",
          ],
          [
            1,
            '[ap 02:13] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.13',
            "Let\x{2019}s review how the Run function is declared.
Listing <<2.13|5a:0>>. search/search.go: lines 11\x{2013}12
11 // Run performs the search logic.
12 func Run(searchTerm string) {",
          ],
          [
            1,
            '[ap 02:14] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.14',
            "To declare a function in Go, use the keyword func followed by the function name, any parameters, and then any return values. In the case of Run, you have a single parameter called searchTerm of type string. The term the program will search against is passed into the Run function, and if you look at the main function again, you can see that exchange.
Listing <<2.14|5a:0>>. main.go: lines 17\x{2013}21
17 // main is the entry point for the program.
18 func main() {
19     // Perform the search for the specified term.
20     search.Run(\"president\")
21 }",
          ],
          [
            1,
            '[ap 02:15] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.15',
            "The first thing that the Run function does is retrieve a list of data feeds. These feeds are used to pull content from the internet that is then matched against the specified search term.
Listing <<2.15|5a:0>>. search/search.go: lines 13\x{2013}17
13     // Retrieve the list of feeds to search through.
14     feeds, err := RetrieveFeeds()
15     if err != nil {
16         log.Fatal(err)
17     }",
          ],
          [
            1,
            '[ap 02:16] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.16',
            "Let\x{2019}s take a closer look at how the values being returned from the function are being assigned to variables.
Listing <<2.16|5a:0>>. search/search.go: lines 13\x{2013}14
13     // Retrieve the list of feeds to search through.
14     feeds, err := RetrieveFeeds()",
          ],
          [
            1,
            '[ap 02:17] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.17',
            "Now that we have our list of data feeds, we can move on to the next line of code.
Listing <<2.17|5a:0>>. search/search.go: lines 19\x{2013}20
19     // Create a unbuffered channel to receive match results.
20     results := make(chan *Result)",
          ],
          [
            1,
            '[ap 02:18] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.18',
            "The next two lines of code are used later to prevent the program from terminating before all the search processing is complete.
Listing <<2.18|5a:0>>. search/search.go: lines 22\x{2013}27
22     // Setup a wait group so we can process all the feeds.
23     var waitGroup sync.WaitGroup
24
25     // Set the number of goroutines we need to wait for while
26     // they process the individual feeds.
27     waitGroup.Add(len(feeds))",
          ],
          [
            1,
            '[ap 02:19] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.19',
            "Next let\x{2019}s look at the code that launches these goroutines for each feed.
Listing <<2.19|5a:0>>. search/search.go: lines 29\x{2013}42
29     // Launch a goroutine for each feed to find the results.
30     for _, feed := range feeds {
31         // Retrieve a matcher for the search.
32         matcher, exists := matchers[feed.Type]
33         if !exists {
34             matcher = matchers[\"default\"]
35         }
36
37         // Launch the goroutine to perform the search.
38         go func(matcher Matcher, feed *Feed) {
39             Match(matcher, feed, searchTerm, results)
40             waitGroup.Done()
41         }(matcher, feed)
42     }",
          ],
          [
            1,
            '[ap 02:20] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.20',
            "If you look closer at the for range statement on line 30, you\x{2019}ll see the use of the blank identifier again.
Listing <<2.20|5a:0>>. search/search.go: lines 29\x{2013}30
29     // Launch a goroutine for each feed to find the results.
30     for _, feed := range feeds {",
          ],
          [
            1,
            '[ap 02:21] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.21',
            "The first thing we do in the loop is check the map for a Matcher value that can be used to process a feed of the specific feed type.
Listing <<2.21|5a:0>>. search/search.go: lines 31\x{2013}35
31         // Retrieve a matcher for the search.
32         matcher, exists := matchers[feed.Type]",
          ],
          [
            1,
            '[ap 02:22] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.22',
            "On line 33 we check whether the key was located in the map, and if it\x{2019}s not, we assign the default matcher to be used. This allows the program to function without causing any issues or interruption for feeds that the program currently doesn\x{2019}t support. Then we launch a goroutine to perform the search.
Listing <<2.22|5a:0>>. search/search.go: lines 37\x{2013}41
37         // Launch the goroutine to perform the search.
38         go func(matcher Matcher, feed *Feed) {
39             Match(matcher, feed, searchTerm, results)
40             waitGroup.Done()
41         }(matcher, feed)",
          ],
          [
            1,
            '[ap 02:23] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.23',
            "On lines 39 and 40 you see the work each goroutine is performing.
Listing <<2.23|5a:0>>. search/search.go: lines 39\x{2013}40
39             Match(matcher, feed, searchTerm, results)
40             waitGroup.Done()",
          ],
          [
            1,
            '[ap 02:24] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.24',
            "Go supports closures and you\x{2019}re seeing this in action. In fact, the searchTerm and results variables are also being accessed by the anonymous function via closures. Thanks to closures, the function can access those variables directly without the need to pass them in as parameters. The anonymous function isn\x{2019}t given a copy of these variables; it has direct access to the same variables declared in the scope of the outer function. This is the reason why we don\x{2019}t use closures for the matcher and feed variables.
Listing <<2.24|5a:0>>. search/search.go: lines 29\x{2013}32
29     // Launch a goroutine for each feed to find the results.
30     for _, feed := range feeds {
31         // Retrieve a matcher for the search.
32         matcher, exists := matchers[feed.Type]",
          ],
          [
            1,
            '[ap 02:25] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.25',
            "With all the search goroutines working, sending results on the results channel and decrementing the waitGroup counter, we need a way to display those results and keep the main function alive until all the processing is done.
Listing <<2.25|5a:0>>. search/search.go: lines 44\x{2013}57
44     // Launch a goroutine to monitor when all the work is done.
45     go func() {
46         // Wait for everything to be processed.",
          ],
          [
            1,
            '[ap 02:26] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.26',
            "Now that you\x{2019}ve seen the Run function, let\x{2019}s look at the code behind the function call to RetrieveFeeds on line 14 of the search.go code file. This function reads the data.json file and returns the slice of data feeds. These feeds drive the content that will be searched by the different matchers. Here are the first eight lines of code that can be found inside the feed.go code file.
Listing <<2.26|5a:0>>. feed.go: lines 01\x{2013}08
01 package search
02
03 import (
04     \"encoding/json\"
05     \"os\"
06 )
07
08 const dataFile = \"data/data.json\"",
          ],
          [
            1,
            '[ap 02:27] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.27',
            "Next let\x{2019}s look at a portion of the data.json data file.
Listing <<2.27|5a:0>>. data.json
[
    {
        \"site\" : \"npr\",
        \"link\" : \"http://www.npr.org/rss/rss.php?id=1001\",
        \"type\" : \"rss\"
    },
    {
        \"site\" : \"cnn\",
        \"link\" : \"http://rss.cnn.com/rss/cnn_world.rss\",
        \"type\" : \"rss\"
    },
    {
        \"site\" : \"foxnews\",
        \"link\" : \"http://feeds.foxnews.com/foxnews/world?format=xml\",
        \"type\" : \"rss\"
    },
    {
        \"site\" : \"nbcnews\",
        \"link\" : \"http://feeds.nbcnews.com/feeds/topstories\",
        \"type\" : \"rss\"
    }
]",
          ],
          [
            1,
            '[ap 02:27] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.27',
            "The actual data file contains more than four data feeds, but listing <<2.27|5a:0>> shows a valid version of the data file. The data file contains an array of JSON documents. Each document in the data file provides a name of the site we\x{2019}re getting the data from, a link to the data, and the type of data we expect to receive.",
          ],
          [
            1,
            '[ap 02:28] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.28',
            "These documents need to be decoded into a slice of struct types so we can use this data in our program. Let\x{2019}s look at the struct type that will be used to decode this data file.
Listing <<2.28|5a:0>>. feed.go: lines 10\x{2013}15
10 // Feed contains information we need to process a feed.
11 type Feed struct {
12     Name string `json:\"site\"`",
          ],
          [
            1,
            '[ap 02:29] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.29',
            "Now we can review the RetrieveFeeds function that we called on line 14 in the search.go code file. This is the function that reads the data file and decodes every document into a slice of Feed type values.
Listing <<2.29|5a:0>>. feed.go: lines 17\x{2013}36
17 // RetrieveFeeds reads and unmarshals the feed data file.
18 func RetrieveFeeds() ([]*Feed, error) {
19    // Open the file.
20    file, err := os.Open(dataFile)
21    if err != nil {
22        return nil, err
23    }
24
25    // Schedule the file to be closed once
26    // the function returns.
27    defer file.Close()
28
29    // Decode the file into a slice of pointers
30    // to Feed values.
31    var feeds []*Feed
32    err = json.NewDecoder(file).Decode(&feeds)
33
34    // We don't need to check for errors, the caller can do this.
35    return feeds, err
36 }",
          ],
          [
            1,
            '[ap 02:30] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.30',
            "If we\x{2019}re successful in opening the file, we then move to line 27. Here you see the use of the keyword defer.
Listing <<2.30|5a:0>>. feed.go: lines 25\x{2013}27
25    // Schedule the file to be closed once
26    // the function returns.
27    defer file.Close()",
          ],
          [
            1,
            '[ap 02:31] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.31',
            "Now we can review the final lines of code in the function. Let\x{2019}s look at lines 31 through 35.
Listing <<2.31|5a:0>>. feed.go: lines 29\x{2013}36
29    // Decode the file into a slice of pointers
30    // to Feed values.
31    var feeds []*Feed
32    err = json.NewDecoder(file).Decode(&feeds)
33
34    // We don't need to check for errors, the caller can do this.
35    return feeds, err
36 }",
          ],
          [
            1,
            '[ap 02:32] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.32',
            'The Decode method can accept any type of value thanks to its declaration.
Listing <<2.32|5a:0>>. Using the empty interface
func (dec *Decoder) Decode(v interface{}) error',
          ],
          [
            1,
            '[ap 02:33] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.33',
            "The match.go code file contains the support for creating different types of matchers that can be used by the search Run function. Let\x{2019}s go back and look at the code from the Run function that executes the search using the different types of matchers.
Listing <<2.33|5a:0>>. search/search.go : lines 29 - 42
29     // Launch a goroutine for each feed to find the results.
30     for _, feed := range feeds {
31         // Retrieve a matcher for the search.
32         matcher, exists := matchers[feed.Type]
33         if !exists {
34             matcher = matchers[\"default\"]
35         }
36
37         // Launch the goroutine to perform the search.
38         go func(matcher Matcher, feed *Feed) {
39             Match(matcher, feed, searchTerm, results)
40             waitGroup.Done()
41         }(matcher, feed)
42     }",
          ],
          [
            1,
            '[ap 02:34] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.34',
            "Here are the first 17 lines of code for match.go.
Listing <<2.34|5a:0>>. search/match.go: lines 01\x{2013}17
01 package search
02
03 import (
04     \"log\"
05 )
06
07 // Result contains the result of a search.
08 type Result struct {
09     Field   string
10     Content string
11 }
12",
          ],
          [
            1,
            '[ap 02:35] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.35',
            "For a user-defined type to implement an interface, the type in question needs to implement all the methods that are declared within that interface type. Let\x{2019}s switch to the default.go code file and see how the default matcher implements the Matcher interface.
Listing <<2.35|5a:0>>. search/default.go: lines 01\x{2013}15
01 package search
02
03 // defaultMatcher implements the default matcher.
04 type defaultMatcher struct{}
05
06 // init registers the default matcher with the program.
07 func init() {
08     var matcher defaultMatcher
09     Register(\"default\", matcher)
10 }
11
12 // Search implements the behavior for the default matcher.
13 func (m defaultMatcher) Search(feed *Feed, searchTerm string)
                                                   ([]*Result, error) {
14     return nil, nil
15 }",
          ],
          [
            1,
            '[ap 02:36] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.36',
            'The declaration of the Search method is declared with a value receiver of type defaultMatcher.
Listing <<2.36|5a:0>>. search/default.go: line 13
13 func (m defaultMatcher) Search',
          ],
          [
            1,
            '[ap 02:37] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.37',
            "The use of a receiver with any function declaration declares a method that\x{2019}s bound to the specified receiver type. In our case, the declaration of the Search method is now bound to values of type defaultMatcher. This means we can call the method Search from values and pointers of type defaultMatcher. Whether we use a value or pointer of the receiver type to make the method call, the compiler will reference or dereference the value if necessary to support the call.
Listing <<2.37|5a:0>>. Example of method calls
// Method declared with a value receiver of type defaultMatcher
func (m defaultMatcher) Search(feed *Feed, searchTerm string)",
          ],
          [
            1,
            '[ap 02:38] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.38',
            'Unlike when you call methods directly from values and pointers, when you call a method via an interface type value, the rules are different. Methods declared with pointer receivers can only be called by interface type values that contain pointers. Methods declared with value receivers can be called by interface type values that contain both values and pointers.
Listing <<2.38|5a:0>>. Example of interface method call restrictions
// Method declared with a pointer receiver of type defaultMatcher
func (m *defaultMatcher) Search(feed *Feed, searchTerm string)',
          ],
          [
            1,
            '[ap 02:39] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.39',
            "Let\x{2019}s look at the implementation of the Match function declared in the match.go code file. This is the function called by the Run function on line 39 in the search.go code file.
Listing <<2.39|5a:0>>. search/match.go: lines 19\x{2013}33
19 // Match is launched as a goroutine for each individual feed to run
20 // searches concurrently.
21 func Match(matcher Matcher, feed *Feed, searchTerm string,
                                              results chan<- *Result) {
22     // Perform the search against the specified matcher.
23     searchResults, err := matcher.Search(feed, searchTerm)
24     if err != nil {
25         log.Println(err)
26         return
27     }
28
29     // Write the results to the channel.
30     for _, result := range searchResults {
31         results <- result
32     }
33 }",
          ],
          [
            1,
            '[ap 02:40] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.40',
            "The final piece of code in match.go is the Display function that\x{2019}s called by the main function on line 56. This is the function preventing the program from terminating until all the results from the search goroutines are received and logged.
Listing <<2.40|5a:0>>. search/match.go: lines 35\x{2013}43
35 // Display writes results to the terminal window as they
36 // are received by the individual goroutines.
37 func Display(results chan *Result) {
38     // The channel blocks until a result is written to the channel.
39     // Once the channel is closed the for loop terminates.
40     for result := range results {
41         fmt.Printf(\"%s:\\n%s\\n\\n\", result.Field, result.Content)
42     }
43 }",
          ],
          [
            1,
            '[ap 02:41] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.41',
            "A bit of channel magic allows this function to process all of the results before returning. It\x{2019}s based on how channels and the keyword range behaves when a channel is closed. Let\x{2019}s briefly look at the code in the Run function again that closes the results channel and calls the Display function.
Listing <<2.41|5a:0>>. search/search.go: lines 44\x{2013}57
44     // Launch a goroutine to monitor when all the work is done.
45     go func() {
46         // Wait for everything to be processed.
47         waitGroup.Wait()
48
49         // Close the channel to signal to the Display
50         // function that we can exit the program.
51         close(results)
52     }()
53
54     // Start displaying results as they are available and
55     // return after the final result is displayed.
56     Display(results)
57 }",
          ],
          [
            1,
            '[ap 02:42] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.42',
            "You saw on lines 30 through 32 in the match.go code file where the search results were being written to the channel.
Listing <<2.42|5a:0>>. search/match.go: lines 29\x{2013}32
29     // Write the results to the channel.
30     for _, result := range searchResults {
31         results <- result
32     }",
          ],
          [
            1,
            '[ap 02:43] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.43',
            "If we look back at the for range loop on lines 40 through 42 of the match.go code file, we can connect the writing of the results, the closing of the channel, and the processing of results all together.
Listing <<2.43|5a:0>>. search/match.go: lines 38\x{2013}42
38     // The channel blocks until a result is written to the channel.
39     // Once the channel is closed the for loop terminates.
40     for result := range results {
41         log.Printf(\"%s:\\n%s\\n\\n\", result.Field, result.Content)
42     }",
          ],
          [
            1,
            '[ap 02:44] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.44',
            "Before we look at the implementation of the RSS matcher, let\x{2019}s review how the different matchers are initialized when the program starts. To see this we need to look back at lines 07 through 10 of the default.go code file.
Listing <<2.44|5a:0>>. search/default.go: lines 06\x{2013}10
06 // init registers the default matcher with the program.
07 func init() {
08     var matcher defaultMatcher
09     Register(\"default\", matcher)
10 }",
          ],
          [
            1,
            '[ap 02:45] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.45',
            "The default.go code file has a special function declared called init. You saw this function also declared in the main.go code file, and we talked about how all the init functions in the program would be called before the main function begins. Let\x{2019}s look at the imports again from the main.go code file.
Listing <<2.45|5a:0>>. main.go: lines 07\x{2013}08
07   _ \"github.com/goinaction/code/chapter2/sample/matchers\"
08    \"github.com/goinaction/code/chapter2/sample/search\"",
          ],
          [
            1,
            '[ap 02:46] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.46',
            "The init function in the default.go code file is performing a special task. It\x{2019}s creating a value of the defaultMatcher type and passing that value to the Register function that can be found in the search.go code file.
Listing <<2.46|5a:0>>. search/search.go: lines 59\x{2013}67
59 // Register is called to register a matcher for use by the program.
60 func Register(feedType string, matcher Matcher) {
61     if _, exists := matchers[feedType]; exists {
62         log.Fatalln(feedType, \"Matcher already registered\")
63     }
64
65     log.Println(\"Register\", feedType, \"matcher\")
66     matchers[feedType] = matcher
67 }",
          ],
          [
            1,
            '[ap 02:47] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.47',
            "The RSS document in listing <<2.47|5a:0>> shows you a sample of what we expect to receive when we use any link in the data feed that\x{2019}s typed as an RSS feed.",
          ],
          [
            1,
            '[ap 02:47] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.47',
            "The RSS document in listing <<2.47|5a:0>> shows you a sample of what we expect to receive when we use any link in the data feed that\x{2019}s typed as an RSS feed.
Listing <<2.47|5a:0>>. Expected RSS feed document
<rss xmlns:npr=\"http://www.npr.org/rss/\" xmlns:nprml=\"http://api
    <channel>
        <title>News</title>
        <link>...</link>
        <description>...</description>",
          ],
          [
            1,
            '[ap 02:47] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.47',
            "If you take any link from listing <<2.47|5a:0>> and put it in a browser, you\x{2019}ll be able to see a complete view of the expected RSS document. The implementation of the RSS matcher pulls down these RSS documents, searches the title and description fields for the search term, and sends the results over the results channel. Let\x{2019}s start by looking at the first 12 lines of code for the rss.go code file.",
          ],
          [
            1,
            '[ap 02:47] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.47',
            "If you take any link from listing <<2.47|5a:0>> and put it in a browser, you\x{2019}ll be able to see a complete view of the expected RSS document. The implementation of the RSS matcher pulls down these RSS documents, searches the title and description fields for the search term, and sends the results over the results channel. Let\x{2019}s start by looking at the first 12 lines of code for the rss.go code file.
Listing <<2.48|5a:0>>. matchers/rss.go: lines 01\x{2013}12
01 package matchers
02
03 import (
04     \"encoding/xml\"
05     \"errors\"
06     \"fmt\"
07     \"log\"
08     \"net/http\"
09     \"regexp\"
10
11     \"github.com/goinaction/code/chapter2/sample/search\"
12 )",
          ],
          [
            1,
            '[ap 02:49] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.49',
            "There are four struct types that are used to decode the RSS document, so we can use the document data in our program.
Listing <<2.49|5a:0>>. matchers/rss.go: lines 14\x{2013}58
14 type (
15     // item defines the fields associated with the item tag
16     // in the rss document.
17     item struct {
18         XMLName     xml.Name `xml:\"item\"`
19         PubDate     string   `xml:\"pubDate\"`
20         Title       string   `xml:\"title\"`
21         Description string   `xml:\"description\"`",
          ],
          [
            1,
            '[ap 02:50] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.50',
            "If you match these structures to the RSS document from any of the feed links, you\x{2019}ll see how everything correlates. Decoding XML is identical to how we decoded JSON in the feed.go code file. Next we can look at the declaration of the rssMatcher type.
Listing <<2.50|5a:0>>. matchers/rss.go: lines 60\x{2013}61
60 // rssMatcher implements the Matcher interface.
61 type rssMatcher struct{}",
          ],
          [
            1,
            '[ap 02:51] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.51',
            "Again, this looks just like how we declared the defaultMatcher type. We use an empty struct since we don\x{2019}t need to maintain any state; we just implement the Matcher interface. Next we have the implementation of the matcher init function.
Listing <<2.51|5a:0>>. matchers/rss.go: lines 63\x{2013}67
63 // init registers the matcher with the program.
64 func init() {
65     var matcher rssMatcher
66     search.Register(\"rss\", matcher)
67 }",
          ],
          [
            1,
            '[ap 02:52] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.52',
            "Just like you saw with the default matcher, the init function registers a value of the rssMatcher type with the program for use. Let\x{2019}s look at the import in the main.go code file once more.
Listing <<2.52|5a:0>>. main.go: lines 07\x{2013}08
07   _ \"github.com/goinaction/code/chapter2/sample/matchers\"
08    \"github.com/goinaction/code/chapter2/sample/search\"",
          ],
          [
            1,
            '[ap 02:53] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.53',
            "The code in the main.go code file doesn\x{2019}t directly use any identifiers from the matchers package. Yet we need the compiler to schedule the call to the init function in the rss.go code file. On line 07 we accomplish this by using the blank identifier as the alias name for the import. This allows the compiler to not produce an error for declaring the import and to locate the init function. With all of the imports, types, and initialization set, let\x{2019}s look at the two remaining methods that support the implementation of the Matcher interface.
Listing <<2.53|5a:0>>. matchers/rss.go: lines 114\x{2013}140
114 // retrieve performs a HTTP Get request for the rss feed and decodes
115 func (m rssMatcher) retrieve(feed *search.Feed)
                                                 (*rssDocument, error) {
116     if feed.URI == \"\" {
117         return nil, errors.New(\"No rss feed URI provided\")
118     }
119
120     // Retrieve the rss feed document from the web.
121     resp, err := http.Get(feed.URI)
122     if err != nil {
123         return nil, err
124     }
125
126     // Close the response once we return from the function.
127     defer resp.Body.Close()
128
129     // Check the status code for a 200 so we know we have received a
130     // proper response.
131     if resp.StatusCode != 200 {
132         return nil, fmt.Errorf(\"HTTP Response Error %d\\n\",
                                                        resp.StatusCode)
133     }
134
135     // Decode the rss feed document into our struct type.",
          ],
          [
            1,
            '[ap 02:54] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.54',
            "The final method to look at implements the Matcher interface.
Listing <<2.54|5a:0>>. matchers/rss.go: lines 69\x{2013}112
 69 // Search looks at the document for the specified search term.
 70 func (m rssMatcher) Search(feed *search.Feed, searchTerm string)
                                            ([]*search.Result, error) {
 71     var results []*search.Result
 72
 73     log.Printf(\"Search Feed Type[%s] Site[%s] For Uri[%s]\\n\",
                                        feed.Type, feed.Name, feed.URI)
 74
 75     // Retrieve the data to search.
 76     document, err := m.retrieve(feed)
 77     if err != nil {
 78         return nil, err
 79     }
 80
 81     for _, channelItem := range document.Channel.Item {
 82         // Check the title for the search term.
 83         matched, err := regexp.MatchString(searchTerm,
                                                     channelItem.Title)
 84         if err != nil {
 85             return nil, err
 86         }
 87
 88         // If we found a match save the result.
 89         if matched {
 90            results = append(results, &search.Result{
 91                Field:   \"Title\",
 92                Content: channelItem.Title,",
          ],
          [
            1,
            '[ap 02:55] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.55',
            'We start on line 71 with the declaration of the results variable, which will be used to store and return any results that may be found.
Listing <<2.55|5a:0>>. matchers/rss.go: line 71
71      var results []*search.Result',
          ],
          [
            1,
            '[ap 02:56] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.56',
            "We use the keyword var and declare a nil slice of pointers to Result type values. The declaration of the Result type can be found again on line 08 of the match.go code file. Next on line 76 we make a web call using the retrieve method we just reviewed.
Listing <<2.56|5a:0>>. matchers/rss.go: lines 75\x{2013}79
75      // Retrieve the data to search.
76      document, err := m.retrieve(feed)
77      if err != nil {
78          return nil, err
79      }",
          ],
          [
            1,
            '[ap 02:57] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.57',
            "The call to the retrieve method returns a pointer to a value of type rssDocument and an error value. Then, as you\x{2019}ve seen throughout the code, we check the error value for errors and return if there was an error. If no error exists, we then iterate through the results performing the match of the search term against the title and description of the retrieved RSS document.
Listing <<2.57|5a:0>>. matchers/rss.go: lines 81\x{2013}86
81      for _, channelItem := range document.Channel.Item {
82          // Check the title for the search term.
83          matched, err := regexp.MatchString(searchTerm,
                                                      channelItem.Title)",
          ],
          [
            1,
            '[ap 02:58] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.58',
            "Since the value of document.Channel.Item is a slice of item type values, we use a for range loop on line 81 to iterate through all the items. On line 83 we use the MatchString function from the regexp package to match the search term against the content in the Title field of the channelItem value. Then we check for errors on line 84. If there are no errors, we move to lines 89 through 94 to check the results of the match.
Listing <<2.58|5a:0>>. matchers/rss.go: lines 88\x{2013}94
88          // If we found a match save the result.
89          if matched {
90             results = append(results, &search.Result{
91                 Field:   \"Title\",
92                 Content: channelItem.Title,
93             })
94          }",
          ],
          [
            1,
            '[ap 03:14] Go in Action - William Kennedy.epub (kindle_split_011.html) - 3.14',
            '01 package main
02
03 import "fmt"
04
05 func main() {
06     fmt.Printf("The quick brown fox jumped over lazy dogs", <<3.14|5a:0>>)
07 }',
          ],
          [
            1,
            '[ap 03:10] Go in Action - William Kennedy.epub (kindle_split_011.html) - 3.10',
            "Next, if you look at the import statements that are declared inside of main.go for these dependencies, you\x{2019}ll see that some things needed to change.
Listing <<3.10|5a:0>>. Before vendoring
01 package main
02
03 import (
04     \"bitbucket.org/ww/goautoneg\"
05     \"github.com/beorn7/perks\"
06 )",
          ],
          [
            1,
            '[ap 03:11] Go in Action - William Kennedy.epub (kindle_split_011.html) - 3.11',
            '01 package main
02
03 import (
04     "bitbucket.org/ww/goautoneg"
05     "github.com/beorn7/perks"
06 )
Listing <<3.11|5a:0>>. After vendoring
01 package main
02
03 import (
04     "github.ardanstudios.com/myproject/Godeps/_workspace/src/
                                             bitbucket.org/ww/goautoneg"
05     "github.ardanstudios.com/myproject/Godeps/_workspace/src/
                                                github.com/beorn7/perks"
06 )',
          ],
          [
            1,
            '[ap 03:12] Go in Action - William Kennedy.epub (kindle_split_011.html) - 3.12',
            "Let\x{2019}s look at how the last project could be converted into a gb project.
Listing <<3.12|5a:0>>. Example of a gb project
/home/bill/devel/myproject (\$PROJECT)
|-- src
|   |-- cmd
|   |   |-- myproject
|   |   |   |-- main.go
|   |-- examples
|   |-- model
|   |-- README.md
|-- vendor
    |-- src
        |-- bitbucket.org
        |   |-- ww
        |       |-- goautoneg
        |       |-- Makefile
        |       |-- README.txt
        |       |-- autoneg.go
        |       |-- autoneg_test.go
        |-- github.com
            |-- beorn7
                |-- perks
                |-- README.md
                |-- quantile
                |-- bench_test.go
        |-- example_test.go
        |-- exampledata.txt
        |-- stream.go",
          ],
          [
            1,
            '[ap 03:13] Go in Action - William Kennedy.epub (kindle_split_011.html) - 3.13',
            'Gb projects differentiate between the code you write and the code your code depends on. The code your code depends on is called vendored code. A gb project makes a clear distinction between your code and vendored code.
Listing <<3.13|5a:0>>. The location for the code you write for the project
$PROJECT/src/',
          ],
          [
            1,
            '[ap 03:14] Go in Action - William Kennedy.epub (kindle_split_011.html) - 3.14',
            '$PROJECT/src/
Listing <<3.14|5a:0>>. The location of vendored code
$PROJECT/vendor/src/',
          ],
          [
            1,
            '[ap 03:15] Go in Action - William Kennedy.epub (kindle_split_011.html) - 3.15',
            "One of the best things about gb is that there\x{2019}s no need for import path rewriting. Look at the import statements that are declared inside of main.go\x{2014}nothing needs to change to reference the vendored dependencies.
Listing <<3.15|5a:0>>. Import paths for gb projects
01 package main
02
03 import (
04     \"bitbucket.org/ww/goautoneg\"
05     \"github.com/beorn7/perks\"
06 )",
          ],
          [
            1,
            '[ap 03:16] Go in Action - William Kennedy.epub (kindle_split_011.html) - 3.16',
            "One thing to note: a gb project is not compatible with the Go tooling, including go get. Since there\x{2019}s no need for GOPATH, and the Go tooling doesn\x{2019}t understand the structure of a gb project, it can\x{2019}t be used to build, test, or get. Building and testing a gb project requires navigating to the \$PROJECT directory and using the gb tool.
Listing <<3.16|5a:0>>. Building a gb project
gb build all",
          ],
          [
            1,
            '[ap 04:10] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.10',
            'Arrays are always one-dimensional, but they can be composed to create multidimensional arrays. Multidimensional arrays come in handy when you need to manage data that may have parent/child relationships or is associated with a coordinate system.
Listing <<4.10|5a:0>>. Declaring two-dimensional arrays
// Declare a two dimensional integer array of four elements
// by two elements.
var array [4][2]int',
          ],
          [
            1,
            '[ap 04:11] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.11',
            'To access an individual element, use the [ ] operator again and a bit of composition.
Listing <<4.11|5a:0>>. Accessing elements of a two-dimensional array
// Declare a two dimensional integer array of two elements.
var array [2][2]int',
          ],
          [
            1,
            '[ap 04:12] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.12',
            'You can copy multidimensional arrays into each other as long as they have the same type. The type of a multidimensional array is based on the length of each dimension and the type of data that can be stored in each element.
Listing <<4.12|5a:0>>. Assigning multidimensional arrays of the same type
// Declare two different two dimensional integer arrays.
var array1 [2][2]int
var array2 [2][2]int',
          ],
          [
            1,
            '[ap 04:13] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.13',
            'Because an array is a value, you can copy individual dimensions.
Listing <<4.13|5a:0>>. Assigning multidimensional arrays by index
// Copy index 1 of array1 into a new array of the same type.
var array3 [2]int = array1[1]',
          ],
          [
            1,
            '[ap 04:14] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.14',
            "To see this in action, let\x{2019}s create an array of one million elements of type int. On a 64-bit architecture, this would require eight million bytes, or eight megabytes, of memory. What happens when you declare an array of that size and pass it to a function?
Listing <<4.14|5a:0>>. Passing a large array by value between functions
// Declare an array of 8 megabytes.
var array [1e6]int",
          ],
          [
            1,
            '[ap 04:15] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.15',
            "Every time the function foo is called, eight megabytes of memory has to be allocated on the stack. Then the value of the array, all eight megabytes of memory, has to be copied into that allocation. Go can handle this copy operation, but there\x{2019}s a better and more efficient way of doing this. You can pass a pointer to the array and only copy eight bytes, instead of eight megabytes of memory on the stack.
Listing <<4.15|5a:0>>. Passing a large array by pointer between functions
// Allocate an array of 8 megabytes.
var array [1e6]int",
          ],
          [
            1,
            '[ap 04:16] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.16',
            'One way to create a slice is to use the built-in function make. When you use make, one option you have is to specify the length of the slice.
Listing <<4.16|5a:0>>. Declaring a slice of strings by length
// Create a slice of strings.
// Contains a length and capacity of 5 elements.
slice := make([]string, 5)',
          ],
          [
            1,
            '[ap 04:17] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.17',
            'When you just specify the length, the capacity of the slice is the same. You can also specify the length and capacity separately.
Listing <<4.17|5a:0>>. Declaring a slice of integers by length and capacity
// Create a slice of integers.
// Contains a length of 3 and has a capacity of 5 elements.
slice := make([]int, 3, 5)',
          ],
          [
            1,
            '[ap 04:17] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.17',
            "When you specify the length and capacity separately, you can create a slice with available capacity in the underlying array that you don\x{2019}t have access to initially. Figure 4.9 depicts what the slice of integers declared in listing <<4.17|5a:0>> could look like after it\x{2019}s initialized with some values.",
          ],
          [
            1,
            '[ap 04:17] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.17',
            'The slice in listing <<4.17|5a:0>> has access to three elements, but the underlying array has five elements. The two elements not associated with the length of the slice can be incorporated so the slice can use those elements as well. New slices can also be created to share this same underlying array and use any existing capacity.',
          ],
          [
            1,
            '[ap 04:18] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.18',
            "Trying to create a slice with a capacity that\x{2019}s smaller than the length is not allowed.
Listing <<4.18|5a:0>>. Compiler error setting capacity less than length
// Create a slice of integers.
// Make the length larger than the capacity.
slice := make([]int, 5, 3)",
          ],
          [
            1,
            '[ap 04:19] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.19',
            "An idiomatic way of creating a slice is to use a slice literal. It\x{2019}s similar to creating an array, except you don\x{2019}t specify a value inside of the [ ] operator. The initial length and capacity will be based on the number of elements you initialize.
Listing <<4.19|5a:0>>. Declaring a slice with a slice literal
// Create a slice of strings.
// Contains a length and capacity of 5 elements.
slice := []string{\"Red\", \"Blue\", \"Green\", \"Yellow\", \"Pink\"}",
          ],
          [
            1,
            '[ap 04:20] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.20',
            'When using a slice literal, you can set the initial length and capacity. All you need to do is initialize the index that represents the length and capacity you need. The following syntax will create a slice with a length and capacity of 100 elements.
Listing <<4.20|5a:0>>. Declaring a slice with index positions
// Create a slice of strings.
// Initialize the 100th element with an empty string.
slice := []string{99: ""}',
          ],
          [
            1,
            '[ap 04:21] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.21',
            "Remember, if you specify a value inside the [ ] operator, you\x{2019}re creating an array. If you don\x{2019}t specify a value, you\x{2019}re creating a slice.
Listing <<4.21|5a:0>>. Declaration differences between arrays and slices
// Create an array of three integers.
array := [3]int{10, 20, 30}",
          ],
          [
            1,
            '[ap 04:22] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.22',
            'Sometimes in your programs you may need to declare a nil slice. A nil slice is created by declaring a slice without any initialization.
Listing <<4.22|5a:0>>. Declaring a nil slice
// Create a nil slice of integers.
var slice []int',
          ],
          [
            1,
            '[ap 04:23] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.23',
            'You can also create an empty slice by declaring a slice with initialization.
Listing <<4.23|5a:0>>. Declaring an empty slice
// Use make to create an empty slice of integers.
slice := make([]int, 0)',
          ],
          [
            1,
            '[ap 04:24] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.24',
            'Assigning a value to any specific index within a slice is identical to how you do this with arrays. To change the value of an individual element, use the [ ] operator.
Listing <<4.24|5a:0>>. Declaring an array using an array literal
// Create a slice of integers.
// Contains a length and capacity of 5 elements.
slice := []int{10, 20, 30, 40, 50}',
          ],
          [
            1,
            '[ap 04:25] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.25',
            'Slices are called such because you can slice a portion of the underlying array to create a new slice.
Listing <<4.25|5a:0>>. Taking the slice of a slice
// Create a slice of integers.
// Contains a length and capacity of 5 elements.
slice := []int{10, 20, 30, 40, 50}',
          ],
          [
            1,
            '[ap 04:25] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.25',
            'After the slicing operation performed in listing <<4.25|5a:0>>, we have two slices that are sharing the same underlying array. However, each slice views the underlying array in a different way (see figure 4.12).',
          ],
          [
            1,
            '[ap 04:26] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.26',
            'Calculating the length and capacity for any new slice is performed using the following formula.
Listing <<4.26|5a:0>>. How length and capacity are calculated
For slice[i:j] with an underlying array of capacity k',
          ],
          [
            1,
            '[ap 04:27] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.27',
            'If you apply this formula to newSlice you get the following.
Listing <<4.27|5a:0>>. Calculating the new length and capacity
For slice[1:3] with an underlying array of capacity 5',
          ],
          [
            1,
            '[ap 04:28] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.28',
            'You need to remember that you now have two slices sharing the same underlying array. Changes made to the shared section of the underlying array by one slice can be seen by the other slice.
Listing <<4.28|5a:0>>. Potential consequence of making changes to a slice
// Create a slice of integers.
// Contains a length and capacity of 5 elements.
slice := []int{10, 20, 30, 40, 50}',
          ],
          [
            1,
            '[ap 04:29] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.29',
            "A slice can only access indexes up to its length. Trying to access an element outside of its length will cause a runtime exception. The elements associated with a slice\x{2019}s capacity are only available for growth. They must be incorporated into the slice\x{2019}s length before they can be used.
Listing <<4.29|5a:0>>. Runtime error showing index out of range
// Create a slice of integers.
// Contains a length and capacity of 5 elements.
slice := []int{10, 20, 30, 40, 50}",
          ],
          [
            1,
            '[ap 04:30] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.30',
            'To use append, you need a source slice and a value that is to be appended. When your append call returns, it provides you a new slice with the changes. The append function will always increase the length of the new slice. The capacity, on the other hand, may or may not be affected, depending on the available capacity of the source slice.
Listing <<4.30|5a:0>>. Using append to add an element to a slice
// Create a slice of integers.
// Contains a length and capacity of 5 elements.
slice := []int{10, 20, 30, 40, 50}',
          ],
          [
            1,
            '[ap 04:30] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.30',
            'After the append operation in listing <<4.30|5a:0>>, the slices and the underlying array will look like figure 4.14.',
          ],
          [
            1,
            '[ap 04:31] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.31',
            'Listing <<4.31|5a:0>>. Using append to increase the length and capacity of a slice',
          ],
          [
            1,
            '[ap 01:25] Go in Action - William Kennedy.epub (kindle_split_012.html) - 1.25',
            'The append operation is clever when growing the capacity of the underlying array. Capacity is always doubled when the existing capacity of the slice is under 1,000 elements. Once the number of elements goes over 1,000, the capacity is grown by a factor of <<1.25|5a:0>>, or 25%. This growth algorithm may change in the language over time.',
          ],
          [
            1,
            '[ap 04:32] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.32',
            "Let\x{2019}s start with a slice of five strings that contain fruit you can find in your local supermarket.
Listing <<4.32|5a:0>>. Declaring a slice of string using a slice literal
// Create a slice of strings.
// Contains a length and capacity of 5 elements.
source := []string{\"Apple\", \"Orange\", \"Plum\", \"Banana\", \"Grape\"}",
          ],
          [
            1,
            '[ap 04:33] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.33',
            "Now let\x{2019}s use the third index option to perform a slicing operation.
Listing <<4.33|5a:0>>. Performing a three-index slice
// Slice the third element and restrict the capacity.
// Contains a length of 1 element and capacity of 2 elements.
slice := source[2:3:4]",
          ],
          [
            1,
            '[ap 04:34] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.34',
            "We can apply the same formula that we defined before to calculate the new slice\x{2019}s length and capacity.
Listing <<4.34|5a:0>>. How length and capacity are calculated
For slice[i:j:k]  or  [2:3:4]",
          ],
          [
            1,
            '[ap 04:35] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.35',
            'Listing <<4.35|5a:0>>. Runtime error setting capacity larger than existing capacity',
          ],
          [
            1,
            '[ap 04:36] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.36',
            'By having the option to set the capacity of a new slice to be the same as the length, you can force the first append operation to detach the new slice from the underlying array. Detaching the new slice from its original source array makes it safe to change.
Listing <<4.36|5a:0>>. Benefits of setting length and capacity to be the same
// Create a slice of strings.
// Contains a length and capacity of 5 elements.
source := []string{"Apple", "Orange", "Plum", "Banana", "Grape"}',
          ],
          [
            1,
            '[ap 04:36] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.36',
            "Without this third index, appending Kiwi to our slice would\x{2019}ve changed the value of Banana in index 3 of the underlying array, because all of the remaining capacity would still belong to the slice. But in listing <<4.36|5a:0>>, we restricted the capacity of the slice to 1. When we call append for the first time on the slice, it will create a new underlying array of two elements, copy the fruit Plum, add the new fruit Kiwi, and return a new slice that references this underlying array, as in figure 4.18.",
          ],
          [
            1,
            '[ap 04:37] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.37',
            'The built-in function append is also a variadic function. This means you can pass multiple values to be appended in a single slice call. If you use the ... operator, you can append all the elements of one slice into another.
Listing <<4.37|5a:0>>. Appending to a slice from another slice
// Create two slices each initialized with two integers.
s1 := []int{1, 2}
s2 := []int{3, 4}',
          ],
          [
            1,
            '[ap 04:38] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.38',
            'Since a slice is a collection, you can iterate over the elements. Go has a special keyword called range that you use in conjunction with the keyword for to iterate over slices.
Listing <<4.38|5a:0>>. Iterating over a slice using for range
// Create a slice of integers.
// Contains a length and capacity of 4 elements.
slice := []int{10, 20, 30, 40}',
          ],
          [
            1,
            '[ap 04:39] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.39',
            "It\x{2019}s important to know that range is making a copy of the value, not returning a reference. If you use the address of the value variable as a pointer to each element, you\x{2019}ll be making a mistake. Let\x{2019}s see why.
Listing <<4.39|5a:0>>. range provides a copy of each element
// Create a slice of integers.
// Contains a length and capacity of 4 elements.
slice := []int{10, 20, 30, 40}",
          ],
          [
            1,
            '[ap 04:40] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.40',
            "If you don\x{2019}t need the index value, you can use the underscore character to discard the value.
Listing <<4.40|5a:0>>. Using the blank identifier to ignore the index value
// Create a slice of integers.
// Contains a length and capacity of 4 elements.
slice := []int{10, 20, 30, 40}",
          ],
          [
            1,
            '[ap 04:41] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.41',
            'The keyword range will always start iterating over a slice from the beginning. If you need more control iterating over a slice, you can always use a traditional for loop.
Listing <<4.41|5a:0>>. Iterating over a slice using a traditional for loop
// Create a slice of integers.
// Contains a length and capacity of 4 elements.
slice := []int{10, 20, 30, 40}',
          ],
          [
            1,
            '[ap 04:41] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.41',
            'There are two special built-in functions called len and cap that work with arrays, slices, and channels. For slices, the len function returns the length of the slice, and the cap function returns the capacity. In listing <<4.41|5a:0>>, we used the len function to determine when to stop iterating over the slice.',
          ],
          [
            1,
            '[ap 04:42] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.42',
            'Like arrays, slices are one-dimensional, but they can be composed to create multidimensional slices for the same reasons we discussed earlier.
Listing <<4.42|5a:0>>. Declaring a multidimensional slice
// Create a slice of a slice of integers.
slice := [][]int{{10}, {100, 200}}',
          ],
          [
            1,
            '[ap 04:43] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.43',
            'Composition allows you to create very complex and powerful data structures. All of the rules you learned about the built-in function append still apply.
Listing <<4.43|5a:0>>. Composing slices of slices
// Create a slice of a slice of integers.
slice := [][]int{{10}, {100, 200}}',
          ],
          [
            1,
            '[ap 04:43] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.43',
            'The append function and Go are elegant in how they handle growing and assigning the new slice of integers back into the first element of the outer slice. When the operation in listing <<4.43|5a:0>> is complete, an entire new slice of integers and a new underlying array is allocated and then copied back into index 0 of the outer slice, as shown in figure 4.21.',
          ],
          [
            1,
            '[ap 04:44] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.44',
            "Passing a slice between two functions requires nothing more than passing the slice by value. Since the size of a slice is small, it\x{2019}s cheap to copy and pass between functions. Let\x{2019}s create a large slice and pass that slice by value to our function called foo.
Listing <<4.44|5a:0>>. Passing slices between functions
// Allocate a slice of 1 million integers.
slice := make([]int, 1e6)",
          ],
          [
            1,
            '[ap 04:45] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.45',
            'There are several ways you can create and initialize maps in Go. You can use the built-in function make, or you can use a map literal.
Listing <<4.45|5a:0>>. Declaring a map using make
// Create a map with a key of type string and a value of type int.
dict := make(map[string]int)',
          ],
          [
            1,
            '[ap 04:46] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.46',
            "The map key can be a value from any built-in or struct type as long as the value can be used in an expression with the == operator. Slices, functions, and struct types that contain slices can\x{2019}t be used as map keys. This will produce a compiler error.
Listing <<4.46|5a:0>>. Declaring an empty map using a map literal
// Create a map using a slice of strings as the key.
dict := map[[]string]int{}",
          ],
          [
            1,
            '[ap 04:47] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.47',
            "There\x{2019}s nothing stopping you from using a slice as a map value. This can come in handy when you need a single map key to be associated with a collection of data.
Listing <<4.47|5a:0>>. Declaring a map that stores slices of strings
// Create a map using a slice of strings as the value.
dict := map[int][]string{}",
          ],
          [
            1,
            '[ap 04:48] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.48',
            'Assigning a key/value pair to a map is performed by specifying a key of the proper type and assigning a value to that key.
Listing <<4.48|5a:0>>. Assigning values to a map
// Create an empty map to store colors and their color codes.
colors := map[string]string{}',
          ],
          [
            1,
            '[ap 04:49] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.49',
            "You can create a nil map by declaring a map without any initialization. A nil map can\x{2019}t be used to store key/value pairs. Trying will produce a runtime error.
Listing <<4.49|5a:0>>. Runtime error assigned to a nil map
// Create a nil map by just declaring the map.
var colors map[string]string",
          ],
          [
            1,
            '[ap 04:50] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.50',
            'When retrieving a value from a map, you have two choices. You can retrieve the value and a flag that explicitly lets you know if the key exists.
Listing <<4.50|5a:0>>. Retrieving a value from a map and testing existence.
// Retrieve the value for the key "Blue".
value, exists := colors["Blue"]',
          ],
          [
            1,
            '[ap 04:51] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.51',
            'Listing <<4.51|5a:0>>. Retrieving a value from a map testing the value for existence',
          ],
          [
            1,
            '[ap 04:52] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.52',
            "Iterating over a map is identical to iterating over an array or slice. You use the keyword range; but when it comes to maps, you don\x{2019}t get back the index/value, you get back the key/value pairs.
Listing <<4.52|5a:0>>. Iterating over a map using for range
// Create a map of colors and color hex codes.
colors := map[string]string{
    \"AliceBlue\":   \"#f0f8ff\",
    \"Coral\":       \"#ff7F50\",
    \"DarkGray\":    \"#a9a9a9\",
    \"ForestGreen\": \"#228b22\",
}",
          ],
          [
            1,
            '[ap 04:53] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.53',
            'If you want to remove a key/value pair from the map, you use the built-in function delete.
Listing <<4.53|5a:0>>. Removing an item from a map
// Remove the key/value pair for the key "Coral".
delete(colors, "Coral")',
          ],
          [
            1,
            '[ap 04:54] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.54',
            "Passing a map between two functions doesn\x{2019}t make a copy of the map. In fact, you can pass a map to a function and make changes to the map, and the changes will be reflected by all references to the map.
Listing <<4.54|5a:0>>. Passing maps between functions
func main() {
    // Create a map of colors and color hex codes.
    colors := map[string]string{
       \"AliceBlue\":   \"#f0f8ff\",
       \"Coral\":       \"#ff7F50\",
       \"DarkGray\":    \"#a9a9a9\",
       \"ForestGreen\": \"#228b22\",
    }",
          ],
          [
            1,
            '[ap 04:55] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.55',
            "If you run this program, you\x{2019}ll get the following output.
Listing <<4.55|5a:0>>. Output for listing <<4.54|5a:0>>
Key: AliceBlue Value: #F0F8FF
Key: Coral Value: #FF7F50
Key: DarkGray Value: #A9A9A9
Key: ForestGreen Value: #228B22",
          ],
          [
            1,
            '[ap 05:10] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.10',
            'The program in listing 5.9 declares a type on line 03 called Duration. Then on line 06, a variable named dur of type Duration is declared and set to its zero value. Then on line 07, we write code that produces the following compiler error when the program is built.
Listing <<5.10|5a:0>>. Actual compiler error
prog.go:7: cannot use int64(1000) (type int64) as type Duration
           in assignment',
          ],
          [
            1,
            '[ap 05:11] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.11',
            "Methods provide a way to add behavior to user-defined types. Methods are really functions that contain an extra parameter that\x{2019}s declared between the keyword func and the function name.
Listing <<5.11|5a:0>>. listing11.go
01 // Sample program to show how to declare methods and how the Go
02 // compiler supports them.
03 package main
04
05 import (
06     \"fmt\"
07 )
08
09 // user defines a user in the program.
10 type user struct {
11     name  string",
          ],
          [
            1,
            '[ap 05:11] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.11',
            'Lines 16 and 23 of listing <<5.11|5a:0>> show two different methods. The parameter between the keyword func and the function name is called a receiver and binds the function to the specified type. When a function has a receiver, that function is called a method. When you run the program, you get the following output.',
          ],
          [
            1,
            '[ap 05:11] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.11',
            'Lines 16 and 23 of listing <<5.11|5a:0>> show two different methods. The parameter between the keyword func and the function name is called a receiver and binds the function to the specified type. When a function has a receiver, that function is called a method. When you run the program, you get the following output.
Listing <<5.12|5a:0>>. Output for listing11.go
Sending User Email To Bill<bill@email.com>
Sending User Email To Lisa<lisa@email.com>
Sending User Email To Bill<bill@newdomain.com>
Sending User Email To Lisa<lisa@comcast.com>',
          ],
          [
            1,
            '[ap 05:13] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.13',
            "Let\x{2019}s examine what the program is doing. On line 10, the program declares a struct type named user and then declares a method named notify.
Listing <<5.13|5a:0>>. listing11.go: lines 09\x{2013}20
09 // user defines a user in the program.
10 type user struct {
11     name  string
12     email string
13 }
14
15 // notify implements a method with a value receiver.
16 func (u user) notify() {
17     fmt.Printf(\"Sending User Email To %s<%s>\\n\",
18         u.name,
19         u.email)
20 }",
          ],
          [
            1,
            '[ap 05:13] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.13',
            'There are two types of receivers in Go: value receivers and pointer receivers. In listing <<5.13|5a:0>> on line 16, the notify method is declared with a value receiver.',
          ],
          [
            1,
            '[ap 05:13] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.13',
            'There are two types of receivers in Go: value receivers and pointer receivers. In listing <<5.13|5a:0>> on line 16, the notify method is declared with a value receiver.
Listing <<5.14|5a:0>>. Declaration of a method with a value receiver
func (u user) notify() {',
          ],
          [
            1,
            '[ap 05:11] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.11',
            "The receiver for notify is declared as a value of type user. When you declare a method using a value receiver, the method will always be operating against a copy of the value used to make the method call. Let\x{2019}s skip to line 32 of the program in listing <<5.11|5a:0>> to see a method call on notify.",
          ],
          [
            1,
            '[ap 05:11] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.11',
            "The receiver for notify is declared as a value of type user. When you declare a method using a value receiver, the method will always be operating against a copy of the value used to make the method call. Let\x{2019}s skip to line 32 of the program in listing <<5.11|5a:0>> to see a method call on notify.
Listing <<5.15|5a:0>>. listing11.go: lines 29\x{2013}32
29     // Values of type user can be used to call methods
30     // declared with a value receiver.
31     bill := user{\"Bill\", \"bill\@email.com\"}
32     bill.notify()",
          ],
          [
            1,
            '[ap 05:15] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.15',
            'Listing <<5.15|5a:0>> shows a call to the notify method using a value of type user. On line 31, a variable named bill of type user is declared and initialized with a name and email address. Then on line 32, the notify method is called using the variable bill.',
          ],
          [
            1,
            '[ap 05:15] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.15',
            'Listing <<5.15|5a:0>> shows a call to the notify method using a value of type user. On line 31, a variable named bill of type user is declared and initialized with a name and email address. Then on line 32, the notify method is called using the variable bill.
Listing <<5.16|5a:0>>. Calling a method from a variable
bill.notify()',
          ],
          [
            1,
            '[ap 05:17] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.17',
            "You can also call methods that are declared with a value receiver using a pointer.
Listing <<5.17|5a:0>>. listing11.go: lines 34\x{2013}37
34     // Pointers of type user can also be used to call methods
35     // declared with a value receiver.
36     lisa := &user{\"Lisa\", \"lisa\@email.com\"}
37     lisa.notify()",
          ],
          [
            1,
            '[ap 05:17] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.17',
            "Listing <<5.17|5a:0>> shows a call to the notify method using a pointer of type user. On line 36, a variable named lisa of pointer type user is declared and initialized with a name and email address. Then on line 37, the notify method is called using the pointer variable. To support the method call, Go adjusts the pointer value to comply with the method\x{2019}s receiver. You can imagine that Go is performing the following operation.",
          ],
          [
            1,
            '[ap 05:17] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.17',
            "Listing <<5.17|5a:0>> shows a call to the notify method using a pointer of type user. On line 36, a variable named lisa of pointer type user is declared and initialized with a name and email address. Then on line 37, the notify method is called using the pointer variable. To support the method call, Go adjusts the pointer value to comply with the method\x{2019}s receiver. You can imagine that Go is performing the following operation.
Listing <<5.18|5a:0>>. What Go is doing underneath the code
(*lisa).notify()",
          ],
          [
            1,
            '[ap 05:18] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.18',
            'Listing <<5.18|5a:0>> shows essentially what the Go compiler is doing to support the method call. The pointer value is dereferenced so the method call is in compliance with the value receiver. Once again, notify is operating against a copy, but this time a copy of the value that the lisa pointer points to.',
          ],
          [
            1,
            '[ap 05:19] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.19',
            "You can also declare methods with pointer receivers.
Listing <<5.19|5a:0>>. listing11.go: lines 22\x{2013}25
22 // changeEmail implements a method with a pointer receiver.
23 func (u *user) changeEmail(email string) {
24     u.email = email
25 }",
          ],
          [
            1,
            '[ap 05:19] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.19',
            'Listing <<5.19|5a:0>> shows the declaration of the changeEmail method, which is declared with a pointer receiver. This time, the receiver is not a value of type user but a pointer of type user. When you call a method declared with a pointer receiver, the value used to make the call is shared with the method.',
          ],
          [
            1,
            '[ap 05:19] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.19',
            "Listing <<5.19|5a:0>> shows the declaration of the changeEmail method, which is declared with a pointer receiver. This time, the receiver is not a value of type user but a pointer of type user. When you call a method declared with a pointer receiver, the value used to make the call is shared with the method.
Listing <<5.20|5a:0>>. listing11.go: lines 36, 44\x{2013}46
36     lisa := &user{\"Lisa\", \"lisa\@email.com\"}",
          ],
          [
            1,
            '[ap 05:20] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.20',
            'In listing <<5.20|5a:0>> you see the declaration of the lisa pointer variable followed by the method call to changeEmail on line 46. Once the call to changeEmail returns, any changes to the value that the lisa pointer points to will be reflected after the call. This is thanks to the pointer receiver. Value receivers operate on a copy of the value used to make the method call and pointer receivers operate on the actual value.',
          ],
          [
            1,
            '[ap 05:21] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.21',
            'You can also call methods that are declared with a pointer receiver using a value.
Listing <<5.21|5a:0>>. listing11.go: line 31
31     bill := user{"Bill", "bill@email.com"}',
          ],
          [
            1,
            '[ap 05:21] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.21',
            "In listing <<5.21|5a:0>>, you see the declaration of the variable bill and then a call to the changeEmail method, which is declared with a pointer receiver. Once again, Go adjusts the value to comply with the method\x{2019}s receiver to support the call.",
          ],
          [
            1,
            '[ap 05:21] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.21',
            "In listing <<5.21|5a:0>>, you see the declaration of the variable bill and then a call to the changeEmail method, which is declared with a pointer receiver. Once again, Go adjusts the value to comply with the method\x{2019}s receiver to support the call.
Listing <<5.22|5a:0>>. What Go is doing underneath the code
(&bill).notify()",
          ],
          [
            1,
            '[ap 05:22] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.22',
            "Listing <<5.22|5a:0>> shows essentially what the Go compiler is doing to support the method call. In this case, the value is referenced so the method call is in compliance with the receiver type. This is a great convenience Go provides, allowing method calls with values and pointers that don\x{2019}t match a method\x{2019}s receiver type natively.",
          ],
          [
            1,
            '[ap 05:23] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.23',
            "Built-in types are the set of types that are provided by the language. We know them as the set of numeric, string, and Boolean types. These types have a primitive nature to them. Because of this, when adding or removing something from a value of one of these types, a new value should be created. Based on this, when passing values of these types to functions and methods, a copy of the value should be passed. Let\x{2019}s look at a function from the standard library that works with built-in values.
Listing <<5.23|5a:0>>. golang.org/src/strings/strings.go: lines 620\x{2013}625
620 func Trim(s string, cutset string) string {
621     if s == \"\" || cutset == \"\" {
622         return s
623     }
624     return TrimFunc(s, makeCutsetFunc(cutset))
625 }",
          ],
          [
            1,
            '[ap 05:23] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.23',
            "In listing <<5.23|5a:0>>, you see the Trim function, which comes from the strings package in the standard library. The Trim function is passed a string value to operate on and a string value with characters to find. It then returns a new string value that\x{2019}s the result of the operation. The function operates on copies of the caller\x{2019}s original string values and returns a copy of the new string value. Strings, just like integers, floats, and Booleans, are primitive data values and should be copied when passed in and out of functions or methods.",
          ],
          [
            1,
            '[ap 05:24] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.24',
            "Let\x{2019}s look at a second example of how the built-in types are treated as having a primitive nature.
Listing <<5.24|5a:0>>. golang.org/src/os/env.go: lines 38\x{2013}44
38 func isShellSpecialVar(c uint8) bool {
39     switch c {
40     case '*', '#', '\$', '\@', '!', '?', '0', '1', '2', '3', '4', '5',
                                                     '6', '7', '8', '9':
41         return true
42     }
43     return false
44 }",
          ],
          [
            1,
            '[ap 05:24] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.24',
            "Listing <<5.24|5a:0>> shows the isShellSpecialVar function from the env package. This function is passed a value of type uint8 and returns a value of type bool. Note how pointers aren\x{2019}t being used to share the value for the parameter or return value. The caller passes a copy of their uint8 value and receives a value of true or false.",
          ],
          [
            1,
            '[ap 05:25] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.25',
            "Let\x{2019}s look at a type from the net package.
Listing <<5.25|5a:0>>. golang.org/src/net/ip.go: line 32
32 type IP []byte",
          ],
          [
            1,
            '[ap 05:25] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.25',
            'Listing <<5.25|5a:0>> shows a type called IP which is declared as a slice of bytes. Declaring a type like this is useful when you want to declare behavior around a built-in or reference type. The compiler will only let you declare methods for user-defined types that are named.',
          ],
          [
            1,
            '[ap 05:25] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.25',
            "Listing <<5.25|5a:0>> shows a type called IP which is declared as a slice of bytes. Declaring a type like this is useful when you want to declare behavior around a built-in or reference type. The compiler will only let you declare methods for user-defined types that are named.
Listing <<5.26|5a:0>>. golang.org/src/net/ip.go: lines 329\x{2013}337
329 func (ip IP) MarshalText() ([]byte, error) {
330     if len(ip) == 0 {
331         return []byte(\"\"), nil
332     }
333     if len(ip) != IPv4len && len(ip) != IPv6len {
334         return nil, errors.New(\"invalid IP address\")
335     }
336     return []byte(ip.String()), nil
337 }",
          ],
          [
            1,
            '[ap 05:26] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.26',
            "The MarshalText method in listing <<5.26|5a:0>> has been declared using a value receiver of type IP. A value receiver is exactly what you expect to see since you don\x{2019}t share reference type values. This also applies to passing reference type values as parameters to functions and methods.",
          ],
          [
            1,
            '[ap 05:26] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.26',
            "The MarshalText method in listing <<5.26|5a:0>> has been declared using a value receiver of type IP. A value receiver is exactly what you expect to see since you don\x{2019}t share reference type values. This also applies to passing reference type values as parameters to functions and methods.
Listing <<5.27|5a:0>>. golang.org/src/net/ip.go: lines 318\x{2013}325
318 // ipEmptyString is like ip.String except that it returns
319 // an empty string when ip is unset.
320 func ipEmptyString(ip IP) string {
321     if len(ip) == 0 {
322         return \"\"
323     }
324     return ip.String()
325 }",
          ],
          [
            1,
            '[ap 05:27] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.27',
            "In listing <<5.27|5a:0>> you see the ipEmptyString function. This function is passed a value of the type IP. Once again, you can see how the caller\x{2019}s reference type value for this parameter is not shared with the function. The function is passed a copy of the caller\x{2019}s reference type value. This also applies to return values. In the end, reference type values are treated like primitive data values.",
          ],
          [
            1,
            '[ap 05:28] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.28',
            "Struct types can represent data values that could have either a primitive or nonprimitive nature. When the decision is made that a struct type value should not be mutated when something needs to be added or removed from the value, then it should follow the guidelines for the built-in and reference types. Let\x{2019}s start with looking at a struct implemented by the standard library that has a primitive nature.
Listing <<5.28|5a:1>>. golang.org/src/time/time.go: lines 39\x{2013}55
39 type Time struct {
40     // sec gives the number of seconds elapsed since
41     // January 1, year 1 <<00:00|2>>:00 UTC.
42     sec int64
43
44     // nsec specifies a non-negative nanosecond
45     // offset within the second named by Seconds.
46     // It must be in the range [0, 999999999].
47     nsec int32
48
49     // loc specifies the Location that should be used to
50     // determine the minute, hour, month, day, and year
51     // that correspond to this Time.
52     // Only the zero Time has a nil Location.
53     // In that case it is interpreted to mean UTC.
54     loc *Location
55 }",
          ],
          [
            1,
            '[00:00] Go in Action - William Kennedy.epub (kindle_split_013.html) - 00:00',
            '39 type Time struct {
40     // sec gives the number of seconds elapsed since
41     // January 1, year 1 <<00:00|2>>:00 UTC.
42     sec int64
43
44     // nsec specifies a non-negative nanosecond
45     // offset within the second named by Seconds.
46     // It must be in the range [0, 999999999].
47     nsec int32
48
49     // loc specifies the Location that should be used to
50     // determine the minute, hour, month, day, and year
51     // that correspond to this Time.
52     // Only the zero Time has a nil Location.
53     // In that case it is interpreted to mean UTC.
54     loc *Location
55 }',
          ],
          [
            1,
            '[ap 05:28] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.28',
            "The Time struct in listing <<5.28|5a:0>> comes from the time package. When you think about time, you realize that any given point in time is not something that can change. This is exactly how the standard library implements the Time type. Let\x{2019}s look at the Now function that creates values of type Time.",
          ],
          [
            1,
            '[ap 05:28] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.28',
            "The Time struct in listing <<5.28|5a:0>> comes from the time package. When you think about time, you realize that any given point in time is not something that can change. This is exactly how the standard library implements the Time type. Let\x{2019}s look at the Now function that creates values of type Time.
Listing <<5.29|5a:0>>. golang.org/src/time/time.go: lines 781\x{2013}784
781 func Now() Time {
782     sec, nsec := now()
783     return Time{sec + unixToInternal, nsec, Local}
784 }",
          ],
          [
            1,
            '[ap 05:29] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.29',
            "The code in listing <<5.29|5a:0>> shows the implementation of the Now function. This function creates a value of type Time and returns a copy of that Time value back to the caller. A pointer is not used to share the Time value created by the function. Next, let\x{2019}s look at a method declared against the Time type.",
          ],
          [
            1,
            '[ap 05:29] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.29',
            "The code in listing <<5.29|5a:0>> shows the implementation of the Now function. This function creates a value of type Time and returns a copy of that Time value back to the caller. A pointer is not used to share the Time value created by the function. Next, let\x{2019}s look at a method declared against the Time type.
Listing <<5.30|5a:0>>. golang.org/src/time/time.go: lines 610\x{2013}622
610 func (t Time) Add(d Duration) Time {
611     t.sec += int64(d / 1e9)
612     nsec := int32(t.nsec) + int32(d%1e9)
613     if nsec >= 1e9 {
614         t.sec++
615         nsec -= 1e9
616     } else if nsec < 0 {
617         t.sec--
618         nsec += 1e9
619     }
620     t.nsec = nsec
621     return t
622 }",
          ],
          [
            1,
            '[ap 05:30] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.30',
            "The method Add in listing <<5.30|5a:0>> is a great example of how the standard library treats the Time type as having a primitive nature. The method is declared using a value receiver and returns a new Time value. The method is operating on its own copy of the caller\x{2019}s Time value and returns a copy of its local Time value back to the caller. It\x{2019}s up to the caller whether they want to replace their Time value with what\x{2019}s returned or declare a new Time variable to hold the result.",
          ],
          [
            1,
            '[ap 05:31] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.31',
            "In most cases, struct types don\x{2019}t exhibit a primitive nature, but a nonprimitive one. In these cases, adding or removing something from the value of the type should mutate the value. When this is the case, you want to use a pointer to share the value with the rest of the program that needs it. Let\x{2019}s take a look at a struct type implemented by the standard library that has a nonprimitive nature.
Listing <<5.31|5a:0>>. golang.org/src/os/file_unix.go: lines 15\x{2013}29
15 // File represents an open file descriptor.
16 type File struct {
17     *file
18 }
19
20 // file is the real representation of *File.
21 // The extra level of indirection ensures that no clients of os
22 // can overwrite this data, which could cause the finalizer
23 // to close the wrong file descriptor.
24 type file struct {
25     fd int
26     name string
27     dirinfo *dirInfo // nil unless directory being read
28     nepipe int32 // number of consecutive EPIPE in Write
29 }",
          ],
          [
            1,
            '[ap 05:31] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.31',
            "In listing <<5.31|5a:0>> you see the declaration of the File type from the standard library. The nature of this type is nonprimitive. Values of this type are actually unsafe to be copied. The comments for the unexported type make this clear. Since there\x{2019}s no way to prevent programmers from making copies, the implementation of the File type uses an embedded pointer of an unexported type. We\x{2019}ll talk about embedding types later in this chapter, but this extra level of indirection provides protection from copies. Not every struct type requires or should be implemented with this extra protection. Programmers should respect the nature of each type and use it accordingly.",
          ],
          [
            1,
            '[ap 05:32] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.32',
            "Let\x{2019}s look at the implementation of the Open function.
Listing <<5.32|5a:0>>. golang.org/src/os/file.go: lines 238\x{2013}240
238 func Open(name string) (file *File, err error) {
239     return OpenFile(name, O_RDONLY, 0)
240 }",
          ],
          [
            1,
            '[ap 05:32] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.32',
            "The implementation of the Open function in listing <<5.32|5a:0>> shows how a pointer is used to share File type values with the caller of the function. Open creates a value of type File and returns a pointer to that value. When a factory function returns a pointer, it\x{2019}s a good indication that the nature of the value being returned is nonprimitive.",
          ],
          [
            1,
            '[ap 05:33] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.33',
            "Even if a function or method is never going to directly change the state of a nonprimitive value, it should still be shared.
Listing <<5.33|5a:0>>. golang.org/src/os/file.go: lines 224\x{2013}232
224 func (f *File) Chdir() error {
225     if f == nil {
226         return ErrInvalid
227     }
228     if e := syscall.Fchdir(f.fd); e != nil {
229         return &PathError{\"chdir\", f.name, e}
230     }
231     return nil
232 }",
          ],
          [
            1,
            '[ap 05:33] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.33',
            "The Chdir method in listing <<5.33|5a:0>> shows how a pointer receiver is declared even though no changes are made to the receiver value. Since values of type File have a nonprimitive nature, they\x{2019}re always shared and never copied.",
          ],
          [
            1,
            '[ap 05:34] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.34',
            "Let\x{2019}s start by looking at a sample program that implements a version of a popular program named curl.
Listing <<5.34|5a:0>>. listing34.go
01 // Sample program to show how to write a simple version of curl using
02 // the io.Reader and io.Writer interface support.
03 package main
04
05 import (
06     \"fmt\"
07     \"io\"
08     \"net/http\"
09     \"os\"
10 )
11
12 // init is called before main.
13 func init() {
14     if len(os.Args) != 2 {
15         fmt.Println(\"Usage: ./example2 <url>\")
16         os.Exit(-1)
17     }
18 }
19
20 // main is the entry point for the application.
21 func main() {
22     // Get a response from the web server.
23     r, err := http.Get(os.Args[1])
24     if err != nil {
25         fmt.Println(err)
26         return
27     }
28
29     // Copies from the Body to Stdout.
30     io.Copy(os.Stdout, r.Body)
31     if err := r.Body.Close(); err != nil {
32         fmt.Println(err)
33     }
34 }",
          ],
          [
            1,
            '[ap 05:34] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.34',
            'Listing <<5.34|5a:0>> shows the power of interfaces and their use in the standard library. In a few lines of code, we have a curl program by leveraging two functions that work with interface values. On line 23, we call the Get function from the http package. The http.Get function returns a pointer of type http.Request after it successfully communicates with the server. The http.Request type contains a field named Body, which is an interface value of type io.ReadCloser.',
          ],
          [
            1,
            '[ap 05:35] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.35',
            'The io.Copy function can perform this work flow for many different types that already exist in the standard library.
Listing <<5.35|5a:0>>. listing35.go
01 // Sample program to show how a bytes.Buffer can also be used
02 // with the io.Copy function.
03 package main
04
05 import (
06     "bytes"
07     "fmt"
08     "io"
09     "os"
10 )
11
12 // main is the entry point for the application.
13 func main() {
14     var b bytes.Buffer
15
16     // Write a string to the buffer.
17     b.Write([]byte("Hello"))
18
19     // Use Fprintf to concatenate a string to the Buffer.
20     fmt.Fprintf(&b, "World!")
21
22     // Write the content of the Buffer to stdout.
23     io.Copy(os.Stdout, &b)
24 }',
          ],
          [
            1,
            '[ap 05:35] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.35',
            'Listing <<5.35|5a:0>> shows a program that uses interfaces to concatenate and then stream data to standard out. On line 14, a variable of type Buffer from the bytes package is created, and then the Write method is used on line 17 to add the string Hello to the buffer. On line 20, the Fprintf function from the fmt package is called to append a second string to the buffer.',
          ],
          [
            1,
            '[ap 05:36] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.36',
            'Method sets define the rules around interface compliance. Take a look at the following code to help you understand how method sets play an important role with interfaces.
Listing <<5.36|5a:0>>. listing36.go
01 // Sample program to show how to use an interface in Go.
02 package main
03
04 import (
05     "fmt"
06 )
07
08 // notifier is an interface that defined notification
09 // type behavior.
10 type notifier interface {
11     notify()
12 }
13
14 // user defines a user in the program.
15 type user struct {
16     name  string
17     email string
18 }
19
20 // notify implements a method with a pointer receiver.
21 func (u *user) notify() {
22     fmt.Printf("Sending user email to %s<%s>\\n",
23         u.name,
24         u.email)
25 }
26
27 // main is the entry point for the application.
28 func main() {
29     // Create a value of type User and send a notification.
30     u := user{"Bill", "bill@email.com"}
31
32     sendNotification(u)
33',
          ],
          [
            1,
            '[ap 05:36] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.36',
            "In listing <<5.36|5a:0>> you see code that you would expect to compile, but it doesn\x{2019}t. On line 10, we declare an interface named notifier with a single method named notify. Then on line 15, we have the declaration of our concrete type named user and the implementation of the notifier interface via the method declaration on line 21. The method is implemented with a pointer receiver of type user.",
          ],
          [
            1,
            '[ap 05:36] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.36',
            "In listing <<5.36|5a:0>> you see code that you would expect to compile, but it doesn\x{2019}t. On line 10, we declare an interface named notifier with a single method named notify. Then on line 15, we have the declaration of our concrete type named user and the implementation of the notifier interface via the method declaration on line 21. The method is implemented with a pointer receiver of type user.
Listing <<5.37|5a:0>>. listing36.go: lines 40\x{2013}44
40 // sendNotification accepts values that implement the notifier
41 // interface and sends notifications.
42 func sendNotification(n notifier) {
43     n.notify()
44 }",
          ],
          [
            1,
            '[ap 05:37] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.37',
            "On line 42 in listing <<5.37|5a:0>>, a function named sendNotification is declared and accepts a single value of the interface type notifier. Then the interface value is used to call the notify method against the stored value. Any value that implements the notifier interface can be passed into the sendNotification function. Now let\x{2019}s look at the main function.",
          ],
          [
            1,
            '[ap 05:37] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.37',
            "On line 42 in listing <<5.37|5a:0>>, a function named sendNotification is declared and accepts a single value of the interface type notifier. Then the interface value is used to call the notify method against the stored value. Any value that implements the notifier interface can be passed into the sendNotification function. Now let\x{2019}s look at the main function.
Listing <<5.38|5a:0>>. listing36.go: lines 28\x{2013}38
28 func main() {
29     // Create a value of type User and send a notification.
30     u := user{\"Bill\", \"bill\@email.com\"}
31
32     sendNotification(u)
33
34     // ./listing36.go:32: cannot use u (type user) as type
35     //                     notifier in argument to sendNotification:
36     //   user does not implement notifier
37     //                          (notify method has pointer receiver)
38 }",
          ],
          [
            1,
            '[ap 05:38] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.38',
            'In the main function, a value of the concrete type user is created and assigned to the variable u on line 30 in listing <<5.38|5a:0>>. Then the value of u is passed to the send-Notification function on line 32. But the call to sendNotification results in a compiler error.',
          ],
          [
            1,
            '[ap 05:39] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.39',
            'Listing <<5.39|5a:0>>. Compiler error storing a value of type user to the interface value',
          ],
          [
            1,
            '[ap 05:40] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.40',
            "So why do we receive a compiler error when the user type implements the notify method on line 21? Let\x{2019}s take a look at that code again.
Listing <<5.40|5a:0>>. listing36.go: lines 08\x{2013}12, <<21\x{2013}25|5a:0>>
08 // notifier is an interface that defined notification
09 // type behavior.
10 type notifier interface {
11     notify()
12 }",
          ],
          [
            1,
            '[ap 05:40] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.40',
            "Listing <<5.40|5a:0>> shows how the interface has been implemented, yet the compiler tells us that a value of type user doesn\x{2019}t implement the interface. If you look closer at the compiler message, it actually tells us why.",
          ],
          [
            1,
            '[ap 05:40] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.40',
            "Listing <<5.40|5a:0>> shows how the interface has been implemented, yet the compiler tells us that a value of type user doesn\x{2019}t implement the interface. If you look closer at the compiler message, it actually tells us why.
Listing <<5.41|5a:0>>. Closer look at compiler error
(notify method has pointer receiver)",
          ],
          [
            1,
            '[ap 05:42] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.42',
            "Let\x{2019}s start with explaining the rules for method sets as it\x{2019}s documented by the Go specification.
Listing <<5.42|5a:0>>. Method sets as described by the specification
Values                    Methods Receivers
-----------------------------------------------
    T                        (t T)
   *T                        (t T) and (t *T)",
          ],
          [
            1,
            '[ap 05:42] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.42',
            "Listing <<5.42|5a:0>> shows how the specification describes method sets. It says that a value of type T only has methods declared that have a value receiver, as part of its method set. But pointers of type T have methods declared with both value and pointer receivers, as part of its method set. Looking at these rules from the perspective of the value is confusing. Let\x{2019}s look at these rules from the perspective of the receiver.",
          ],
          [
            1,
            '[ap 05:42] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.42',
            "Listing <<5.42|5a:0>> shows how the specification describes method sets. It says that a value of type T only has methods declared that have a value receiver, as part of its method set. But pointers of type T have methods declared with both value and pointer receivers, as part of its method set. Looking at these rules from the perspective of the value is confusing. Let\x{2019}s look at these rules from the perspective of the receiver.
Listing <<5.43|5a:0>>. Method sets from the perspective of the receiver type
Methods Receivers         Values
-----------------------------------------------
   (t T)                     T and *T
   (t *T)                    *T",
          ],
          [
            1,
            '[ap 05:43] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.43',
            'Listing <<5.43|5a:0>> shows the same rules, but from the perspective of the receiver. It says that if you implement an interface using a pointer receiver, then only pointers of that type implement the interface. If you implement an interface using a value receiver, then both values and pointers of that type implement the interface. If you look at the code in listing <<5.36|5a:0>> again, you now have the context to understand the compiler error.',
          ],
          [
            1,
            '[ap 05:43] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.43',
            "Listing <<5.43|5a:0>> shows the same rules, but from the perspective of the receiver. It says that if you implement an interface using a pointer receiver, then only pointers of that type implement the interface. If you implement an interface using a value receiver, then both values and pointers of that type implement the interface. If you look at the code in listing <<5.36|5a:0>> again, you now have the context to understand the compiler error.
Listing <<5.44|5a:0>>. listing36.go: lines 28\x{2013}38
28 func main() {
29     // Create a value of type User and send a notification.
30     u := user{\"Bill\", \"bill\@email.com\"}
31
32     sendNotification(u)
33
34     // ./listing36.go:32: cannot use u (type user) as type
35     //                     notifier in argument to sendNotification:
36     //   user does not implement notifier
37     //                          (notify method has pointer receiver)
38 }",
          ],
          [
            1,
            '[ap 05:44] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.44',
            "We implemented the interface using a pointer receiver and attempted to pass a value of type user to the sendNotification function. Lines 30 and 32 in listing <<5.44|5a:0>> show this clearly. But if we pass the address of the user value instead, you\x{2019}ll see that it now compiles and works.",
          ],
          [
            1,
            '[ap 05:44] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.44',
            "We implemented the interface using a pointer receiver and attempted to pass a value of type user to the sendNotification function. Lines 30 and 32 in listing <<5.44|5a:0>> show this clearly. But if we pass the address of the user value instead, you\x{2019}ll see that it now compiles and works.
Listing <<5.45|5a:0>>. listing36.go: lines 28\x{2013}35
28 func main() {
29     // Create a value of type User and send a notification.
30     u := user{\"Bill\", \"bill\@email.com\"}
31
32     sendNotification(&u)
33
34     // PASSED THE ADDRESS AND NO MORE ERROR.
35 }",
          ],
          [
            1,
            '[ap 05:45] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.45',
            'In listing <<5.45|5a:0>>, we now have a program that compiles and runs. Only pointers of type user can be passed to the sendNotification function, since a pointer receiver was used to implement the interface.',
          ],
          [
            1,
            '[ap 05:46] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.46',
            "The question now is why the restriction? The answer comes from the fact that it\x{2019}s not always possible to get the address of a value.
Listing <<5.46|5a:0>>. listing46.go
01 // Sample program to show how you can't always get the
02 // address of a value.
03 package main
04
05 import \"fmt\"
06
07 // duration is a type with a base type of int.
08 type duration int
09
10 // format pretty-prints the duration value.
11 func (d *duration) pretty() string {
12     return fmt.Sprintf(\"Duration: %d\", *d)
13 }
14
15 // main is the entry point for the application.
16 func main() {
17     duration(42).pretty()
18
19     // ./listing46.go:17: cannot call pointer method on duration(42)
20     // ./listing46.go:17: cannot take the address of duration(42)
21 }",
          ],
          [
            1,
            '[ap 05:46] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.46',
            "The code in listing <<5.46|5a:0>> attempts to get the address of a value of type duration and can\x{2019}t. This shows that it\x{2019}s not always possible to get the address of a value. Let\x{2019}s look at the method set rules again.",
          ],
          [
            1,
            '[ap 05:46] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.46',
            "The code in listing <<5.46|5a:0>> attempts to get the address of a value of type duration and can\x{2019}t. This shows that it\x{2019}s not always possible to get the address of a value. Let\x{2019}s look at the method set rules again.
Listing <<5.47|5a:0>>. Second look at the method set rules
Values                    Methods Receivers
-----------------------------------------------
    T                        (t T)
   *T                        (t T) and (t *T)",
          ],
          [
            1,
            '[ap 05:48] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.48',
            "Now that you understand the mechanics behind interfaces and method sets, let\x{2019}s look at one final example that shows the polymorphic behavior of interfaces.
Listing <<5.48|5a:0>>. listing48.go
01 // Sample program to show how polymorphic behavior with interfaces.
02 package main
03
04 import (
05     \"fmt\"
06 )
07
08 // notifier is an interface that defines notification
09 // type behavior.
10 type notifier interface {
11     notify()
12 }
13
14 // user defines a user in the program.
15 type user struct {
16     name  string
17     email string
18 }
19
20 // notify implements the notifier interface with a pointer receiver.
21 func (u *user) notify() {
22     fmt.Printf(\"Sending user email to %s<%s>\\n\",
23         u.name,
24         u.email)
25 }
26
27 // admin defines a admin in the program.
28 type admin struct {
29     name  string
30     email string
31 }
32
33 // notify implements the notifier interface with a pointer receiver.
34 func (a *admin) notify() {
35     fmt.Printf(\"Sending admin email to %s<%s>\\n\",
36         a.name,
37         a.email)
38 }
39
40 // main is the entry point for the application.
41 func main() {
42     // Create a user value and pass it to sendNotification.
43     bill := user{\"Bill\", \"bill\@email.com\"}
44     sendNotification(&bill)
45
46     // Create an admin value and pass it to sendNotification.
47     lisa := admin{\"Lisa\", \"lisa\@email.com\"}
48     sendNotification(&lisa)
49 }
50
51 // sendNotification accepts values that implement the notifier
52 // interface and sends notifications.",
          ],
          [
            1,
            '[ap 05:48] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.48',
            'In listing <<5.48|5a:0>>, we have a final example of how interfaces provide polymorphic behavior. On line 10, we have the same notifier interface that we declared in previous listings. Then on lines 15 through 25, we have the declaration of a struct named user with the implementation of the notifier interface using a pointer receiver. On lines 28 through 38, we have the declaration of a struct named admin with the implementation of the notifier interface as well. We have two concrete types implementing the notifier interface.',
          ],
          [
            1,
            '[ap 05:49] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.49',
            "On line 53, we have our polymorphic sendNotification function again that accepts values that implement the notifier interface. Since any concrete type value can implement the interface, this function can execute the notify method for any concrete type value that\x{2019}s passed in, thus providing polymorphic behavior.
Listing <<5.49|5a:0>>. listing48.go: lines 40\x{2013}49
40 // main is the entry point for the application.
41 func main() {
42     // Create a user value and pass it to sendNotification.
43     bill := user{\"Bill\", \"bill\@email.com\"}
44     sendNotification(&bill)
45
46     // Create an admin value and pass it to sendNotification.
47     lisa := admin{\"Lisa\", \"lisa\@email.com\"}
48     sendNotification(&lisa)
49 }",
          ],
          [
            1,
            '[ap 05:49] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.49',
            'Finally, in listing <<5.49|5a:0>> you see it all come together. A value of type user is created on line 43 in the main function, and then the address of that value is passed into send-Notification on line 44. This causes the notify method declared by the user type to be executed. Then we do the same with a value of type admin on lines 47 and 48. In the end, because sendNotification accepts interface values of type notifier, the function can execute the behavior implemented by both user and admin.',
          ],
          [
            1,
            '[ap 05:50] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.50',
            "Let\x{2019}s start with a sample program that shows the basics of type embedding.
Listing <<5.50|5a:0>>. listing50.go
01 // Sample program to show how to embed a type into another type and
02 // the relationship between the inner and outer type.
03 package main
04
05 import (
06     \"fmt\"
07 )
08
09 // user defines a user in the program.
10 type user struct {
11     name  string
12     email string
13 }
14
15 // notify implements a method that can be called via
16 // a value of type user.
17 func (u *user) notify() {
18     fmt.Printf(\"Sending user email to %s<%s>\\n\",
19     u.name,
20     u.email)
21 }
22
23 // admin represents an admin user with privileges.
24 type admin struct {
25     user  // Embedded Type
26     level string
27 }
28
29 // main is the entry point for the application.
30 func main() {
31     // Create an admin user.
32     ad := admin{
33         user: user{
34             name:  \"john smith\",
35             email: \"john\@yahoo.com\",
36         },
37         level: \"super\",
38     }
39
40     // We can access the inner type's method directly.
41     ad.user.notify()
42
43     // The inner type's method is promoted.
44     ad.notify()
45 }",
          ],
          [
            1,
            '[ap 05:50] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.50',
            'In listing <<5.50|5a:0>>, we have a program that shows how to embed a type and access the embedded identifiers. We start with the declaration of two struct types on lines 10 and 24.',
          ],
          [
            1,
            '[ap 05:50] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.50',
            "In listing <<5.50|5a:0>>, we have a program that shows how to embed a type and access the embedded identifiers. We start with the declaration of two struct types on lines 10 and 24.
Listing <<5.51|5a:0>>. listing50.go: lines 09\x{2013}13, <<23\x{2013}27|5a:0>>
09 // user defines a user in the program.
10 type user struct {
11     name  string
12     email string
13 }",
          ],
          [
            1,
            '[ap 05:51] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.51',
            'On line 10 in listing <<5.51|5a:0>>, we have the declaration of a struct type named user, and then on line 24 we have the declaration of a second struct type named admin. Inside the declaration of the admin type on line 25, we have the embedding of the user type as an inner type of admin. To embed a type, all that needs to happen is for the type name to be declared. One line 26, we have the declaration of a field named level. Notice the difference between declaring a field and embedding a type.',
          ],
          [
            1,
            '[ap 05:52] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.52',
            "Once we embed the user type inside of admin, we can say that user is an inner type of the outer type admin. The concept of having an inner and outer type makes it easier to understand the relationship between the two.
Listing <<5.52|5a:0>>. listing50.go: lines 15\x{2013}21
15 // notify implements a method that can be called via
16 // a value of type user.
17 func (u *user) notify() {
18     fmt.Printf(\"Sending user email to %s<%s>\\n\",
19     u.name,
20     u.email)
21 }",
          ],
          [
            1,
            '[ap 05:52] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.52',
            "Listing <<5.52|5a:0>> shows the declaration of a method named notify using a pointer receiver of type user. The method just displays a friendly message stating an email is being sent to a specific user and email address. Now let\x{2019}s look at the main function.",
          ],
          [
            1,
            '[ap 05:52] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.52',
            "Listing <<5.52|5a:0>> shows the declaration of a method named notify using a pointer receiver of type user. The method just displays a friendly message stating an email is being sent to a specific user and email address. Now let\x{2019}s look at the main function.
Listing <<5.53|5a:0>>. listing50.go: lines 30\x{2013}45
30 func main() {
31     // Create an admin user.
32     ad := admin{
33         user: user{
34             name:  \"john smith\",
35             email: \"john\@yahoo.com\",
36         },",
          ],
          [
            1,
            '[ap 05:53] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.53',
            "The main function in listing <<5.53|5a:0>> shows the mechanics behind type embedding. On line 32, a value of type admin is created. The initialization of the inner type is performed using a struct literal, and to access the inner type we just need to use the type\x{2019}s name. Something special about an inner type is that it always exists in and of itself. This means the inner type never loses its identity and can always be accessed directly.",
          ],
          [
            1,
            '[ap 05:53] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.53',
            "The main function in listing <<5.53|5a:0>> shows the mechanics behind type embedding. On line 32, a value of type admin is created. The initialization of the inner type is performed using a struct literal, and to access the inner type we just need to use the type\x{2019}s name. Something special about an inner type is that it always exists in and of itself. This means the inner type never loses its identity and can always be accessed directly.
Listing <<5.54|5a:0>>. listing50.go: lines 40\x{2013}41
40     // We can access the inner type's method directly.
41     ad.user.notify()",
          ],
          [
            1,
            '[ap 05:54] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.54',
            'On line 41 in listing <<5.54|5a:0>>, you see a call to the notify method. This call is made by accessing the user inner type directly through the admin outer type variable ad. This shows how the inner type exists in and of itself and is always accessible. But thanks to inner type promotion, the notify method can also be accessed directly from the ad variable.',
          ],
          [
            1,
            '[ap 05:54] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.54',
            "On line 41 in listing <<5.54|5a:0>>, you see a call to the notify method. This call is made by accessing the user inner type directly through the admin outer type variable ad. This shows how the inner type exists in and of itself and is always accessible. But thanks to inner type promotion, the notify method can also be accessed directly from the ad variable.
Listing <<5.55|5a:0>>. listing50.go: lines 43\x{2013}45
43     // The inner type's method is promoted.
44     ad.notify()
45 }",
          ],
          [
            1,
            '[ap 05:55] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.55',
            "Listing <<5.55|5a:0>> on line 44 shows the method call to notify from the outer type variable. Since the identifiers of the inner type are promoted up to the outer type, we can access the inner type\x{2019}s identifiers through values of the outer type. Let\x{2019}s change the sample by adding an interface.",
          ],
          [
            1,
            '[ap 05:55] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.55',
            "Listing <<5.55|5a:0>> on line 44 shows the method call to notify from the outer type variable. Since the identifiers of the inner type are promoted up to the outer type, we can access the inner type\x{2019}s identifiers through values of the outer type. Let\x{2019}s change the sample by adding an interface.
Listing <<5.56|5a:0>>. listing56.go
01 // Sample program to show how embedded types work with interfaces.
02 package main
03
04 import (
05     \"fmt\"
06 )
07
08 // notifier is an interface that defined notification
09 // type behavior.
10 type notifier interface {
11     notify()",
          ],
          [
            1,
            '[ap 05:56] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.56',
            'The sample code in listing <<5.56|5a:0>> uses the same code from before but with a few changes.',
          ],
          [
            1,
            '[ap 05:56] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.56',
            "The sample code in listing <<5.56|5a:0>> uses the same code from before but with a few changes.
Listing <<5.57|5a:0>>. listing56.go: lines 08\x{2013}12, 51\x{2013}55
08 // notifier is an interface that defined notification
09 // type behavior.
10 type notifier interface {
11     notify()
12 }",
          ],
          [
            1,
            '[ap 05:57] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.57',
            'On line 08 in listing <<5.57|5a:0>>, we have the declaration of the notifier interface. Then on line 53, we have the sendNotification function that accepts an interface value of type notifier. We know from the code before that the user type has declared a method named notify that implements the notifier interface with a pointer receiver. Therefore, we can move on to the changes made to the main function.',
          ],
          [
            1,
            '[ap 05:57] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.57',
            "On line 08 in listing <<5.57|5a:0>>, we have the declaration of the notifier interface. Then on line 53, we have the sendNotification function that accepts an interface value of type notifier. We know from the code before that the user type has declared a method named notify that implements the notifier interface with a pointer receiver. Therefore, we can move on to the changes made to the main function.
Listing <<5.58|5a:0>>. listing56.go: lines 35\x{2013}49
35 func main() {
36     // Create an admin user.
37     ad := admin{
38         user: user{
39             name:  \"john smith\",
40             email: \"john\@yahoo.com\",
41         },
42         level: \"super\",
43     }
44
45     // Send the admin user a notification.
46     // The embedded inner type's implementation of the
47     // interface is \"promoted\" to the outer type.
48     sendNotification(&ad)
49 }",
          ],
          [
            1,
            '[ap 05:58] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.58',
            "This is where things get interesting. On line 37 in listing <<5.58|5a:0>>, we create the admin outer type variable ad. Then on line 48, we pass the address of the outer type variable to the sendNotification function. The compiler accepts the assignment of the outer type pointer as a value that implements the notifier interface. But if you look at the entire sample program, you won\x{2019}t see the admin type implement the interface.",
          ],
          [
            1,
            '[ap 05:59] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.59',
            "Thanks to inner type promotion, the implementation of the interface by the inner type has been promoted up to the outer type. That means the outer type now implements the interface, thanks to the inner type\x{2019}s implementation. When we run this sample program, we get the following output.
Listing <<5.59|5a:0>>. Output for listing56.go
Output:
Sending user email to john smith<john\@yahoo.com>",
          ],
          [
            1,
            '[ap 05:59] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.59',
            "You can see in listing <<5.59|5a:0>> that the inner type\x{2019}s implementation of the interface was called.",
          ],
          [
            1,
            '[ap 06:00] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.60',
            "What if the outer type doesn\x{2019}t want to use the inner type\x{2019}s implementation because it needs an implementation of its own? Let\x{2019}s look at another sample program that solves that problem.
Listing <<5.60|5a:0>>. listing60.go
01 // Sample program to show what happens when the outer and inner
02 // types implement the same interface.
03 package main
04
05 import (
06     \"fmt\"
07 )
08
09 // notifier is an interface that defined notification
10 // type behavior.
11 type notifier interface {
12     notify()
13 }
14
15 // user defines a user in the program.
16 type user struct {
17     name  string
18     email string
19 }
20
21 // notify implements a method that can be called via
22 // a value of type user.
23 func (u *user) notify() {
24     fmt.Printf(\"Sending user email to %s<%s>\\n\",
25         u.name,
26         u.email)
27 }
28
29 // admin represents an admin user with privileges.
30 type admin struct {
31     user
32     level string
33 }
34
35 // notify implements a method that can be called via
36 // a value of type admin.
37 func (a *admin) notify() {
38     fmt.Printf(\"Sending admin email to %s<%s>\\n\",
39         a.name,
40         a.email)
41 }
42
43 // main is the entry point for the application.
44 func main() {
45     // Create an admin user.",
          ],
          [
            1,
            '[ap 06:00] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.60',
            'The sample code in listing <<5.60|5a:0>> uses the same code from before, but with a few more changes.',
          ],
          [
            1,
            "[23:26] Go in Action - William Kennedy.epub (kindle_split_014.html) - 23\x{2013}26",
            "Once the two anonymous functions are created as goroutines, the code in main keeps running. This means that the main function can return before the goroutines complete their work. If this happens, the program will terminate before the goroutines have a chance to run. On line 51, the main function therefore waits for both goroutines to complete their work by using a WaitGroup.
Listing 6.3. listing01.go: lines 17\x{2013}19, <<23\x{2013}26|5a:0>>, 49\x{2013}51
16     // wg is used to wait for the program to finish.
17     // Add a count of two, one for each goroutine.
18     var wg sync.WaitGroup
19     wg.Add(2)",
          ],
          [
            1,
            '[ap 06:10] Go in Action - William Kennedy.epub (kindle_split_014.html) - 6.10',
            '16     wg sync.WaitGroup
17 )
18
19 // main is the entry point for all Go programs.
20 func main() {
21     // Add a count of two, one for each goroutine.
22     wg.Add(2)
23
24     // Create two goroutines.
25     go incCounter(1)
26     go incCounter(2)
27
28     // Wait for the goroutines to finish.
29     wg.Wait()
30     fmt.Println("Final Counter:", counter)
31 }
32
33 // incCounter increments the package level counter variable.
34 func incCounter(id int) {
35     // Schedule the call to Done to tell main we are done.
36     defer wg.Done()
37
38     for count := 0; count < 2; count++ {
39         // Capture the value of Counter.
40         value := counter
41
42         // Yield the thread and be placed back in queue.
43         runtime.Gosched()
44
45         // Increment our local value of Counter.
46         value++
47
48         // Store the value back into Counter.
49         counter = value
50     }
51 }
Listing <<6.10|5a:0>>. Output for listing09.go
Final Counter: 2',
          ],
          [
            1,
            '[ap 06:11] Go in Action - William Kennedy.epub (kindle_split_014.html) - 6.11',
            "Go has a special tool that can detect race conditions in your code. It\x{2019}s extremely useful to find these types of bugs, especially when they\x{2019}re not as obvious as our example. Let\x{2019}s run the race detector against our example code.
Listing <<6.11|5a:0>>. Building and running listing09 with the race detector
go build -race   // Build the code using the race detector flag
./example        // Run the code",
          ],
          [
            1,
            '[ap 06:11] Go in Action - William Kennedy.epub (kindle_split_014.html) - 6.11',
            'The race detector in listing <<6.11|5a:0>> has pointed out the following four lines of code from our example.',
          ],
          [
            1,
            '[ap 06:11] Go in Action - William Kennedy.epub (kindle_split_014.html) - 6.11',
            'The race detector in listing <<6.11|5a:0>> has pointed out the following four lines of code from our example.
Listing <<6.12|5a:0>>. Lines of code called out by the race detector
Line 49: counter = value
Line 40: value := counter
Line 25: go incCounter(1)
Line 26: go incCounter(2)',
          ],
          [
            1,
            '[ap 06:12] Go in Action - William Kennedy.epub (kindle_split_014.html) - 6.12',
            "Listing <<6.12|5a:0>> shows that the race detector has told us which goroutine is causing the data race and which two lines of code are in conflict. It\x{2019}s not surprising that the code that\x{2019}s pointed out is reading from and writing to the counter variable.",
          ],
          [
            1,
            '[ap 06:13] Go in Action - William Kennedy.epub (kindle_split_014.html) - 6.13',
            'Atomic functions provide low-level locking mechanisms for synchronizing access to integers and pointers. We can use atomic functions to fix the race condition we created in listing 6.9.
Listing <<6.13|5a:0>>. listing13.go
01 // This sample program demonstrates how to use the atomic
02 // package to provide safe access to numeric types.
03 package main',
          ],
          [
            1,
            '[ap 06:14] Go in Action - William Kennedy.epub (kindle_split_014.html) - 6.14',
            '04
05 import (
06     "fmt"
07     "runtime"
08     "sync"
09     "sync/atomic"
10 )
11
12 var (
13     // counter is a variable incremented by all goroutines.
14     counter int64
15
16     // wg is used to wait for the program to finish.
17     wg sync.WaitGroup
18 )
19
20 // main is the entry point for all Go programs.
21 func main() {
22     // Add a count of two, one for each goroutine.
23     wg.Add(2)
24
25     // Create two goroutines.
26     go incCounter(1)
27     go incCounter(2)
28
29     // Wait for the goroutines to finish.
30     wg.Wait()
31
32     // Display the final value.
33     fmt.Println("Final Counter:", counter)
34 }
35
36 // incCounter increments the package level counter variable.
37 func incCounter(id int) {
38     // Schedule the call to Done to tell main we are done.
39     defer wg.Done()
40
41     for count := 0; count < 2; count++ {
42         // Safely Add One To Counter.
43         atomic.AddInt64(&counter, 1)
44
45         // Yield the thread and be placed back in queue.
46         runtime.Gosched()
47     }
48 }
Listing <<6.14|5a:0>>. Output for listing13.go
Final Counter: 4',
          ],
          [
            1,
            '[ap 06:15] Go in Action - William Kennedy.epub (kindle_split_014.html) - 6.15',
            "Two other useful atomic functions are LoadInt64 and StoreInt64. These functions provide a safe way to read and write to an integer value. Here\x{2019}s an example using LoadInt64 and StoreInt64 to create a synchronous flag that can alert multiple goroutines of a special condition in a program.
Listing <<6.15|5a:1>>. listing15.go
01 // This sample program demonstrates how to use the atomic
02 // package functions Store and Load to provide safe access
03 // to numeric types.
04 package main
05
06 import (
07     \"fmt\"
08     \"sync\"
09     \"sync/atomic\"
10     \"time\"
11 )
12
13 var (
14     // shutdown is a flag to alert running goroutines to shutdown.
15     shutdown int64
16
17     // wg is used to wait for the program to finish.
18     wg sync.WaitGroup
19 )
20
21 // main is the entry point for all Go programs.
22 func main() {
23     // Add a count of two, one for each goroutine.
24     wg.Add(2)
25
26     // Create two goroutines.
27     go doWork(\"A\")
28     go doWork(\"B\")
29
30     // Give the goroutines time to run.
31     time.Sleep(1 * time.Second)
32
33     // Safely flag it is time to shutdown.
34     fmt.Println(\"Shutdown Now\")
35     atomic.StoreInt64(&shutdown, 1)
36
37     // Wait for the goroutines to finish.
38     wg.Wait()
39 }
40
41 // doWork simulates a goroutine performing work and
42 // checking the Shutdown flag to terminate early.
43 func doWork(name string) {
44     // Schedule the call to Done to tell main we are done.",
          ],
          [
            1,
            '[ap 06:16] Go in Action - William Kennedy.epub (kindle_split_014.html) - 6.16',
            'Another way to synchronize access to a shared resource is by using a mutex. A mutex is named after the concept of mutual exclusion. A mutex is used to create a critical section around code that ensures only one goroutine at a time can execute that code section. We can also use a mutex to fix the race condition we created in listing 6.9.
Listing <<6.16|5a:0>>. listing16.go
01 // This sample program demonstrates how to use a mutex
02 // to define critical sections of code that need synchronous
03 // access.
04 package main
05
06 import (
07     "fmt"
08     "runtime"
09     "sync"
10 )
11
12 var (
13     // counter is a variable incremented by all goroutines.
14     counter int
15
16     // wg is used to wait for the program to finish.
17     wg sync.WaitGroup',
          ],
          [
            1,
            '[ap 06:17] Go in Action - William Kennedy.epub (kindle_split_014.html) - 6.17',
            'Creating a channel in Go requires the use of the built-in function make.
Listing <<6.17|5a:0>>. Using make to create a channel
// Unbuffered channel of integers.
unbuffered := make(chan int)',
          ],
          [
            1,
            '[ap 06:17] Go in Action - William Kennedy.epub (kindle_split_014.html) - 6.17',
            "In listing <<6.17|5a:0>> you see the use of the built-in function make to create both an unbuffered and buffered channel. The first argument to make requires the keyword chan and then the type of data the channel will allow to be exchanged. If you\x{2019}re creating a buffered channel, then you specify the size of the channel\x{2019}s buffer as the second argument.",
          ],
          [
            1,
            '[ap 06:18] Go in Action - William Kennedy.epub (kindle_split_014.html) - 6.18',
            'Sending a value or pointer into a channel requires the use of the <- operator.
Listing <<6.18|5a:0>>. Sending values into a channel
// Buffered channel of strings.
buffered := make(chan string, 10)',
          ],
          [
            1,
            '[ap 06:18] Go in Action - William Kennedy.epub (kindle_split_014.html) - 6.18',
            "In listing <<6.18|5a:0>> we create a buffered channel of type string that contains a buffer of 10 values. Then we send the string \x{201c}Gopher\x{201d} through the channel. For another goroutine to receive that string from the channel, we use the same <- operator, but this time as a unary operator.",
          ],
          [
            1,
            '[ap 06:18] Go in Action - William Kennedy.epub (kindle_split_014.html) - 6.18',
            "In listing <<6.18|5a:0>> we create a buffered channel of type string that contains a buffer of 10 values. Then we send the string \x{201c}Gopher\x{201d} through the channel. For another goroutine to receive that string from the channel, we use the same <- operator, but this time as a unary operator.
Listing <<6.19|5a:0>>. Receiving values from a channel
// Receive a string from the channel.
value := <-buffered",
          ],
          [
            1,
            '[ap 06:19] Go in Action - William Kennedy.epub (kindle_split_014.html) - 6.19',
            'When receiving a value or pointer from a channel, the <- operator is attached to the left side of the channel variable, as seen in listing <<6.19|5a:0>>.',
          ],
          [
            1,
            '[ap 06:20] Go in Action - William Kennedy.epub (kindle_split_014.html) - 6.20',
            'In the game of tennis, two players hit a ball back and forth to each other. The players are always in one of two states: either waiting to receive the ball, or sending the ball back to the opposing player. You can simulate a game of tennis using two goroutines and an unbuffered channel to simulate the exchange of the ball.
Listing <<6.20|5a:0>>. listing20.go
01 // This sample program demonstrates how to use an unbuffered
02 // channel to simulate a game of tennis between two goroutines.
03 package main
04
05 import (
06     "fmt"
07     "math/rand"
08     "sync"
09     "time"
10 )
11
12 // wg is used to wait for the program to finish.
13 var wg sync.WaitGroup
14
15 func init() {
16     rand.Seed(time.Now().UnixNano())
17 }
18
19 // main is the entry point for all Go programs.
20 func main() {
21     // Create an unbuffered channel.
22     court := make(chan int)
23
24     // Add a count of two, one for each goroutine.
25     wg.Add(2)
26
27     // Launch two players.
28     go player("Nadal", court)
29     go player("Djokovic", court)
30
31     // Start the set.
32     court <- 1
33
34     // Wait for the game to finish.
35     wg.Wait()
36 }
37',
          ],
          [
            1,
            '[ap 06:21] Go in Action - William Kennedy.epub (kindle_split_014.html) - 6.21',
            'When you run the program, you get the following output.
Listing <<6.21|5a:0>>. Output for listing20.go
Player Nadal Hit 1
Player Djokovic Hit 2
Player Nadal Hit 3
Player Djokovic Missed
Player Nadal Won',
          ],
          [
            1,
            '[ap 06:22] Go in Action - William Kennedy.epub (kindle_split_014.html) - 6.22',
            "Another example that uses a different pattern to synchronize goroutines with an unbuffered channel is simulating a relay race. In a relay race, four runners take turns running around the track. The second, third, and fourth runners can\x{2019}t start running until they receive the baton from the previous runner. The exchange of the baton is a critical part of the race and requires synchronization to not miss a step. For this synchronization to take place, both runners who are involved in the exchange need to be ready at exactly the same time.
Listing <<6.22|5a:0>>. listing22.go
01 // This sample program demonstrates how to use an unbuffered
02 // channel to simulate a relay race between four goroutines.
03 package main
04
05 import (
06     \"fmt\"
07     \"sync\"
08     \"time\"
09 )
10
11 // wg is used to wait for the program to finish.
12 var wg sync.WaitGroup
13
14 // main is the entry point for all Go programs.
15 func main() {
16     // Create an unbuffered channel.
17     baton := make(chan int)
18
19     // Add a count of one for the last runner.
20     wg.Add(1)
21
22     // First runner to his mark.
23     go Runner(baton)
24
25     // Start the race.
26     baton <- 1
27
28     // Wait for the race to finish.
29     wg.Wait()
30 }
31
32 // Runner simulates a person running in the relay race.
33 func Runner(baton chan int) {
34     var newRunner int",
          ],
          [
            1,
            '[ap 06:23] Go in Action - William Kennedy.epub (kindle_split_014.html) - 6.23',
            'When you run the program, you get the following output.
Listing <<6.23|5a:0>>. Output for listing22.go
Runner 1 Running With Baton
Runner 1 Exchange With Runner 2
Runner 2 Running With Baton
Runner 2 Exchange With Runner 3
Runner 3 Running With Baton
Runner 3 Exchange With Runner 4
Runner 4 Running With Baton
Runner 4 Finished, Race Over',
          ],
          [
            1,
            '[ap 06:24] Go in Action - William Kennedy.epub (kindle_split_014.html) - 6.24',
            "Let\x{2019}s look at an example using a buffered channel to manage a set of goroutines to receive and process work. Buffered channels provide a clean and intuitive way to implement this code.
Listing <<6.24|5a:0>>. listing24.go
01 // This sample program demonstrates how to use a buffered
02 // channel to work on multiple tasks with a predefined number
03 // of goroutines.
04 package main
05
06 import (
07     \"fmt\"
08     \"math/rand\"
09     \"sync\"
10     \"time\"
11 )
12
13 const (
14     numberGoroutines = 4  // Number of goroutines to use.
15     taskLoad         = 10 // Amount of work to process.
16 )
17
18 // wg is used to wait for the program to finish.
19 var wg sync.WaitGroup
20
21 // init is called to initialize the package by the
22 // Go runtime prior to any other code being executed.
23 func init() {
24     // Seed the random number generator.
25     rand.Seed(time.Now().Unix())
26 }
27
28 // main is the entry point for all Go programs.
29 func main() {
30     // Create a buffered channel to manage the task load.
31     tasks := make(chan string, taskLoad)
32
33     // Launch goroutines to handle the work.
34     wg.Add(numberGoroutines)
35     for gr := 1; gr <= numberGoroutines; gr++ {
36         go worker(tasks, gr)
37     }
38
39     // Add a bunch of work to get done.
40     for post := 1; post <= taskLoad; post++ {
41         tasks <- fmt.Sprintf(\"Task : %d\", post)
42     }",
          ],
          [
            1,
            '[ap 06:25] Go in Action - William Kennedy.epub (kindle_split_014.html) - 6.25',
            'When you run the program, you get the following output.
Listing <<6.25|5a:0>>. Output for listing24.go
Worker: 1 : Started Task : 1
Worker: 2 : Started Task : 2
Worker: 3 : Started Task : 3
Worker: 4 : Started Task : 4
Worker: 1 : Completed Task : 1
Worker: 1 : Started Task : 5
Worker: 4 : Completed Task : 4
Worker: 4 : Started Task : 6
Worker: 1 : Completed Task : 5',
          ],
          [
            1,
            '[ap 07:10] Go in Action - William Kennedy.epub (kindle_split_015.html) - 7.10',
            "Now let\x{2019}s look at the run method.
Listing <<7.10|5a:0>>. runner/runner.go: lines 72\x{2013}85
72 // run executes each registered task.
73 func (r *Runner) run() error {
74     for id, task := range r.tasks {",
          ],
          [
            1,
            '[ap 07:10] Go in Action - William Kennedy.epub (kindle_split_015.html) - 7.10',
            'The run method on line 73 in listing <<7.10|5a:0>> iterates over the tasks slice and executes each function in order. Before any function is executed on line 81, the gotInterrupt method is called on line 76 to see if there are any events to receive from the operating system.',
          ],
          [
            1,
            '[ap 07:10] Go in Action - William Kennedy.epub (kindle_split_015.html) - 7.10',
            "The run method on line 73 in listing <<7.10|5a:0>> iterates over the tasks slice and executes each function in order. Before any function is executed on line 81, the gotInterrupt method is called on line 76 to see if there are any events to receive from the operating system.
Listing <<7.11|5a:0>>. runner/runner.go: lines 87\x{2013}101
 87 // gotInterrupt verifies if the interrupt signal has been issued.
 88 func (r *Runner) gotInterrupt() bool {
 89     select {
 90     // Signaled when an interrupt event is sent.
 91     case <-r.interrupt:
 92         // Stop receiving any further signals.
 93         signal.Stop(r.interrupt)
 95         return true
 96
 97     // Continue running as normal.
 98     default:
 99         return false
100     }
101 }",
          ],
          [
            1,
            '[ap 07:11] Go in Action - William Kennedy.epub (kindle_split_015.html) - 7.11',
            "The gotInterrupt method in listing <<7.11|5a:0>> shows a classic use of the select statement with a default case. On line 91, the code attempts to receive on the interrupt channel. Normally that would block if there was nothing to receive, but we have a default case on line 98. The default case turns the attempt to receive on the interrupt channel into a nonblocking call. If there\x{2019}s an interrupt to receive, then it\x{2019}s received and processed. If there\x{2019}s nothing to receive, the default case is then executed.",
          ],
          [
            1,
            '[ap 07:12] Go in Action - William Kennedy.epub (kindle_split_015.html) - 7.12',
            "The final method in the package is called Start.
Listing <<7.12|5a:0>>. runner/runner.go: lines 51\x{2013}70
51 // Start runs all tasks and monitors channel events.
52 func (r *Runner) Start() error {",
          ],
          [
            1,
            '[ap 07:12] Go in Action - William Kennedy.epub (kindle_split_015.html) - 7.12',
            'The Start method implements the main workflow for the program. In listing <<7.12|5a:0>> on line 52, Start sets up the ability for the gotInterrupt method to receive interrupt events from the operating system. On lines 56 through 59, an anonymous function is declared and created as a goroutine. This is the goroutine that executes the set of assigned tasks for the program. On line 58, inside this goroutine, the run method is called and the returned error interface value is sent on the complete channel. Once the error interface value is received, the goroutine returns that value to the caller.',
          ],
          [
            1,
            '[ap 07:13] Go in Action - William Kennedy.epub (kindle_split_015.html) - 7.13',
            "Now that you\x{2019}ve seen the code for the runner package and learned how it works, let\x{2019}s review the test program in the main.go source code file.
Listing <<7.13|5a:0>>. runner/main/main.go
01 // This sample program demonstrates how to use a channel to
02 // monitor the amount of time the program is running and terminate
03 // the program if it runs too long.
03 package main
04
05 import (
06     \"log\"
07     \"time\"
08
09     \"github.com/goinaction/code/chapter7/patterns/runner\"
10 )",
          ],
          [
            1,
            '[ap 07:13] Go in Action - William Kennedy.epub (kindle_split_015.html) - 7.13',
            'The main function can be found on line 16 in listing <<7.13|5a:0>>. On line 20 the timeout value is passed to the New function, and a pointer of type Runner is returned. Then the createTask function is added to the Runner several times on line 23. The createTask function, declared on line 42, is a function that just pretends to perform some work for a specified amount of time. Once the functions have been added, the Start method is called on line 26 and the main function waits for Start to return.',
          ],
          [
            1,
            '[ap 07:14] Go in Action - William Kennedy.epub (kindle_split_015.html) - 7.14',
            "Let\x{2019}s take a look at the pool.go code file from the pool package.
Listing <<7.14|5a:0>>. pool/pool.go
 01 // Example provided with help from Fatih Arslan and Gabriel Aszalos.
 02 // Package pool manages a user defined set of resources.
 03 package pool
 04
 05 import (
 06     \"errors\"
 07     \"log\"
 08     \"io\"
 09     \"sync\"
 10 )
 11
 12 // Pool manages a set of resources that can be shared safely by
 13 // multiple goroutines. The resource being managed must implement
 14 // the io.Closer interface.
 15 type Pool struct {
 16     m         sync.Mutex
 17     resources chan io.Closer
 18     factory   func() (io.Closer, error)
 19     closed    bool
 20 }
 21
 22 // ErrPoolClosed is returned when an Acquire returns on a
 23 // closed pool.
 24 var ErrPoolClosed = errors.New(\"Pool has been closed.\")
 25
 26 // New creates a pool that manages resources. A pool requires a
 27 // function that can allocate a new resource and the size of
 28 // the pool.
 29 func New(fn func() (io.Closer, error), size uint) (*Pool, error) {
 30     if size <= 0 {
 31         return nil, errors.New(\"Size value too small.\")
 32     }
 33
 34     return &Pool{
 35         factory:   fn,
 36         resources: make(chan io.Closer, size),
 37     }, nil
 38 }
 39
 40 // Acquire retrieves a resource from the pool.
 41 func (p *Pool) Acquire() (io.Closer, error) {",
          ],
          [
            1,
            '[ap 07:14] Go in Action - William Kennedy.epub (kindle_split_015.html) - 7.14',
            "The code for the pool package in listing <<7.14|5a:0>> declares a struct named Pool that allows the caller to create as many different pools as needed. Each pool can manage any type of resource as long as the type implements the io.Closer interface. Let\x{2019}s take a look at the declaration of the Pool struct.",
          ],
          [
            1,
            '[ap 07:14] Go in Action - William Kennedy.epub (kindle_split_015.html) - 7.14',
            "The code for the pool package in listing <<7.14|5a:0>> declares a struct named Pool that allows the caller to create as many different pools as needed. Each pool can manage any type of resource as long as the type implements the io.Closer interface. Let\x{2019}s take a look at the declaration of the Pool struct.
Listing <<7.15|5a:0>>. pool/pool.go: lines 12\x{2013}20
12 // Pool manages a set of resources that can be shared safely by
13 // multiple goroutines. The resource being managed must implement
14 // the io.Closer interface.
15 type Pool struct {
16     m         sync.Mutex
17     resources chan io.Closer
18     factory   func() (io.Closer, error)
19     closed    bool
20 }",
          ],
          [
            1,
            '[ap 07:16] Go in Action - William Kennedy.epub (kindle_split_015.html) - 7.16',
            "The final field on line 19 is the closed field. This field is a flag that indicates the Pool is being shut down or is already shut down. Now that you\x{2019}ve seen the declaration of the Pool struct, let\x{2019}s look at the error interface variable that\x{2019}s declared on line 24.
Listing <<7.16|5a:0>>. pool/pool.go: lines 22\x{2013}24
22 // ErrPoolClosed is returned when an Acquire returns on a
23 // closed pool.
24 var ErrPoolClosed = errors.New(\"Pool has been closed.\")",
          ],
          [
            1,
            '[ap 07:16] Go in Action - William Kennedy.epub (kindle_split_015.html) - 7.16',
            'Creating error interface variables is a common practice in Go. This allows the caller to identify specific returned error values from any function or method within the package. The error interface variable in listing <<7.16|5a:0>> has been declared to report when the user calls the Acquire method and the Pool has been closed. Since the Acquire method can return multiple different errors, returning this error variable when the Pool is closed allows the caller to identify this specific error over others.',
          ],
          [
            1,
            '[ap 07:17] Go in Action - William Kennedy.epub (kindle_split_015.html) - 7.17',
            "With the Pool type and the error interface variable declared, we can start to look at the functions and methods that are declared in the pool package. Let\x{2019}s start with the pool\x{2019}s factory function, named New.
Listing <<7.17|5a:0>>. pool/pool.go: lines 26\x{2013}38
26 // New creates a pool that manages resources. A pool requires a
27 // function that can allocate a new resource and the size of
28 // the pool.
29 func New(fn func() (io.Closer, error), size uint) (*Pool, error) {
30     if size <= 0 {
31         return nil, errors.New(\"Size value too small.\")
32     }
33
34     return &Pool{
35         factory:   fn,
36         resources: make(chan io.Closer, size),
37     }, nil
38 }",
          ],
          [
            1,
            '[ap 07:17] Go in Action - William Kennedy.epub (kindle_split_015.html) - 7.17',
            'The New function in listing <<7.17|5a:0>> accepts two parameters and returns two values. The first parameter, fn, is declared as a function type that accepts no parameters and returns an io.Closer and an error interface value. The function parameter represents a factory function that creates values of the resource being managed by the pool. The second parameter, size, represents the size of the buffered channel created to hold the resources.',
          ],
          [
            1,
            '[ap 07:18] Go in Action - William Kennedy.epub (kindle_split_015.html) - 7.18',
            "With the ability to create and initialize a Pool value, next let\x{2019}s look at the Acquire method. This method allows the caller to acquire a resource from the pool.
Listing <<7.18|5a:0>>. pool/pool.go: lines 40\x{2013}56
40 // Acquire retrieves a resource from the pool.
41 func (p *Pool) Acquire() (io.Closer, error) {
42     select {
43     // Check for a free resource.
44     case r, ok := <-p.resources:
45         log.Println(\"Acquire:\", \"Shared Resource\")
46         if !ok {
47             return nil, ErrPoolClosed
48         }
49         return r, nil
50
51     // Provide a new resource since there are none available.
52     default:
53         log.Println(\"Acquire:\", \"New Resource\")
54         return p.factory()
55     }
56 }",
          ],
          [
            1,
            '[ap 07:18] Go in Action - William Kennedy.epub (kindle_split_015.html) - 7.18',
            "Listing <<7.18|5a:0>> contains the code for the Acquire method. This method returns a resource from the pool if one is available, or creates a new one for the call. This implementation is accomplished by using a select / case statement to check if there\x{2019}s a resource in the buffered channel. If there is, it\x{2019}s received and then returned to the caller. This can be seen on lines 44 and 49. If there\x{2019}s no resource in the buffered channel to receive, then the default case is executed. In this case, on line 54 the user\x{2019}s factory function is executed and a new resource is created and returned.",
          ],
          [
            1,
            '[ap 07:19] Go in Action - William Kennedy.epub (kindle_split_015.html) - 7.19',
            "After a resource is acquired and no longer needed, it must be released back into the pool. This is where the Release method comes in. But to understand the mechanics behind the code in the Release method, we need to look at the Close method first.
Listing <<7.19|5a:0>>. pool/pool.go: lines 82\x{2013}104
 82 // Close will shutdown the pool and close all existing resources.
 83 func (p *Pool) Close() {
 84     // Secure this operation with the Release operation.
 85     p.m.Lock()
 86     defer p.m.Unlock()
 87
 88     // If the pool is already closed, don't do anything.
 89     if p.closed {
 90         return
 91     }
 92
 93     // Set the pool as closed.
 94     p.closed = true
 95
 96     // Close the channel before we drain the channel of its
 97     // resources. If we don't do this, we will have a deadlock.
 98     close(p.resources)
 99",
          ],
          [
            1,
            '[ap 07:19] Go in Action - William Kennedy.epub (kindle_split_015.html) - 7.19',
            "Once the program is finished with the pool, it should call the Close method. The code for the Close method is shown in listing <<7.19|5a:0>>. The method closes and flushes the buffered channel on lines 98 and 101, closing any resources that exist until the channel is empty. All the code in this method must be executed by only one goroutine at a time. In fact, when this code is being executed, goroutines must also be prevented from executing code in the Release method. You\x{2019}ll understand why this is important soon.",
          ],
          [
            1,
            '[ap 07:20] Go in Action - William Kennedy.epub (kindle_split_015.html) - 7.20',
            "Now we can look at the Release method and see how it works in coordination with the Close method.
Listing <<7.20|5a:0>>. pool/pool.go: lines 58\x{2013}80
58 // Release places a new resource onto the pool.
59 func (p *Pool) Release(r io.Closer) {
60     // Secure this operation with the Close operation.
61     p.m.Lock()
62     defer p.m.Unlock()
63
64     // If the pool is closed, discard the resource.
65     if p.closed {
66         r.Close()
67         return
68     }
69
70     select {
71     // Attempt to place the new resource on the queue.
72     case p.resources <- r:
73         log.Println(\"Release:\", \"In Queue\")
74
75     // If the queue is already at capacity we close the resource.
76     default:
77         log.Println(\"Release:\", \"Closing\")
78         r.Close()
79     }
80 }",
          ],
          [
            1,
            '[ap 07:20] Go in Action - William Kennedy.epub (kindle_split_015.html) - 7.20',
            "The implementation of the Release method can be found in listing <<7.20|5a:0>>. The method starts out with the locking and unlocking of a mutex on lines 61 and 62. This is the same mutex as in the Close method. This is how both methods are prevented from being run at the same time by different goroutines. The use of the mutex serves two purposes. First, it protects the read on the closed flag on line 65 from happening at the same time as a write on this flag in the Close method. Second, we don\x{2019}t want to attempt to send on a closed channel because this will cause a panic. When the closed field is false, we know the resources channel has been closed.",
          ],
          [
            1,
            '[ap 07:21] Go in Action - William Kennedy.epub (kindle_split_015.html) - 7.21',
            "Now that you\x{2019}ve seen the pool code and learned how it works, let\x{2019}s review the test program in the main.go source code file.
Listing <<7.21|5a:0>>. pool/main/main.go
01 // This sample program demonstrates how to use the pool package
02 // to share a simulated set of database connections.
03 package main
04
05 import (
06     \"log\"
07     \"io\"
08     \"math/rand\"
09     \"sync\"
10     \"sync/atomic\"
11     \"time\"
12
13     \"github.com/goinaction/code/chapter7/patterns/pool\"
14 )
15
16 const (
17     maxGoroutines   = 25 // the number of routines to use.
18     pooledResources = 2  // number of resources in the pool
19 )
20
21 // dbConnection simulates a resource to share.
22 type dbConnection struct {
23     ID int32
24 }
25
26 // Close implements the io.Closer interface so dbConnection
27 // can be managed by the pool. Close performs any resource
28 // release management.
29 func (dbConn *dbConnection) Close() error {
30     log.Println(\"Close: Connection\", dbConn.ID)
31     return nil
32 }
33
34 // idCounter provides support for giving each connection a unique id.
35 var idCounter int32
36
37 // createConnection is a factory method that will be called by
38 // the pool when a new connection is needed.
39 func createConnection() (io.Closer, error) {",
          ],
          [
            1,
            '[ap 07:21] Go in Action - William Kennedy.epub (kindle_split_015.html) - 7.21',
            'The code in main.go, shown in listing <<7.21|5a:0>>, uses the pool package to manage a simulated pool of database connections. The code starts out declaring two constants, maxGoroutines and pooledResources, to set the number of goroutines and resources the program is going to use. The declaration of the resource and the implementation of the io.Closer interface follows.',
          ],
          [
            1,
            '[ap 07:21] Go in Action - William Kennedy.epub (kindle_split_015.html) - 7.21',
            "The code in main.go, shown in listing <<7.21|5a:0>>, uses the pool package to manage a simulated pool of database connections. The code starts out declaring two constants, maxGoroutines and pooledResources, to set the number of goroutines and resources the program is going to use. The declaration of the resource and the implementation of the io.Closer interface follows.
Listing <<7.22|5a:0>>. pool/main/main.go: lines 21\x{2013}32
21 // dbConnection simulates a resource to share.
22 type dbConnection struct {
23     ID int32
24 }
25
26 // Close implements the io.Closer interface so dbConnection
27 // can be managed by the pool. Close performs any resource
28 // release management.
29 func (dbConn *dbConnection) Close() error {
30     log.Println(\"Close: Connection\", dbConn.ID)
31     return nil
32 }",
          ],
          [
            1,
            '[ap 07:22] Go in Action - William Kennedy.epub (kindle_split_015.html) - 7.22',
            "Listing <<7.22|5a:1>> shows the declaration of the dbConnection struct and its implementation of the io.Closer interface. The dbConnection type simulates a struct that\x{2019}s managing a database connection and currently has one field, ID, that contains a unique ID for each connection. The Close method just reports that the connection is being closed and displays its ID.",
          ],
          [
            1,
            '[ap 07:23] Go in Action - William Kennedy.epub (kindle_split_015.html) - 7.23',
            "Next we have the factory function that creates values of dbConnection.
Listing <<7.23|5a:0>>. pool/main/main.go: lines 34\x{2013}44
34 // idCounter provides support for giving each connection a unique id.
35 var idCounter int32
36
37 // createConnection is a factory method that will be called by
38 // the pool when a new connection is needed.
39 func createConnection() (io.Closer, error) {
40     id := atomic.AddInt32(&idCounter, 1)
41     log.Println(\"Create: New Connection\", id)
42
43     return &dbConnection{id}, nil
44 }",
          ],
          [
            1,
            '[ap 07:23] Go in Action - William Kennedy.epub (kindle_split_015.html) - 7.23',
            "Listing <<7.23|5a:0>> shows the implementation of the createConnection function. The function generates a new and unique ID for the connection, displays that the connection is being created, and returns a pointer to a value of type dbConnection with this unique ID. The generation of the unique ID is performed with the atomic.AddInt32 function. It\x{2019}s used to safely increment the value of the package level variable idCounter. Now that we have our resource and the factory function, we can use it with the pool package.",
          ],
          [
            1,
            '[ap 07:24] Go in Action - William Kennedy.epub (kindle_split_015.html) - 7.24',
            "Next, let\x{2019}s look at the code inside the main function.
Listing <<7.24|5a:0>>. pool/main/main.go: lines 48\x{2013}55
48     var wg sync.WaitGroup
49     wg.Add(maxGoroutines)
50
51     // Create the pool to manage our connections.
52     p, err := pool.New(createConnection, pooledResources)
53     if err != nil {
54         log.Println(err)
55     }",
          ],
          [
            1,
            '[ap 07:25] Go in Action - William Kennedy.epub (kindle_split_015.html) - 7.25',
            "The main function starts out with declaring a WaitGroup on line 48 and setting the value of the WaitGroup to match the number of goroutines that will be created. The new Pool is created using the New function from the pool package. The factory function and the number of resources to manage are passed in. This returns a pointer to the Pool value and any possible error is checked. Now that we have a Pool, we can create goroutines that can share resources being managed by the pool.
Listing <<7.25|5a:0>>. pool/main/main.go: lines 57\x{2013}66
57     // Perform queries using connections from the pool.
58     for query := 0; query < maxGoroutines; query++ {
59         // Each goroutine needs its own copy of the query
60         // value else they will all be sharing the same query
61         // variable.
62         go func(q int) {
63             performQueries(q, p)
64             wg.Done()
65         }(query)
66     }",
          ],
          [
            1,
            '[ap 07:25] Go in Action - William Kennedy.epub (kindle_split_015.html) - 7.25',
            'A for loop is used in listing <<7.25|5a:0>> to create goroutines that will use the pool. Each goroutine calls the performQueries function once and then quits. The performQueries function is provided a unique ID for logging and the pointer to the Pool. Once all the goroutines are created, the main function then waits for the goroutines to complete.',
          ],
          [
            1,
            '[ap 07:25] Go in Action - William Kennedy.epub (kindle_split_015.html) - 7.25',
            "A for loop is used in listing <<7.25|5a:0>> to create goroutines that will use the pool. Each goroutine calls the performQueries function once and then quits. The performQueries function is provided a unique ID for logging and the pointer to the Pool. Once all the goroutines are created, the main function then waits for the goroutines to complete.
Listing <<7.26|5a:0>>. pool/main/main.go: lines 68\x{2013}73
68     // Wait for the goroutines to finish.
69     wg.Wait()
70
71     // Close the pool.
72     log.Println(\"Shutdown Program.\")
73     p.Close()",
          ],
          [
            1,
            '[ap 07:26] Go in Action - William Kennedy.epub (kindle_split_015.html) - 7.26',
            "In listing <<7.26|5a:0>>, the main function waits on the WaitGroup. Once all the goroutines report they\x{2019}re done, the Pool is closed and the program terminates. Next, let\x{2019}s look at the performQueries function, which uses the pool\x{2019}s Acquire and Release methods.",
          ],
          [
            1,
            '[ap 07:26] Go in Action - William Kennedy.epub (kindle_split_015.html) - 7.26',
            "In listing <<7.26|5a:0>>, the main function waits on the WaitGroup. Once all the goroutines report they\x{2019}re done, the Pool is closed and the program terminates. Next, let\x{2019}s look at the performQueries function, which uses the pool\x{2019}s Acquire and Release methods.
Listing <<7.27|5a:0>>. pool/main/main.go: lines 76\x{2013}91
76 // performQueries tests the resource pool of connections.
77 func performQueries(query int, p *pool.Pool) {
78     // Acquire a connection from the pool.
79     conn, err := p.Acquire()
80     if err != nil {
81         log.Println(err)
82         return
83     }
84
85     // Release the connection back to the pool.
86     defer p.Release(conn)
87
88     // Wait to simulate a query response.
89     time.Sleep(time.Duration(rand.Intn(1000)) * time.Millisecond)
90     log.Printf(\"QID[%d] CID[%d]\\n\", query, conn.(*dbConnection).ID)
91 }",
          ],
          [
            1,
            '[ap 07:27] Go in Action - William Kennedy.epub (kindle_split_015.html) - 7.27',
            "The implementation of the performQueries function in listing <<7.27|5a:0>> shows the use of the pool\x{2019}s Acquire and Release methods. The function starts out by calling the Acquire method to retrieve a dbConnection from the pool. The returned error interface value is checked, and then on line 86 a defer is used to release the dbConnection back into the pool once the function returns. On lines 89 and 90 a random amount of sleep occurs to simulate work time using the dbConnection.",
          ],
          [
            1,
            '[ap 07:28] Go in Action - William Kennedy.epub (kindle_split_015.html) - 7.28',
            "Let\x{2019}s take a look at the work.go code file from the work package.
Listing <<7.28|5a:0>>. work/work.go
01 // Example provided with help from Jason Waldrip.
02 // Package work manages a pool of goroutines to perform work.
03 package work
04
05 import \"sync\"
06
07 // Worker must be implemented by types that want to use
08 // the work pool.
09 type Worker interface {
10     Task()",
          ],
          [
            1,
            '[ap 07:28] Go in Action - William Kennedy.epub (kindle_split_015.html) - 7.28',
            'The work package in listing <<7.28|5a:0>> starts off with the declaration of an interface named Worker and a struct named Pool.',
          ],
          [
            1,
            '[ap 07:28] Go in Action - William Kennedy.epub (kindle_split_015.html) - 7.28',
            "The work package in listing <<7.28|5a:0>> starts off with the declaration of an interface named Worker and a struct named Pool.
Listing <<7.29|5a:0>>. work/work.go: lines 07\x{2013}18
07 // Worker must be implemented by types that want to use
08 // the work pool.
09 type Worker interface {
10     Task()
11 }
12
13 // Pool provides a pool of goroutines that can execute any Worker
14 // tasks that are submitted.
15 type Pool struct {
16     work chan Worker
17     wg   sync.WaitGroup
18 }",
          ],
          [
            1,
            '[ap 07:29] Go in Action - William Kennedy.epub (kindle_split_015.html) - 7.29',
            'The Worker interface on line 09 in listing <<7.29|5a:0>> declares a single method called Task. On line 15 a struct named Pool is declared, which is the type that implements the pool of goroutines and will have methods that process the work. The type declares two fields, one named work, which is a channel of the Worker interface type, and a sync.WaitGroup named wg.',
          ],
          [
            1,
            '[ap 07:30] Go in Action - William Kennedy.epub (kindle_split_015.html) - 7.30',
            "Next let\x{2019}s look at the factory function for the work package.
Listing <<7.30|5a:0>>. work/work.go: lines 20\x{2013}37
20 // New creates a new work pool.
21 func New(maxGoroutines int) *Pool {
22     p := Pool{
23         work: make(chan Worker),
24     }
25
26     p.wg.Add(maxGoroutines)
27     for i := 0; i < maxGoroutines; i++ {
28         go func() {
29             for w := range p.work {
30                 w.Task()
31             }
32             p.wg.Done()
33         }()
34     }
35
36     return &p
37 }",
          ],
          [
            1,
            '[ap 07:30] Go in Action - William Kennedy.epub (kindle_split_015.html) - 7.30',
            "Listing <<7.30|5a:0>> shows the New function that\x{2019}s used to create work pool that\x{2019}s configured with a fixed number of goroutines. The number of goroutines is passed in as a parameter to the New function. On line 22 a value of type Pool is created, and the work field is initialized with an unbuffered channel.",
          ],
          [
            1,
            '[ap 07:31] Go in Action - William Kennedy.epub (kindle_split_015.html) - 7.31',
            "Then, on line 26, the WaitGroup is initialized, and on lines 27 through 34 the same number of goroutines are created. The goroutines just receive interface values of type Worker and call the Task method on those values.
Listing <<7.31|5a:0>>. work/work.go: lines 28\x{2013}33
28         go func() {
29             for w := range w.work {
30                 w.Task()
31             }
32             p.wg.Done()
33         }()",
          ],
          [
            1,
            '[ap 07:32] Go in Action - William Kennedy.epub (kindle_split_015.html) - 7.32',
            "Now that we can create a pool of goroutines that can wait for and execute work, let\x{2019}s look at how work is submitted into the pool.
Listing <<7.32|5a:0>>. work/work.go: lines 39\x{2013}42
39 // Run submits work to the pool.
40 func (p *Pool) Run(w Worker) {
41     w.work <- w
42 }",
          ],
          [
            1,
            '[ap 07:32] Go in Action - William Kennedy.epub (kindle_split_015.html) - 7.32',
            'Listing <<7.32|5a:0>> shows the Run method. This method is used to submit work into the pool. It accepts an interface value of type Worker and sends that value through the work channel. Since the work channel is an unbuffered channel, the caller must wait for a goroutine from the pool to receive it. This is what we want, because the caller needs the guarantee that the work being submitted is being worked on once the call to Run returns.',
          ],
          [
            1,
            '[ap 07:33] Go in Action - William Kennedy.epub (kindle_split_015.html) - 7.33',
            "At some point, the work pool needs to be shut down. This is where the Shutdown method comes in.
Listing <<7.33|5a:0>>. work/work.go: lines 44\x{2013}48
44 // Shutdown waits for all the goroutines to shutdown.
45 func (p *Pool) Shutdown() {
46     close(p.work)
47     p.wg.Wait()
48 }",
          ],
          [
            1,
            '[ap 07:33] Go in Action - William Kennedy.epub (kindle_split_015.html) - 7.33',
            'The Shutdown method in listing <<7.33|5a:0>> does two things. First, it closes the work channel, which causes all of the goroutines in the pool to shut down and call the Done method on the WaitGroup. Then the Shutdown method calls the Wait method on the WaitGroup, which causes the Shutdown method to wait for all the goroutines to report they have terminated.',
          ],
          [
            1,
            '[ap 07:34] Go in Action - William Kennedy.epub (kindle_split_015.html) - 7.34',
            "Now that you\x{2019}ve seen the code for the work package and learned how it works, let\x{2019}s review the test program in the main.go source code file.
Listing <<7.34|5a:0>>. work/main/main.go
01 // This sample program demonstrates how to use the work package
02 // to use a pool of goroutines to get work done.
03 package main
04
05 import (
06     \"log\"
07     \"sync\"
08     \"time\"
09
10     \"github.com/goinaction/code/chapter7/patterns/work\"
11 )
12",
          ],
          [
            1,
            '[ap 07:34] Go in Action - William Kennedy.epub (kindle_split_015.html) - 7.34',
            'Listing <<7.34|5a:0>> shows the test program that uses the work package to perform the displaying of names. The code starts out on line 14 with the declaration of a package level variable named names, which is declared as a slice of strings. The slice is also initialized with five names. Then a type named namePrinter is declared.',
          ],
          [
            1,
            '[ap 07:34] Go in Action - William Kennedy.epub (kindle_split_015.html) - 7.34',
            "Listing <<7.34|5a:0>> shows the test program that uses the work package to perform the displaying of names. The code starts out on line 14 with the declaration of a package level variable named names, which is declared as a slice of strings. The slice is also initialized with five names. Then a type named namePrinter is declared.
Listing <<7.35|5a:0>>. work/main/main.go: lines 22\x{2013}31
22 // namePrinter provides special support for printing names.
23 type namePrinter struct {
24     name string
25 }
26
27 // Task implements the Worker interface.
28 func (m *namePrinter) Task() {
29     log.Println(m.name)
30     time.Sleep(time.Second)
31 }",
          ],
          [
            1,
            '[ap 07:35] Go in Action - William Kennedy.epub (kindle_split_015.html) - 7.35',
            'On line 23 in listing <<7.35|5a:0>>, the namePrinter type is declared and the implementation of the Worker interface follows. The purpose of the work is to display names to the screen. The type contains a single field, name, that will contain the name to display. The implementation of the Worker interface uses the log.Println function to display the name and then waits a second before returning. The second wait is just to slow the test program down so you can see the concurrency is action.',
          ],
          [
            1,
            '[ap 07:36] Go in Action - William Kennedy.epub (kindle_split_015.html) - 7.36',
            "With the implementation of the Worker interface, we can look at the code inside the main function.
Listing <<7.36|5a:0>>. work/main/main.go: lines 33\x{2013}64
33 // main is the entry point for all Go programs.
34 func main() {
35     // Create a work pool with 2 goroutines.
36     p := work.New(2)
37
38     var wg sync.WaitGroup
39     wg.Add(100 * len(names))
40
41     for i := 0; i < 100; i++ {
42         // Iterate over the slice of names.
43         for _, name := range names {
44             // Create a namePrinter and provide the
45             // specific name.
46             np := namePrinter{
47                 name: name,
48             }
49
50             go func() {
51                 // Submit the task to be worked on. When RunTask
52                 // returns we know it is being handled.
53                 p.Run(&np)",
          ],
          [
            1,
            '[ap 07:36] Go in Action - William Kennedy.epub (kindle_split_015.html) - 7.36',
            'On line 36 in listing <<7.36|5a:0>>, the New function from the work package is called to create the work pool. The number 2 is passed into the call, indicating the pool should only contain two goroutines. On lines 38 and 39 a WaitGroup is declared and initialized to each goroutine that will be created. In this case, a goroutine for each name in the names slice will be created 100 times. This is to create a lot of goroutines competing to submit work to the pool.',
          ],
          [
            1,
            '[23:00] Go in Action - William Kennedy.epub (kindle_split_016.html) - 23:00',
            'TRACE: 2009/11/10 <<23:00|2>>:00.000000 /tmpfs/gosandbox-/prog.go:14: message',
          ],
          [
            1,
            '[ap 01:23] Go in Action - William Kennedy.epub (kindle_split_016.html) - 01:23',
            'const (
  // Bits or\'ed together to control what\'s printed. There is no control
  // over the order they appear (the order listed here) or the format
  // they present (as described in the comments).  A colon appears after
  // these items:
  //    2009/01/23 <<01:23|2>>:23.123123 /a/b/c/d.go:23: message',
          ],
          [
            1,
            '[ap 01:23] Go in Action - William Kennedy.epub (kindle_split_016.html) - 01:23',
            '

  // the time: <<01:23|2>>:23

',
          ],
          [
            1,
            '[ap 01:23] Go in Action - William Kennedy.epub (kindle_split_016.html) - 01:23',
            '  // microsecond resolution: <<01:23|2>>:23.123123. assumes Ltime
  Lmicroseconds',
          ],
          [
            1,
            '[ap 08:10] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.10',
            "With the log package initialized, you can look at main() and see how to write messages.
Listing <<8.10|5a:0>>. listing03.go: lines 13\x{2013}22
13 func main() {
14     // Println writes to the standard logger.
15     log.Println(\"message\")
16
17     // Fatalln is Println() followed by a call to os.Exit(1).
18     log.Fatalln(\"fatal message\")
19
20     // Panicln is Println() followed by a call to panic().
21     log.Panicln(\"panic message\")
22 }",
          ],
          [
            1,
            '[ap 08:10] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.10',
            'Listing <<8.10|5a:0>> shows how to write log messages using three different functions: Println, Fatalln, and Panicln. These functions have a format version, as well, that end with the letter f instead of the letters ln. The Fatal family of functions is used to write a log message and then terminate the program using the os.Exit(1) function call. The Panic family of functions is used to write a log message and then issue a panic, which unless recovered, will cause the program to terminate and stack trace. The Print family of functions is the standard way to write log messages.',
          ],
          [
            1,
            '[ap 08:11] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.11',
            "Creating customized loggers require that you create your own Logger type values. Each logger you create can be configured for a unique destination and set with its own prefix and flags. Let\x{2019}s look at an example program that creates different Logger type pointer variables to support different logging levels.
Listing <<8.11|5a:0>>. listing11.go
01 // This sample program demonstrates how to create customized loggers.
02 package main
03
04 import (
05     \"io\"
06     \"io/ioutil\"
07     \"log\"
08     \"os\"
09 )
10
11 var (
12     Trace   *log.Logger // Just about anything
13     Info    *log.Logger // Important information
14     Warning *log.Logger // Be concerned
15     Error   *log.Logger // Critical problem
16 )
17
18 func init() {
19     file, err := os.OpenFile(\"errors.txt\",
20         os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)
21     if err != nil {
22         log.Fatalln(\"Failed to open error log file:\", err)
23     }
24
25     Trace = log.New(ioutil.Discard,
26         \"TRACE: \",
27         log.Ldate|log.Ltime|log.Lshortfile)
28
29     Info = log.New(os.Stdout,
30         \"INFO: \",
31         log.Ldate|log.Ltime|log.Lshortfile)
32",
          ],
          [
            1,
            '[ap 08:11] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.11',
            "Listing <<8.11|5a:0>> shows a complete program that creates four different Logger type pointer variables. They\x{2019}re named Trace, Info, Warning, and Error. Each variable is configured differently because of the importance each represents. Let\x{2019}s break down the code so you can learn how all this works.",
          ],
          [
            1,
            '[ap 08:12] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.12',
            "On lines 11 through 16 we declare the four Logger type pointer variables for our different logging levels.
Listing <<8.12|5a:0>>. listing11.go: lines 11\x{2013}16
11 var (
12     Trace   *log.Logger // Just about anything
13     Info    *log.Logger // Important information
14     Warning *log.Logger // Be concerned
15     Error   *log.Logger // Critical problem
16 )",
          ],
          [
            1,
            '[ap 08:12] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.12',
            "In listing <<8.12|5a:0>> you see the declaration of the Logger type pointer variables. We\x{2019}ve given each logger a short but descriptive variable name. Next, let\x{2019}s look at the code in init() that creates and assigns the address of each Logger type value to each variable.",
          ],
          [
            1,
            '[ap 08:12] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.12',
            "In listing <<8.12|5a:0>> you see the declaration of the Logger type pointer variables. We\x{2019}ve given each logger a short but descriptive variable name. Next, let\x{2019}s look at the code in init() that creates and assigns the address of each Logger type value to each variable.
Listing <<8.13|5a:0>>. listing11.go: lines 25\x{2013}39
25     Trace = log.New(ioutil.Discard,
26         \"TRACE: \",
27         log.Ldate|log.Ltime|log.Lshortfile)
28
29     Info = log.New(os.Stdout,
30         \"INFO: \",
31         log.Ldate|log.Ltime|log.Lshortfile)
32
33     Warning = log.New(os.Stdout,
34         \"WARNING: \",
35         log.Ldate|log.Ltime|log.Lshortfile)
36
37     Error = log.New(io.MultiWriter(file, os.Stderr),
38         \"ERROR: \",
39         log.Ldate|log.Ltime|log.Lshortfile)",
          ],
          [
            1,
            '[ap 08:14] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.14',
            'To create each logger, we use the New function from the log package, which creates a properly initialized Logger type value. The New function returns the address to the newly created value. Before the New function can create a value, we need to pass it some parameters.
Listing <<8.14|5a:0>>. golang.org/src/log/log.go
// New creates a new Logger. The out variable sets the
// destination to which log data will be written.
// The prefix appears at the beginning of each generated log line.
// The flag argument defines the logging properties.
func New(out io.Writer, prefix string, flag int) *Logger {
    return &Logger{out: out, prefix: prefix, flag: flag}
}',
          ],
          [
            1,
            '[ap 08:14] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.14',
            'Listing <<8.14|5a:0>> shows the declaration of the New function from the source code for the log package. The first parameter is the destination we want the logger to write to. This is provided as a value that implements the io.Writer interface. The second parameter is the prefix that you saw before, and log flags comprise the final parameter.',
          ],
          [
            1,
            '[ap 08:15] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.15',
            "In our program, the Trace logger uses the Discard variable from the ioutil package as the destination to write to.
Listing <<8.15|5a:0>>. listing11.go: lines 25\x{2013}27
25     Trace = log.New(ioutil.Discard,
26         \"TRACE: \",
27         log.Ldate|log.Ltime|log.Lshortfile)",
          ],
          [
            1,
            '[ap 08:16] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.16',
            'The Discard variable has some very interesting properties.
Listing <<8.16|5a:0>>. golang.org/src/io/ioutil/ioutil.go
// devNull is a named type using int as its base type.
type devNull int',
          ],
          [
            1,
            '[ap 08:16] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.16',
            'Listing <<8.16|5a:0>> shows the declaration of the Discard variable and the implementation surrounding it. The Discard variable is declared to be of interface type io.Writer and is given a value of 0 of type devNull. Anything written to this variable is discarded based on the implementation of the Write method for the devNull type. Using the Discard variable is a technique you can use to disable a logging level when the output for that level is not required.',
          ],
          [
            1,
            '[ap 08:17] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.17',
            "The Info and Warning loggers both use the stdout destination.
Listing <<8.17|5a:0>>. listing11.go: lines 29\x{2013}35
29     Info = log.New(os.Stdout,
30         \"INFO: \",
31         log.Ldate|log.Ltime|log.Lshortfile)
32
33     Warning = log.New(os.Stdout,
34         \"WARNING: \",
35         log.Ldate|log.Ltime|log.Lshortfile)",
          ],
          [
            1,
            '[ap 08:18] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.18',
            'The declaration of the Stdout variable is also interesting.
Listing <<8.18|5a:0>>. golang.org/src/os/file.go
// Stdin, Stdout, and Stderr are open Files pointing to the standard
// input, standard output, and standard error file descriptors.
var (
    Stdin  = NewFile(uintptr(syscall.Stdin), "/dev/stdin")
    Stdout = NewFile(uintptr(syscall.Stdout), "/dev/stdout")
    Stderr = NewFile(uintptr(syscall.Stderr), "/dev/stderr")
)',
          ],
          [
            1,
            '[ap 08:18] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.18',
            'In listing <<8.18|5a:0>> you can see the declaration for the three variables that represent the standard destinations that exist on all operating systems: Stdin, Stdout, and Stderr. All these variables are declared to be pointers of type File, which implements the io.Writer interface. This leads us to the final logger, Error.',
          ],
          [
            1,
            '[ap 08:18] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.18',
            "In listing <<8.18|5a:0>> you can see the declaration for the three variables that represent the standard destinations that exist on all operating systems: Stdin, Stdout, and Stderr. All these variables are declared to be pointers of type File, which implements the io.Writer interface. This leads us to the final logger, Error.
Listing <<8.19|5a:0>>. listing11.go: lines 37\x{2013}39
37     Error = log.New(io.MultiWriter(file, os.Stderr),
38         \"ERROR: \",
39         log.Ldate|log.Ltime|log.Lshortfile)",
          ],
          [
            1,
            '[ap 08:19] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.19',
            'In listing <<8.19|5a:0>> you can see that the first parameter to the New function comes from a special function called MultiWriter from the io package.',
          ],
          [
            1,
            '[ap 08:20] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.20',
            'Listing <<8.20|5a:0>>. Declaration of the MultiWriter function in the io package',
          ],
          [
            1,
            '[ap 08:20] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.20',
            'Listing <<8.20|5a:0>> isolates the call to the MultiWriter function, which returns an interface type value of io.Writer that contains both the file that we opened and the stderr destination. The MultiWriter function is a variadic function that accepts any number of values that implement the io.Writer interface. The function returns a single io.Writer value that bundles all of the io.Writer values that are passed in. This allows functions like log.New to accept multiple writers within a single writer. Now when we write a log using the Error logger, the output will be written to both the file and stderr.',
          ],
          [
            1,
            '[ap 08:21] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.21',
            "Now that you know how to create custom loggers, let\x{2019}s look at how you can use them to write messages.
Listing <<8.21|5a:0>>. listing11.go: lines 42\x{2013}47
42 func main() {
43     Trace.Println(\"I have something standard to say\")
44     Info.Println(\"Special Information\")
45     Warning.Println(\"There is something you need to know about\")
46     Error.Println(\"Something has failed\")
47 }",
          ],
          [
            1,
            '[ap 08:21] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.21',
            'Listing <<8.21|5a:0>> shows the main() function from listing <<8.11|5a:0>>. On lines 43 through 46 we write a single message for each logger that we created. Each logger variable contains a set of methods that are identical to the set of functions that are implemented by the log package.',
          ],
          [
            1,
            '[ap 08:21] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.21',
            'Listing <<8.21|5a:0>> shows the main() function from listing <<8.11|5a:0>>. On lines 43 through 46 we write a single message for each logger that we created. Each logger variable contains a set of methods that are identical to the set of functions that are implemented by the log package.
Listing <<8.22|5a:0>>. Declarations of the different logging methods
func (l *Logger) Fatal(v ...interface{})
func (l *Logger) Fatalf(format string, v ...interface{})
func (l *Logger) Fatalln(v ...interface{})
func (l *Logger) Flags() int
func (l *Logger) Output(calldepth int, s string) error
func (l *Logger) Panic(v ...interface{})
func (l *Logger) Panicf(format string, v ...interface{})
func (l *Logger) Panicln(v ...interface{})
func (l *Logger) Prefix() string
func (l *Logger) Print(v ...interface{})
func (l *Logger) Printf(format string, v ...interface{})
func (l *Logger) Println(v ...interface{})
func (l *Logger) SetFlags(flag int)
func (l *Logger) SetPrefix(prefix string)',
          ],
          [
            1,
            '[ap 08:22] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.22',
            'Listing <<8.22|5a:0>> shows all the methods that have been implemented for the Logger type.',
          ],
          [
            1,
            '[ap 08:23] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.23',
            "The first aspect of working with JSON we\x{2019}ll explore is using the NewDecoder function and Decode method from the json package. If you\x{2019}re consuming JSON from a web response or a file, this is the function and method you want to use. Let\x{2019}s look at an example that works with the http package to perform a Get request against the Google search API that returns results in JSON. The next listing shows what the response looks like.
Listing <<8.23|5a:0>>. Google search API sample JSON response
{
    \"responseData\": {
        \"results\": [
            {
                \"GsearchResultClass\": \"GwebSearch\",
                \"unescapedUrl\": \"https://www.reddit.com/r/golang\",
                \"url\": \"https://www.reddit.com/r/golang\",
                \"visibleUrl\": \"www.reddit.com\",
                \"cacheUrl\": \"http://www.google.com/search?q=cache:W...\",
                \"title\": \"r/\\u003cb\\u003eGolang\\u003c/b\\u003e - Reddit\",
                \"titleNoFormatting\": \"r/Golang - Reddit\",
                \"content\": \"First Open Source \\u003cb\\u003eGolang\\u...\"
            },
            {
                \"GsearchResultClass\": \"GwebSearch\",
                \"unescapedUrl\": \"http://tour.golang.org/\",
                \"url\": \"http://tour.golang.org/\",
                \"visibleUrl\": \"tour.golang.org\",
                \"cacheUrl\": \"http://www.google.com/search?q=cache:O...\",
                \"title\": \"A Tour of Go\",
                \"titleNoFormatting\": \"A Tour of Go\",
                \"content\": \"Welcome to a tour of the Go programming ...\"",
          ],
          [
            1,
            '[ap 08:24] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.24',
            "Here\x{2019}s the example that retrieves and decodes the response into a struct type.
Listing <<8.24|5a:0>>. listing24.go
01 // This sample program demonstrates how to decode a JSON response
02 // using the json package and NewDecoder function.
03 package main
04
05 import (
06     \"encoding/json\"
07     \"fmt\"
08     \"log\"
09     \"net/http\"
10 )
11
12 type (
13     // gResult maps to the result document received from the search.
14     gResult struct {
15         GsearchResultClass string `json:\"GsearchResultClass\"`
16         UnescapedURL       string `json:\"unescapedUrl\"`
17         URL                string `json:\"url\"`
18         VisibleURL         string `json:\"visibleUrl\"`
19         CacheURL           string `json:\"cacheUrl\"`
20         Title              string `json:\"title\"`
21         TitleNoFormatting  string `json:\"titleNoFormatting\"`
22         Content            string `json:\"content\"`
23     }
24
25     // gResponse contains the top level document.
26     gResponse struct {
27         ResponseData struct {
28             Results []gResult `json:\"results\"`
29         } `json:\"responseData\"`
30     }
31 )
32
33 func main() {
34     uri := \"http://ajax.googleapis.com/ajax/services/search/web?
                                                  v=1.0&rsz=8&q=golang\"
35
36     // Issue the search against Google.
37     resp, err := http.Get(uri)
38     if err != nil {
39        log.Println(\"ERROR:\", err)
40        return
41     }
42     defer resp.Body.Close()
43
44     // Decode the JSON response into our struct type.
45     var gr gResponse
46     err = json.NewDecoder(resp.Body).Decode(&gr)",
          ],
          [
            1,
            '[ap 08:24] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.24',
            "The code on line 37 in listing <<8.24|5a:0>> shows a program that makes an HTTP Get call that retrieves a JSON document from Google. Then, using the NewDecoder function and Decode method on line 46, the JSON document from the response is decoded into a variable of the struct type that\x{2019}s declared on line 26. On line 52 the value of the variable is written to stdout.",
          ],
          [
            1,
            '[ap 08:25] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.25',
            "Thanks to the standard library, all of the technical aspects of performing HTTP Get calls and decoding JSON into struct types are taken care of. Let\x{2019}s look at the declaration of both the NewDecoder function and Decode method.
Listing <<8.25|5a:0>>. golang.org/src/encoding/json/stream.go
// NewDecoder returns a new decoder that reads from r.
//
// The decoder introduces its own buffering and may
// read data from r beyond the JSON values requested.
func NewDecoder(r io.Reader) *Decoder",
          ],
          [
            1,
            '[ap 08:25] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.25',
            "In listing <<8.25|5a:0>> you can see that the NewDecoder function accepts any value whose type implements the io.Reader interface. In the next section you\x{2019}ll learn more about the io.Reader and io.Writer interfaces. For now, understand that many different types from within the standard library implement these interfaces, including types from the http package. When types implement these particular interfaces, you get a lot of support and functionality for free.",
          ],
          [
            1,
            '[ap 08:25] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.25',
            'The NewDecoder function returns a pointer value of type Decoder. Since Go supports compound statement calls, the return value from the NewDecoder function can be used to call the Decode method immediately without the need to declare a variable first. In listing <<8.25|5a:0>> you can see that the Decode method accepts a value of type interface{} and returns an error.',
          ],
          [
            1,
            '[ap 08:26] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.26',
            "As described in chapter 5, the empty interface is an interface implemented by every type. This means the Decode method can accept values of any type. Through the use of reflection, the Decode method will inspect the type information about the value you pass in. Then as it reads the JSON response, it will decode the response into a value of that type. This means you don\x{2019}t need to create values yourself; Decode can do this for you.
Listing <<8.26|5a:0>>. Use of the Decode method
var gr *gResponse
err = json.NewDecoder(resp.Body).Decode(&gr)",
          ],
          [
            1,
            '[ap 08:26] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.26',
            'In listing <<8.26|5a:0>> we pass the address of a pointer variable of type gResponse, with the value of nil, to the Decode method. After the method call, the value of the pointer variable will be assigned to a value of type gResponse and initialized based on the JSON document being decoded.',
          ],
          [
            1,
            '[ap 08:27] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.27',
            "Sometimes the JSON documents you\x{2019}re working with come to you as a string value. In these cases, you need to convert the string into a byte slice ([]byte) and use the Unmarshal function from the json package.
Listing <<8.27|5a:0>>. listing27.go
01 // This sample program demonstrates how to decode a JSON string.
02 package main
03
04 import (
05     \"encoding/json\"
06     \"fmt\"
07     \"log\"
08 )
09
10 // Contact represents our JSON string.
11 type Contact struct {
12     Name    string `json:\"name\"`
13     Title   string `json:\"title\"`
14     Contact struct {
15         Home string `json:\"home\"`
16         Cell string `json:\"cell\"`
17     } `json:\"contact\"`
18 }
19
20 // JSON contains a sample string to unmarshal.
21 var JSON = `{
22     \"name\": \"Gopher\",
23     \"title\": \"programmer\",
24     \"contact\": {
25         \"home\": \"415.333.3333\",
26         \"cell\": \"415.555.5555\"",
          ],
          [
            1,
            '[ap 08:27] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.27',
            "In listing <<8.27|5a:0>> we have an example that takes a JSON document inside of a string variable and uses the Unmarshal function to decode the JSON into a struct type value. If you run the program, you\x{2019}ll get the following output.",
          ],
          [
            1,
            '[ap 08:27] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.27',
            "In listing <<8.27|5a:0>> we have an example that takes a JSON document inside of a string variable and uses the Unmarshal function to decode the JSON into a struct type value. If you run the program, you\x{2019}ll get the following output.
Listing <<8.28|5a:0>>. Output for listing27.go
{Gopher programmer {415.333.3333 415.555.5555}}",
          ],
          [
            1,
            '[ap 08:29] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.29',
            "Sometimes it\x{2019}s not possible to declare a struct type and you need more flexibility to work with the JSON document. In these cases you can decode or unmarshal the JSON document into a map variable.
Listing <<8.29|5a:0>>. listing29.go
01 // This sample program demonstrates how to decode a JSON string.
02 package main
03
04 import (
05     \"encoding/json\"
06     \"fmt\"
07     \"log\"
08 )
09
10 // JSON contains a sample string to unmarshal.
11 var JSON = `{
12     \"name\": \"Gopher\",
13     \"title\": \"programmer\",
14     \"contact\": {
15         \"home\": \"415.333.3333\",
16         \"cell\": \"415.555.5555\"
17     }
18 }`
19
20 func main() {
21     // Unmarshal the JSON string into our map variable.
22     var c map[string]interface{}
23     err := json.Unmarshal([]byte(JSON), &c)
24     if err != nil {",
          ],
          [
            1,
            '[ap 08:29] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.29',
            "In listing <<8.29|5a:0>> we\x{2019}ve changed the program from listing <<8.27|5a:0>> to use a map variable instead of our struct type variable. The map variable is declared as a map with a key of type string and a value of type interface{}. This means the map can store any type of value for any given key. Though this gives you great flexibility when working with JSON documents, it has one minor drawback. Look at the syntax required to access the home field from the contact subdocument.",
          ],
          [
            1,
            '[ap 08:29] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.29',
            "In listing <<8.29|5a:0>> we\x{2019}ve changed the program from listing <<8.27|5a:0>> to use a map variable instead of our struct type variable. The map variable is declared as a map with a key of type string and a value of type interface{}. This means the map can store any type of value for any given key. Though this gives you great flexibility when working with JSON documents, it has one minor drawback. Look at the syntax required to access the home field from the contact subdocument.
Listing <<8.30|5a:0>>. Syntax for accessing a field from an unmarshaled map
fmt.Println(\"\\tHome:\", c[\"contact\"].(map[string]interface{})[\"home\"])",
          ],
          [
            1,
            '[ap 08:30] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.30',
            "Because the value for each key is of type interface{}, you need to convert the value to the proper native type in order to work with the value. Listing <<8.30|5a:0>> shows how you need to convert the value of the contact key to another map with a key of type string and a value of type interface{}. This can make using maps that contain JSON documents sometimes unfriendly to work with. But if you never need to dig into the JSON documents you\x{2019}re working with or you plan to do very little manipulation, using a map can be fast, and then there\x{2019}s no need to declare new types.",
          ],
          [
            1,
            '[ap 08:31] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.31',
            "The second aspect of working with JSON we\x{2019}ll explore is using the MarshalIndent function from the json package. This comes in handy when you want to publish a pretty-printed JSON document from a Go map or struct type value. Marshaling is the process of transforming data into a JSON string. Here\x{2019}s an example that converts a map type into a JSON string.
Listing <<8.31|5a:0>>. listing31.go
01 // This sample program demonstrates how to marshal a JSON string.
02 package main
03
04 import (
05     \"encoding/json\"
06     \"fmt\"
07     \"log\"
08 )
09
10 func main() {",
          ],
          [
            1,
            '[ap 08:31] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.31',
            "Listing <<8.31|5a:0>> shows how to use the MarshalIndent function from the json package to convert a map to a JSON string. The MarshalIndent function returns a byte slice that represents the JSON string and an error value. Here\x{2019}s a look at the declaration of the MarshalIndent function from the json package.",
          ],
          [
            1,
            '[ap 08:31] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.31',
            "Listing <<8.31|5a:0>> shows how to use the MarshalIndent function from the json package to convert a map to a JSON string. The MarshalIndent function returns a byte slice that represents the JSON string and an error value. Here\x{2019}s a look at the declaration of the MarshalIndent function from the json package.
Listing <<8.32|5a:0>>. golang.org/src/encoding/json/encode.go
// MarshalIndent is like Marshal but applies Indent to format the output
func MarshalIndent(v interface{}, prefix, indent string)
                                                       ([]byte, error) {",
          ],
          [
            1,
            '[ap 08:33] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.33',
            "The io package is built around working with values from types that implement the io.Writer and io.Reader interfaces. The functions and methods that make up the io package have no understanding about the type of data nor how that data is physically read and written. This is thanks to the abstraction that the io.Writer and io.Reader interfaces provide. Let\x{2019}s start by looking at the declaration of the io.Writer interface.
Listing <<8.33|5a:0>>. Declaration of the io.Writer interface
type Writer interface {
        Write(p []byte) (n int, err error)
}",
          ],
          [
            1,
            '[ap 08:33] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.33',
            'Listing <<8.33|5a:0>> shows the declaration of the io.Writer interface. The interface declares a single method called Write that accepts a byte slice and returns two values. The first value is the number of bytes written, and the second value is an error. The rules for implementing this method are as follows.',
          ],
          [
            1,
            '[ap 08:33] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.33',
            'Listing <<8.33|5a:0>> shows the declaration of the io.Writer interface. The interface declares a single method called Write that accepts a byte slice and returns two values. The first value is the number of bytes written, and the second value is an error. The rules for implementing this method are as follows.
Listing <<8.34|5a:0>>. Documentation for the io.Writer interface
Write writes len(p) bytes from p to the underlying data stream. It
returns the number of bytes written from p (0 <= n <= len(p)) and any
error encountered that caused the write to stop early. Write must
return a non-nil error if it returns n < len(p). Write must not modify
the slice data, even temporarily.',
          ],
          [
            1,
            '[ap 08:34] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.34',
            "The rules in listing <<8.34|5a:1>> come from the standard library. They mean that the implementation of the Write method should attempt to write the entire length of the byte slice that\x{2019}s passed in. But if that isn\x{2019}t possible, then the method must return an error. The number of bytes reported as written can be less than the length of the byte slice, but never more. Finally, the byte slice must never be modified in any way.",
          ],
          [
            1,
            '[ap 08:35] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.35',
            "Let\x{2019}s look at the declaration of the Reader interface.
Listing <<8.35|5a:0>>. Declaration of the io.Reader interface
type Reader interface {
        Read(p []byte) (n int, err error)
}",
          ],
          [
            1,
            '[ap 08:35] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.35',
            'The io.Reader interface in listing <<8.35|5a:0>> declares a single method, Read, that accepts a byte slice and returns two values. The first value is the number of bytes read and the second value is an error. The rules for implementing this method are as follows.',
          ],
          [
            1,
            '[ap 08:35] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.35',
            'The io.Reader interface in listing <<8.35|5a:0>> declares a single method, Read, that accepts a byte slice and returns two values. The first value is the number of bytes read and the second value is an error. The rules for implementing this method are as follows.
Listing <<8.36|5a:0>>. Documentation for the io.Reader interface
(1) Read reads up to len(p) bytes into p. It returns the number of bytes
read (0 <= n <= len(p)) and any error encountered. Even if Read returns
n < len(p), it may use all of p as scratch space during the call. If
some data is available but not len(p) bytes, Read conventionally
returns what is available instead of waiting for more.',
          ],
          [
            1,
            '[ap 08:37] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.37',
            'This example shows how different packages from the standard library work together by providing support for values from types that implement the io.Writer interface. The example uses the bytes, fmt, and os packages to buffer, concatenate, and write a string to stdout.
Listing <<8.37|5a:0>>. listing37.go
01 // Sample program to show how different functions from the
02 // standard library use the io.Writer interface.
03 package main
04
05 import (
06     "bytes"
07     "fmt"
08     "os"
09 )
10
11 // main is the entry point for the application.
12 func main() {
13     // Create a Buffer value and write a string to the buffer.
14     // Using the Write method that implements io.Writer.
15     var b bytes.Buffer
16     b.Write([]byte("Hello "))
17
18     // Use Fprintf to concatenate a string to the Buffer.
19     // Passing the address of a bytes.Buffer value for io.Writer.
20     fmt.Fprintf(&b, "World!")
21
22     // Write the content of the Buffer to the stdout device.
23     // Passing the address of a os.File value for io.Writer.
24     b.WriteTo(os.Stdout)
25 }',
          ],
          [
            1,
            '[ap 08:37] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.37',
            "When you run the program in listing <<8.37|5a:0>>, you\x{2019}ll get the following output.",
          ],
          [
            1,
            '[ap 08:37] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.37',
            "When you run the program in listing <<8.37|5a:0>>, you\x{2019}ll get the following output.
Listing <<8.38|5a:0>>. Output for listing37.go
Hello World!",
          ],
          [
            1,
            '[ap 08:39] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.39',
            "Line 20 uses the Fprintf function from the fmt package to append the string \"World!\" to the buffer. Let\x{2019}s look at the declaration of the Fprintf function.
Listing <<8.39|5a:0>>. golang.org/src/fmt/print.go
// Fprintf formats according to a format specifier and writes to w. It
// returns the number of bytes written and any write error encountered.
func Fprintf(w io.Writer, format string, a ...interface{})
                                                     (n int, err error)",
          ],
          [
            1,
            '[ap 08:40] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.40',
            "What\x{2019}s important to note is the first parameter of the Fprintf function. It accepts values from types that implement the io.Writer interface. This means that the Buffer type from the bytes package must implement this interface since we\x{2019}re able to pass the address of a variable of that type through. In the source code for the bytes package, we should then find the Write method declared for the Buffer type.
Listing <<8.40|5a:0>>. golang.org/src/bytes/buffer.go
// Write appends the contents of p to the buffer, growing the buffer
// as needed. The return value n is the length of p; err is always
// nil. If the buffer becomes too large, Write will panic with ...
func (b *Buffer) Write(p []byte) (n int, err error) {
    b.lastRead = opInvalid
    m := b.grow(len(p))
    return copy(b.buf[m:], p), nil
}",
          ],
          [
            1,
            '[ap 08:40] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.40',
            'Listing <<8.40|5a:0>> shows the current implementation of the Write method for the Buffer type that implements the io.Writer interface. Because of the implementation of this method, we can pass pointers of type Buffer as the first parameter to Fprintf. We use the Fprintf function in our example to append the string "World!" to the internal buffer of the Buffer type variable via the implementation of the Write method.',
          ],
          [
            1,
            '[ap 08:37] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.37',
            "Let\x{2019}s review the last line of listing <<8.37|5a:0>>, which writes the entire buffer to stdout.",
          ],
          [
            1,
            '[ap 08:37] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.37',
            "Let\x{2019}s review the last line of listing <<8.37|5a:0>>, which writes the entire buffer to stdout.
Listing <<8.41|5a:0>>. listing37.go: lines 22\x{2013}25
22 // Write the content of the Buffer to the stdout device.
23     // Passing the address of a os.File value for io.Writer.
24     b.WriteTo(os.Stdout)
25 }",
          ],
          [
            1,
            '[ap 08:37] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.37',
            'On line 24 of listing <<8.37|5a:0>>, the contents of the Buffer type variable are written to stdout using the WriteTo method. This method accepts a value that implements the io.Writer interface. In our program we pass the value of the Stdout variable from the os package.',
          ],
          [
            1,
            '[ap 08:37] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.37',
            'On line 24 of listing <<8.37|5a:0>>, the contents of the Buffer type variable are written to stdout using the WriteTo method. This method accepts a value that implements the io.Writer interface. In our program we pass the value of the Stdout variable from the os package.
Listing <<8.42|5a:0>>. golang.org/src/os/file.go
var (
    Stdin  = NewFile(uintptr(syscall.Stdin), "/dev/stdin")
    Stdout = NewFile(uintptr(syscall.Stdout), "/dev/stdout")
    Stderr = NewFile(uintptr(syscall.Stderr), "/dev/stderr")
)',
          ],
          [
            1,
            '[ap 08:43] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.43',
            'The declaration of these variables comes from the type returned by the NewFile function.
Listing <<8.43|5a:0>>. golang.org/src/os/file_unix.go
// NewFile returns a new File with the given file descriptor and name.
func NewFile(fd uintptr, name string) *File {
    fdi := int(fd)
    if fdi < 0 {
        return nil
    }
    f := &File{&file{fd: fdi, name: name}}
    runtime.SetFinalizer(f.file, (*file).close)
    return f
}',
          ],
          [
            1,
            '[ap 08:43] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.43',
            'As you can see in listing <<8.43|5a:0>>, the NewFile function returns a pointer of type File. This is the type of the Stdout variable. Since we can pass pointers of this type as a parameter to the WriteTo method, it must implement the io.Writer interface. In the source code for the os package, we should find the Write method.',
          ],
          [
            1,
            '[ap 08:43] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.43',
            'As you can see in listing <<8.43|5a:0>>, the NewFile function returns a pointer of type File. This is the type of the Stdout variable. Since we can pass pointers of this type as a parameter to the WriteTo method, it must implement the io.Writer interface. In the source code for the os package, we should find the Write method.
Listing <<8.44|5a:0>>. golang.org/src/os/file.go
// Write writes len(b) bytes to the File.
// It returns the number of bytes written and an error, if any.
// Write returns a non-nil error when n != len(b).
func (f *File) Write(b []byte) (n int, err error) {
    if f == nil {
        return 0, ErrInvalid
    }
    n, e := f.write(b)
    if n < 0 {
        n = 0
    }
    if n != len(b) {
        err = io.ErrShortWrite
    }',
          ],
          [
            1,
            '[ap 08:44] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.44',
            'Sure enough, listing <<8.44|5a:0>> shows the implementation of the io.Writer interface for pointers of type File. Look again at line 24 from listing <<8.37|5a:0>>.',
          ],
          [
            1,
            '[ap 08:44] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.44',
            "Sure enough, listing <<8.44|5a:0>> shows the implementation of the io.Writer interface for pointers of type File. Look again at line 24 from listing <<8.37|5a:0>>.
Listing <<8.45|5a:0>>. listing37.go: lines 22\x{2013}25
22     // Write the content of the Buffer to the stdout device.
23     // Using the io.Writer implementation for os.File.
24     b.WriteTo(os.Stdout)
25 }",
          ],
          [
            1,
            '[ap 08:46] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.46',
            "Let\x{2019}s take a look at an example that implements a basic version of curl.
Listing <<8.46|5a:0>>. listing46.go
01 // Sample program to show how to write a simple version of curl using
02 // the io.Reader and io.Writer interface support.
03 package main
04
05 import (
06     \"io\"
07     \"log\"
08     \"net/http\"
09     \"os\"
10 )
11
12 // main is the entry point for the application.
13 func main() {
14     // r here is a response, and r.Body is an io.Reader.
15     r, err := http.Get(os.Args[1])",
          ],
          [
            1,
            '[ap 08:46] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.46',
            "Listing <<8.46|5a:0>> shows a very bare-bones implementation of curl that can be used to download, display, and save the content of any HTTP Get request. The example will write the response to a file and to stdout at the same time. To keep the example small, the program doesn\x{2019}t check for valid command-line arguments nor provide switches for advanced options.",
          ],
          [
            1,
            '[ap 09:10] Go in Action - William Kennedy.epub (kindle_split_017.html) - 9.10',
            "Let\x{2019}s look at the changes we made to make the table test work.
Listing <<9.10|5a:0>>. listing08_test.go: lines 29\x{2013}34
29     t.Log(\"Given the need to test downloading different content.\")
30     {
31         for _, u := range urls {
32             t.Logf(\"\\tWhen checking \\\"%s\\\" for status code \\\"%d\\\"\",
33                 u.url, u.statusCode)
34             {",
          ],
          [
            1,
            '[ap 09:10] Go in Action - William Kennedy.epub (kindle_split_017.html) - 9.10',
            'The for range loop on line 31 in listing <<9.10|5a:0>> allows the test to iterate over the table and run the test code for each different URL. The original code from the basic unit test is the same except for the use of the table values.',
          ],
          [
            1,
            '[ap 09:10] Go in Action - William Kennedy.epub (kindle_split_017.html) - 9.10',
            "The for range loop on line 31 in listing <<9.10|5a:0>> allows the test to iterate over the table and run the test code for each different URL. The original code from the basic unit test is the same except for the use of the table values.
Listing <<9.11|5a:0>>. listing08_test.go: lines 35\x{2013}55
35                 resp, err := http.Get(u.url)
36                 if err != nil {
37                     t.Fatal(\"\\t\\tShould be able to Get the url.\",
38                         ballotX, err)
39                 }
40                 t.Log(\"\\t\\tShould be able to Get the url\",
41                     checkMark)
42
43                 defer resp.Body.Close()
44
45                 if resp.StatusCode == u.statusCode {
46                     t.Logf(\"\\t\\tShould have a \\\"%d\\\" status. %v\",
47                         u.statusCode, checkMark)
48                 } else {
49                     t.Errorf(\"\\t\\tShould have a \\\"%d\\\" status %v %v\",
50                         u.statusCode, ballotX, resp.StatusCode)
51                 }
52             }
53         }
54     }
55 }",
          ],
          [
            1,
            '[ap 09:11] Go in Action - William Kennedy.epub (kindle_split_017.html) - 9.11',
            "Listing <<9.11|5a:0>> shows how, on line 35, the code uses the u.url field for the URL to call. On line 45 the u.statusCode field is used to compare the actual status code from the response. In the future, new URLs and status codes can be added to the table and the core of the test doesn\x{2019}t need to change.",
          ],
          [
            1,
            '[ap 09:12] Go in Action - William Kennedy.epub (kindle_split_017.html) - 9.12',
            "To fix this situation, the standard library has a package called httptest that will let you mock HTTP-based web calls. Mocking is a technique many developers use to simulate access to resources that won\x{2019}t be available when tests are run. The httptest package provides you with the ability to mock requests and responses from web resources on the internet. By mocking the http.Get response in our unit test, we can solve the problem we saw in figure 9.4. No longer will our test fail because we don\x{2019}t have an internet connection. Yet the test can validate that our http.Get call works and handles the expected response. Let\x{2019}s take the basic unit test and change it to mock a call to the goinggo.net RSS feed.
Listing <<9.12|5a:0>>. listing12_test.go: lines 01\x{2013}41
01 // Sample test to show how to mock an HTTP GET call internally.
02 // Differs slightly from the book to show more.
03 package listing12
04
05 import (
06     \"encoding/xml\"
07     \"fmt\"
08     \"net/http\"
09     \"net/http/httptest\"
10     \"testing\"
11 )
12
13 const checkMark = \"\\u2713\"
14 const ballotX = \"\\u2717\"
15
16 // feed is mocking the XML document we except to receive.
17 var feed = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>
18 <rss>
19 <channel>
20     <title>Going Go Programming</title>
21     <description>Golang : https://github.com/goinggo</description>
22     <link>http://www.goinggo.net/</link>
23     <item>
24         <pubDate>Sun, 15 Mar 2015 <<15:04|2>>:00 +0000</pubDate>
25         <title>Object Oriented Programming Mechanics</title>
26         <description>Go is an object oriented language.</description>
27         <link>http://www.goinggo.net/2015/03/object-oriented</link>
28     </item>
29 </channel>
30 </rss>`
31
32 // mockServer returns a pointer to a server to handle the get call.
33 func mockServer() *httptest.Server {",
          ],
          [
            1,
            '[15:04] Go in Action - William Kennedy.epub (kindle_split_017.html) - 15:04',
            '01 // Sample test to show how to mock an HTTP GET call internally.
02 // Differs slightly from the book to show more.
03 package listing12
04
05 import (
06     "encoding/xml"
07     "fmt"
08     "net/http"
09     "net/http/httptest"
10     "testing"
11 )
12
13 const checkMark = "\\u2713"
14 const ballotX = "\\u2717"
15
16 // feed is mocking the XML document we except to receive.
17 var feed = `<?xml version="1.0" encoding="UTF-8"?>
18 <rss>
19 <channel>
20     <title>Going Go Programming</title>
21     <description>Golang : https://github.com/goinggo</description>
22     <link>http://www.goinggo.net/</link>
23     <item>
24         <pubDate>Sun, 15 Mar 2015 <<15:04|2>>:00 +0000</pubDate>
25         <title>Object Oriented Programming Mechanics</title>
26         <description>Go is an object oriented language.</description>
27         <link>http://www.goinggo.net/2015/03/object-oriented</link>
28     </item>
29 </channel>
30 </rss>`
31
32 // mockServer returns a pointer to a server to handle the get call.
33 func mockServer() *httptest.Server {',
          ],
          [
            1,
            '[ap 09:12] Go in Action - William Kennedy.epub (kindle_split_017.html) - 9.12',
            "Listing <<9.12|5a:0>> shows how we can mock a call to the goinggo.net website to simulate the downloading of the RSS feed. On line 17 a package-level variable named feed is declared and initialized with a literal string that represents the RSS XML document we\x{2019}ll receive from our mock server call. It\x{2019}s a small snippet of the actual RSS feed document and is enough to conduct our test. On line 32 we have the declaration of a function named mockServer that leverages the support inside the httptest package to simulate a call to a real server on the internet.",
          ],
          [
            1,
            '[ap 09:12] Go in Action - William Kennedy.epub (kindle_split_017.html) - 9.12',
            "Listing <<9.12|5a:0>> shows how we can mock a call to the goinggo.net website to simulate the downloading of the RSS feed. On line 17 a package-level variable named feed is declared and initialized with a literal string that represents the RSS XML document we\x{2019}ll receive from our mock server call. It\x{2019}s a small snippet of the actual RSS feed document and is enough to conduct our test. On line 32 we have the declaration of a function named mockServer that leverages the support inside the httptest package to simulate a call to a real server on the internet.
Listing <<9.13|5a:0>>. listing12_test.go: lines 32\x{2013}40
32 func mockServer() *httptest.Server {
33     f := func(w http.ResponseWriter, r *http.Request) {
34         w.WriteHeader(200)
35         w.Header().Set(\"Content-Type\", \"application/xml\")
36         fmt.Fprintln(w, feed)
37     }
38
39     return httptest.NewServer(http.HandlerFunc(f))
40 }",
          ],
          [
            1,
            '[ap 09:13] Go in Action - William Kennedy.epub (kindle_split_017.html) - 9.13',
            'The mockServer function in listing <<9.13|5a:0>> is declared to return a pointer of type httptest.Server. The httptest.Server value is the key to making all of this work. The code starts out with declaring an anonymous function that has the same signature as the http.HandlerFunc function type.',
          ],
          [
            1,
            '[ap 09:13] Go in Action - William Kennedy.epub (kindle_split_017.html) - 9.13',
            'The mockServer function in listing <<9.13|5a:0>> is declared to return a pointer of type httptest.Server. The httptest.Server value is the key to making all of this work. The code starts out with declaring an anonymous function that has the same signature as the http.HandlerFunc function type.
Listing <<9.14|5a:0>>. golang.org/pkg/net/http/#HandlerFunc
type HandlerFunc func(ResponseWriter, *Request)',
          ],
          [
            1,
            '[ap 09:15] Go in Action - William Kennedy.epub (kindle_split_017.html) - 9.15',
            "Now, let\x{2019}s look at how the mock server is integrated into the basic unit test and how the http.Get call is able to use it.
Listing <<9.15|5a:0>>. listing12_test.go: lines 43\x{2013}74
43 // TestDownload validates the http Get function can download content
44 // and the content can be unmarshaled and clean.
45 func TestDownload(t *testing.T) {
46     statusCode := http.StatusOK
47
48     server := mockServer()
49     defer server.Close()
50
51     t.Log(\"Given the need to test downloading content.\")
52     {
53         t.Logf(\"\\tWhen checking \\\"%s\\\" for status code \\\"%d\\\"\",
54             server.URL, statusCode)
55         {
56             resp, err := http.Get(server.URL)
57             if err != nil {
58                 t.Fatal(\"\\t\\tShould be able to make the Get call.\",
59                     ballotX, err)
60             }
61             t.Log(\"\\t\\tShould be able to make the Get call.\",
62                 checkMark)
63
64             defer resp.Body.Close()
65
66             if resp.StatusCode != statusCode {
67                 t.Fatalf(\"\\t\\tShould receive a \\\"%d\\\" status. %v %v\",
68                     statusCode, ballotX, resp.StatusCode)
69             }
70             t.Logf(\"\\t\\tShould receive a \\\"%d\\\" status. %v\",
71                statusCode, checkMark)
72         }
73     }
74 }",
          ],
          [
            1,
            '[ap 09:15] Go in Action - William Kennedy.epub (kindle_split_017.html) - 9.15',
            "In listing <<9.15|5a:0>> you see the TestDownload function once more, but this time it\x{2019}s using the mock server. On lines 48 and 49 a call to the mockServer function is made, and a call to the Close method is deferred for when the test function returns. After that, the test code looks identical to the basic unit test except for one thing.",
          ],
          [
            1,
            '[ap 09:15] Go in Action - William Kennedy.epub (kindle_split_017.html) - 9.15',
            "In listing <<9.15|5a:0>> you see the TestDownload function once more, but this time it\x{2019}s using the mock server. On lines 48 and 49 a call to the mockServer function is made, and a call to the Close method is deferred for when the test function returns. After that, the test code looks identical to the basic unit test except for one thing.
Listing <<9.16|5a:0>>. listing12_test.go: line 56
56             resp, err := http.Get(server.URL)",
          ],
          [
            1,
            '[ap 09:17] Go in Action - William Kennedy.epub (kindle_split_017.html) - 9.17',
            "If you\x{2019}re building a web API, you\x{2019}ll want to test all of your endpoints without the need to start the web service. The httptest package provides a facility for doing just this. Let\x{2019}s take a look at a sample web service that implements a single endpoint, and then you can see how to write a unit test that mocks an actual call.
Listing <<9.17|5a:0>>. listing17.go
01 // This sample code implement a simple web service.
02 package main
03
04 import (
05     \"log\"
06     \"net/http\"
07
08     \"github.com/goinaction/code/chapter9/listing17/handlers\"
09 )
10
11 // main is the entry point for the application.
12 func main() {
13     handlers.Routes()
14
15     log.Println(\"listener : Started : Listening on :4000\")
16     http.ListenAndServe(\":4000\", nil)
17 }",
          ],
          [
            1,
            '[ap 09:17] Go in Action - William Kennedy.epub (kindle_split_017.html) - 9.17',
            'Listing <<9.17|5a:0>> shows the code file for the entry point of the web service. Inside the main function on line 13, the code calls the Routes function from the internal handlers package. This function sets up the routes for the different endpoints the web service is hosting. On lines 15 and 16 the main function displays the port the service is listening on and starts the web service, waiting for requests.',
          ],
          [
            1,
            '[ap 09:18] Go in Action - William Kennedy.epub (kindle_split_017.html) - 9.18',
            "Now, let\x{2019}s look at the code for the handlers package.
Listing <<9.18|5a:0>>. handlers/handlers.go
01 // Package handlers provides the endpoints for the web service.
02 package handlers
03
04 import (
05     \"encoding/json\"
06     \"net/http\"
07 )
08
09 // Routes sets the routes for the web service.
10 func Routes() {
11     http.HandleFunc(\"/sendjson\", SendJSON)
12 }
13
14 // SendJSON returns a simple JSON document.
15 func SendJSON(rw http.ResponseWriter, r *http.Request) {
16     u := struct {
17         Name  string
18         Email string
19     }{
20         Name:  \"Bill\",
21         Email: \"bill\@ardanstudios.com\",
22     }
23
24     rw.Header().Set(\"Content-Type\", \"application/json\")
25     rw.WriteHeader(200)
26     json.NewEncoder(rw).Encode(&u)
27 }",
          ],
          [
            1,
            '[ap 09:18] Go in Action - William Kennedy.epub (kindle_split_017.html) - 9.18',
            'The code for the handlers package in listing <<9.18|5a:0>> provides the implementation of the handler function and sets up the routes for the web service. On line 10 you see the Routes function, which uses the default http.ServeMux from inside the http package to configure the routing between the URLs and the corresponding handler code. On line 11 we bind the /sendjson endpoint to the SendJSON function.',
          ],
          [
            1,
            '[ap 09:14] Go in Action - William Kennedy.epub (kindle_split_017.html) - 9.14',
            'Starting on line 15, we have the implementation of the SendJSON function. The function has the same signature as the http.HandlerFunc function type that you saw in listing <<9.14|5a:0>>. On line 16 an anonymous struct type is declared, and a variable named u is created with some values. On lines 24 and 25 the content type and status code for the response is set. Finally, on line 26 the u value is encoded into a JSON document and sent back to the client.',
          ],
          [
            1,
            '[ap 09:19] Go in Action - William Kennedy.epub (kindle_split_017.html) - 9.19',
            'Now that we have a functioning web service with an endpoint, we can write a unit test to test the endpoint.
Listing <<9.19|5a:0>>. handlers/handlers_test.go
01 // Sample test to show how to test the execution of an
02 // internal endpoint.
03 package handlers_test
04
05 import (
06     "encoding/json"
07     "net/http"
08     "net/http/httptest"
09     "testing"
10
11     "github.com/goinaction/code/chapter9/listing17/handlers"
12 )
13
14 const checkMark = "\\u2713"
15 const ballotX = "\\u2717"
16
17 func init() {
18     handlers.Routes()
19 }
20
21 // TestSendJSON testing the sendjson internal endpoint.
22 func TestSendJSON(t *testing.T) {
23     t.Log("Given the need to test the SendJSON endpoint.")
24     {
25         req, err := http.NewRequest("GET", "/sendjson", nil)
26         if err != nil {
27             t.Fatal("\\tShould be able to create a request.",
28                 ballotX, err)
29         }
30         t.Log("\\tShould be able to create a request.",
31             checkMark)
32
33         rw := httptest.NewRecorder()
34         http.DefaultServeMux.ServeHTTP(rw, req)
35
36         if rw.Code != 200 {
37             t.Fatal("\\tShould receive \\"200\\"", ballotX, rw.Code)
38         }
39         t.Log("\\tShould receive \\"200\\"", checkMark)
40',
          ],
          [
            1,
            '[ap 09:19] Go in Action - William Kennedy.epub (kindle_split_017.html) - 9.19',
            'Listing <<9.19|5a:0>> shows a unit test for the /sendjson endpoint. On line 03 you see the name of the package is different from the other tests.',
          ],
          [
            1,
            '[ap 09:19] Go in Action - William Kennedy.epub (kindle_split_017.html) - 9.19',
            "Listing <<9.19|5a:0>> shows a unit test for the /sendjson endpoint. On line 03 you see the name of the package is different from the other tests.
Listing <<9.20|5a:0>>. handlers/handlers_test.go: lines 01\x{2013}03
01 // Sample test to show how to test the execution of an
02 // internal endpoint.
03 package handlers_test",
          ],
          [
            1,
            '[ap 09:20] Go in Action - William Kennedy.epub (kindle_split_017.html) - 9.20',
            'This time, as you can see in listing <<9.20|5a:0>>, the package name also ends with _test. When the package name ends like this, the test code can only access exported identifiers. This is true even if the test code file is in the same folder as the code being tested.',
          ],
          [
            1,
            '[ap 09:21] Go in Action - William Kennedy.epub (kindle_split_017.html) - 9.21',
            "Just like when running the service directly, the routes need to be initialized.
Listing <<9.21|5a:0>>. handlers/handlers_test.go: lines 17\x{2013}19
17 func init() {
18     handlers.Routes()
19 }",
          ],
          [
            1,
            '[ap 09:21] Go in Action - William Kennedy.epub (kindle_split_017.html) - 9.21',
            "On line 17 in listing <<9.21|5a:0>>, an init function is declared to initialize the routes. If the routes aren\x{2019}t initialized before the unit tests are run, then the tests will fail with an http.StatusNotFound error. Now we can look at the unit test for the /sendjson endpoint.",
          ],
          [
            1,
            '[ap 09:21] Go in Action - William Kennedy.epub (kindle_split_017.html) - 9.21',
            "On line 17 in listing <<9.21|5a:0>>, an init function is declared to initialize the routes. If the routes aren\x{2019}t initialized before the unit tests are run, then the tests will fail with an http.StatusNotFound error. Now we can look at the unit test for the /sendjson endpoint.
Listing <<9.22|5a:0>>. handlers/handlers_test.go: lines 21\x{2013}34
21 // TestSendJSON testing the sendjson internal endpoint.
22 func TestSendJSON(t *testing.T) {
23     t.Log(\"Given the need to test the SendJSON endpoint.\")
24     {
25         req, err := http.NewRequest(\"GET\", \"/sendjson\", nil)
26         if err != nil {
27             t.Fatal(\"\\tShould be able to create a request.\",
28                 ballotX, err)
29         }
30         t.Log(\"\\tShould be able to create a request.\",
31             checkMark)
32
33         rw := httptest.NewRecorder()
34         http.DefaultServeMux.ServeHTTP(rw, req)",
          ],
          [
            1,
            '[ap 09:22] Go in Action - William Kennedy.epub (kindle_split_017.html) - 9.22',
            'Listing <<9.22|5a:0>> shows the declaration of the TestSendJSON test function. The test starts off logging the given need of the test, and then on line 25 it creates an http.Request value. The request value is configured to be a GET call against the /sendjson endpoint. Since this is a GET call, nil is passed as the third parameter for the post data.',
          ],
          [
            1,
            '[ap 09:23] Go in Action - William Kennedy.epub (kindle_split_017.html) - 9.23',
            "Once the ServeHTTP method call completes, the http.ResponseRecorder value contains the response from our SendJSON function handler. Now we can test the response.
Listing <<9.23|5a:0>>. handlers/handlers_test.go: lines 36\x{2013}39
36         if rw.Code != 200 {
37             t.Fatal(\"\\tShould receive \\\"200\\\"\", ballotX, rw.Code)
38         }
39         t.Log(\"\\tShould receive \\\"200\\\"\", checkMark)",
          ],
          [
            1,
            '[ap 09:24] Go in Action - William Kennedy.epub (kindle_split_017.html) - 9.24',
            "First, the status of the response is checked on line 36. With any successful endpoint call, a status of 200 is expected. If the status is 200, then the JSON response is decoded into a Go value.
Listing <<9.24|5a:0>>. handlers/handlers_test.go: lines 41\x{2013}49
41         u := struct {
42             Name  string
43             Email string
44         }{}
45
46         if err := json.NewDecoder(rw.Body).Decode(&u); err != nil {
47             t.Fatal(\"\\tShould decode the response.\", ballotX)
48         }
49         t.Log(\"\\tShould decode the response.\", checkMark)",
          ],
          [
            1,
            '[ap 09:24] Go in Action - William Kennedy.epub (kindle_split_017.html) - 9.24',
            'On line 41 in listing <<9.24|5a:0>>, an anonymous struct type is declared, and a variable named u is created and initialized to its zero value. On line 46 the json package is used to decode the JSON document from the response into the u variable. If the decode fails, the unit test is ended; otherwise, we validate the values that were decoded.',
          ],
          [
            1,
            '[ap 09:24] Go in Action - William Kennedy.epub (kindle_split_017.html) - 9.24',
            "On line 41 in listing <<9.24|5a:0>>, an anonymous struct type is declared, and a variable named u is created and initialized to its zero value. On line 46 the json package is used to decode the JSON document from the response into the u variable. If the decode fails, the unit test is ended; otherwise, we validate the values that were decoded.
Listing <<9.25|5a:0>>. handlers/handlers_test.go: lines 51\x{2013}63
51         if u.Name == \"Bill\" {
52           t.Log(\"\\tShould have a Name.\", checkMark)
53         } else {
54           t.Error(\"\\tShould have a Name.\", ballotX, u.Name)
55         }
56
57         if u.Email == \"bill\@ardanstudios.com\" {
58             t.Log(\"\\tShould have an Email.\", checkMark)
59         } else {
60             t.Error(\"\\tShould have an Email.\", ballotX, u.Email)
61         }
62     }
63 }",
          ],
          [
            1,
            '[ap 09:25] Go in Action - William Kennedy.epub (kindle_split_017.html) - 9.25',
            'Listing <<9.25|5a:0>> shows both checks for each value we expect to receive. On line 51 we check that the value of the Name field is "Bill", and then on line 57 the value of the Email field is checked for "bill@ardanstudios.com". If these values match, then the unit test passes; otherwise, the unit test fails. These two checks use the Error method to report failure, so all the fields are checked.',
          ],
          [
            1,
            '[ap 09:26] Go in Action - William Kennedy.epub (kindle_split_017.html) - 9.26',
            "You can create your own examples and have them show up in the Go documentation for your packages. Let\x{2019}s look at an example for the SendJSON function from our previous example.
Listing <<9.26|5a:0>>. handlers_example_test.go
01 // Sample test to show how to write a basic example.
02 package handlers_test
03
04 import (
05     \"encoding/json\"
06     \"fmt\"
07     \"log\"",
          ],
          [
            1,
            '[ap 09:26] Go in Action - William Kennedy.epub (kindle_split_017.html) - 9.26',
            'Examples are based on existing functions or methods. Instead of starting the function with the word Test, we need to use the word Example. On line 13 in listing <<9.26|5a:0>>, the name of the example is ExampleSendJSON.',
          ],
          [
            1,
            '[ap 09:27] Go in Action - William Kennedy.epub (kindle_split_017.html) - 9.27',
            "The code you write for an example is to show someone how to use the specific function or method. To determine if the test succeeds or fails, the test will compare the final output of the function with the output listed at the bottom of the example function.
Listing <<9.27|5a:0>>. handlers_example_test.go: lines 27\x{2013}31
27     // Use fmt to write to stdout to check the output.
28     fmt.Println(u)
29     // Output:
30     // {Bill bill\@ardanstudios.com}
31 }",
          ],
          [
            1,
            '[ap 09:27] Go in Action - William Kennedy.epub (kindle_split_017.html) - 9.27',
            'On line 28 in listing <<9.27|5a:0>>, the code uses fmt.Println to write the value of u to stdout. The value of u is initialized from making a call to the /sendjson endpoint earlier in the function. On line 29 we have a comment with the word Output:.',
          ],
          [
            1,
            '[ap 09:28] Go in Action - William Kennedy.epub (kindle_split_017.html) - 9.28',
            "Let\x{2019}s look at a set of benchmark functions that reveal the fastest way to convert an integer value to a string. In the standard library, there are three different ways to convert an integer value to a string.
Listing <<9.28|5a:0>>. listing28_test.go: lines 01\x{2013}10
01 // Sample benchmarks to test which function is better for converting
02 // an integer into a string. First using the fmt.Sprintf function,
03 // then the strconv.FormatInt function and then strconv.Itoa.",
          ],
          [
            1,
            '[ap 09:28] Go in Action - William Kennedy.epub (kindle_split_017.html) - 9.28',
            "Listing <<9.28|5a:0>> shows the initial code for the listing28_test.go benchmarks. As with unit test files, the file name must end in _test.go. The testing package must also be imported. Next, let\x{2019}s look at one of the benchmark functions.",
          ],
          [
            1,
            '[ap 09:28] Go in Action - William Kennedy.epub (kindle_split_017.html) - 9.28',
            "Listing <<9.28|5a:0>> shows the initial code for the listing28_test.go benchmarks. As with unit test files, the file name must end in _test.go. The testing package must also be imported. Next, let\x{2019}s look at one of the benchmark functions.
Listing <<9.29|5a:0>>. listing28_test.go: lines 12\x{2013}22
12 // BenchmarkSprintf provides performance numbers for the
13 // fmt.Sprintf function.
14 func BenchmarkSprintf(b *testing.B) {
15     number := 10
16
17     b.ResetTimer()
18
19     for i := 0; i < b.N; i++ {
20         fmt.Sprintf(\"%d\", number)
21     }
22 }",
          ],
          [
            1,
            '[ap 09:29] Go in Action - William Kennedy.epub (kindle_split_017.html) - 9.29',
            'On line 14 in listing <<9.29|5a:0>>, you see the first benchmark, named BenchmarkSprintf. Benchmark functions begin with the word Benchmark and take as their only parameter a pointer of type testing.B. In order for the benchmarking framework to calculate performance, it must run the code over and over again for a period of time. This is where the for loop comes in.',
          ],
          [
            1,
            '[ap 09:29] Go in Action - William Kennedy.epub (kindle_split_017.html) - 9.29',
            "On line 14 in listing <<9.29|5a:0>>, you see the first benchmark, named BenchmarkSprintf. Benchmark functions begin with the word Benchmark and take as their only parameter a pointer of type testing.B. In order for the benchmarking framework to calculate performance, it must run the code over and over again for a period of time. This is where the for loop comes in.
Listing <<9.30|5a:0>>. listing28_test.go: lines 19\x{2013}22
19     for i := 0; i < b.N; i++ {
20         fmt.Sprintf(\"%d\", number)
21     }
22 }",
          ],
          [
            1,
            '[ap 09:30] Go in Action - William Kennedy.epub (kindle_split_017.html) - 9.30',
            "The for loop on line 19 in listing <<9.30|5a:0>> shows how to use the b.N value. On line 20 we have the call to the Sprintf function from the fmt package. This is the function we\x{2019}re benchmarking to convert an integer value into a string.",
          ],
          [
            1,
            '[ap 09:31] Go in Action - William Kennedy.epub (kindle_split_017.html) - 9.31',
            'If we just want to run benchmark functions, we need to use the -bench option.
Listing <<9.31|5a:0>>. Running the benchmark test
go test -v -run="none" -bench="BenchmarkSprintf"',
          ],
          [
            1,
            '[ap 09:32] Go in Action - William Kennedy.epub (kindle_split_017.html) - 9.32',
            "Let\x{2019}s look at the other two benchmark functions and then run all three benchmarks together to see what\x{2019}s the fastest way to convert an integer value to a string.
Listing <<9.32|5a:0>>. listing28_test.go: lines 24\x{2013}46
24 // BenchmarkFormat provides performance numbers for the
25 // strconv.FormatInt function.
26 func BenchmarkFormat(b *testing.B) {
27     number := int64(10)
28
29     b.ResetTimer()
30
31     for i := 0; i < b.N; i++ {
32         strconv.FormatInt(number, 10)
33     }
34 }
35
36 // BenchmarkItoa provides performance numbers for the
37 // strconv.Itoa function.
38 func BenchmarkItoa(b *testing.B) {
39     number := 10
40
41     b.ResetTimer()
42
43     for i := 0; i < b.N; i++ {
44         strconv.Itoa(number)
45     }
46 }",
          ],
          [
            1,
            '[ap 09:32] Go in Action - William Kennedy.epub (kindle_split_017.html) - 9.32',
            'Listing <<9.32|5a:0>> shows the other two benchmark functions. The BenchmarkFormat function benchmarks the use of the FormatInt function from the strconv package. The BenchmarkItoa function benchmarks the use of the Itoa function from the same strconv package. You can see the same pattern in these two other benchmark functions as in the BenchmarkSprintf function. The call is inside the for loop using b.N to control the number of iterations for each call.',
          ],
        ];
