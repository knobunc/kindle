$VAR1 = [
          [
            1,
            '[ap 02:10] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.10',
            "Listing <<2.10|5a:0>>. search/search.go: lines 08\x{2013}09
      
      08 // A map of registered matchers for searching.
09 var matchers = make(map[string]Matcher)
      
      This variable is located outside the scope of any function and so is considered a package-level variable. The variable is
         declared using the keyword var and is declared as a map of Matcher type values with a key of type string. The declaration for the Matcher type can be found in the match.go code file, and we\x{2019}ll describe the purpose of this type later. There\x{2019}s another important
         aspect of this variable declaration: the name of the variable matchers starts with a lowercase letter.",
          ],
          [
            1,
            '[ap 02:11] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.11',
            "Listing <<2.11|5a:0>>. Making a map
      
      make(map[string]Matcher)
      
      A map is a reference type that you\x{2019}re required to make in Go. If you don\x{2019}t make the map first and assign it to your variable, you\x{2019}ll receive errors when you try to use the map variable. This is because the zero value for a map variable is nil. In chapter 4 we\x{2019}ll go into greater detail about maps.",
          ],
          [
            1,
            '[ap 02:12] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.12',
            "Listing <<2.12|5a:0>>. search/search.go: lines 11\x{2013}57
      
      11 // Run performs the search logic.
12 func Run(searchTerm string) {
13     // Retrieve the list of feeds to search through.
14     feeds, err := RetrieveFeeds()
15     if err != nil {
16         log.Fatal(err)
17     }
18
19     // Create a unbuffered channel to receive match results.
20     results := make(chan *Result)
21
22     // Setup a wait group so we can process all the feeds.
23     var waitGroup sync.WaitGroup
24
25     // Set the number of goroutines we need to wait for while

26     // they process the individual feeds.
27     waitGroup.Add(len(feeds))
28
29     // Launch a goroutine for each feed to find the results.
30     for _, feed := range feeds {
31         // Retrieve a matcher for the search.
32         matcher, exists := matchers[feed.Type]
33         if !exists {
34             matcher = matchers[\"default\"]
35         }
36
37         // Launch the goroutine to perform the search.
38         go func(matcher Matcher, feed *Feed) {
39             Match(matcher, feed, searchTerm, results)
40             waitGroup.Done()
41         }(matcher, feed)
42     }
43
44     // Launch a goroutine to monitor when all the work is done.
45     go func() {
46         // Wait for everything to be processed.
47         waitGroup.Wait()
48
49         // Close the channel to signal to the Display
50         // function that we can exit the program.
51         close(results)
52     }()
53
54     // Start displaying results as they are available and
55     // return after the final result is displayed.
56     Display(results)
57 }
      
      The Run function contains the main control logic for the program. It\x{2019}s a good representation of how Go programs can be structured
         to handle the launching and synchronization of goroutines that run concurrently. Let\x{2019}s walk through the logic section by section,
         and then explore the other code files that lend their support.",
          ],
          [
            1,
            '[ap 02:13] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.13',
            "Listing <<2.13|5a:0>>. search/search.go: lines 11\x{2013}12
      
      11 // Run performs the search logic.
12 func Run(searchTerm string) {
      
      To declare a function in Go, use the keyword func followed by the function name, any parameters, and then any return values. In the case of Run, you have a single parameter called searchTerm of type string. The term the program will search against is passed into the Run function, and if you look at the main function again, you can see that exchange.",
          ],
          [
            1,
            '[ap 02:14] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.14',
            "Listing <<2.14|5a:0>>. main.go: lines 17\x{2013}21
      
      17 // main is the entry point for the program.
18 func main() {
19     // Perform the search for the specified term.
20     search.Run(\"president\")
21 }
      
      The first thing that the Run function does is retrieve a list of data feeds. These feeds are used to pull content from the internet that is then matched
         against the specified search term.",
          ],
          [
            1,
            '[ap 02:15] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.15',
            "Listing <<2.15|5a:0>>. search/search.go: lines 13\x{2013}17
      
      13     // Retrieve the list of feeds to search through.
14     feeds, err := RetrieveFeeds()
15     if err != nil {
16         log.Fatal(err)
17     }
      
      There are a few important concepts here that we need to go through. You can see on line 14 that we make a function call to
         the function RetrieveFeeds. This function belongs to the search package and returns two values. The first return value is a slice of Feed type values. A slice is a reference type that implements a dynamic array. You use slices in Go to work with lists of data.
         Chapter 4 goes into greater detail about slices.",
          ],
          [
            1,
            '[ap 02:16] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.16',
            "Listing <<2.16|5a:0>>. search/search.go: lines 13\x{2013}14
      
      13     // Retrieve the list of feeds to search through.
14     feeds, err := RetrieveFeeds()
      
      Here you see the use of the short variable declaration operator (:=). This operator is used to both declare and initialize variables at the same time. The type of each value being returned
         is used by the compiler to determine the type for each variable, respectively. The short variable declaration operator is
         just a shortcut to streamline your code and make the code more readable. The variable it declares is no different than any other variable you may declare
         when using the keyword var.",
          ],
          [
            1,
            '[ap 02:17] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.17',
            "Listing <<2.17|5a:0>>. search/search.go: lines 19\x{2013}20
      
      19     // Create a unbuffered channel to receive match results.
20     results := make(chan *Result)
      
      On line 20, we use the built-in function make to create an unbuffered channel. We use the short variable declaration operator to declare and initialize the channel variable
         with the call to make. A good rule of thumb when declaring variables is to use the keyword var when declaring variables that will be initialized to their zero value, and to use the short variable declaration operator
         when you\x{2019}re providing extra initialization or making a function call.",
          ],
          [
            1,
            '[ap 02:18] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.18',
            "Listing <<2.18|5a:0>>. search/search.go: lines 22\x{2013}27
      
      22     // Setup a wait group so we can process all the feeds.
23     var waitGroup sync.WaitGroup
24
25     // Set the number of goroutines we need to wait for while
26     // they process the individual feeds.
27     waitGroup.Add(len(feeds))
      
      In Go, once the main function returns, the program terminates. Any goroutines that were launched and are still running at this time will also
         be terminated by the Go runtime. When you write concurrent programs, it\x{2019}s best to cleanly terminate any goroutines that were
         launched prior to letting the main function return. Writing programs that can cleanly start and shut down helps reduce bugs and prevents resources from corruption.",
          ],
          [
            1,
            '[ap 02:19] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.19',
            "Listing <<2.19|5a:0>>. search/search.go: lines 29\x{2013}42
      
      29     // Launch a goroutine for each feed to find the results.
30     for _, feed := range feeds {
31         // Retrieve a matcher for the search.
32         matcher, exists := matchers[feed.Type]
33         if !exists {
34             matcher = matchers[\"default\"]
35         }
36
37         // Launch the goroutine to perform the search.
38         go func(matcher Matcher, feed *Feed) {
39             Match(matcher, feed, searchTerm, results)
40             waitGroup.Done()
41         }(matcher, feed)
42     }
      
      The code for lines 30 through 42 iterate through the list of data feeds we retrieved earlier and launch a goroutine for each
         one. To iterate over the slice of feeds, we use the keywords for range. The keyword range can be used with arrays, strings, slices, maps, and channels. When we use for range to iterate over a slice, we get two values back on each iteration. The first is the index position of the element we\x{2019}re iterating
         over, and the second is a copy of the value in that element.",
          ],
          [
            1,
            '[ap 02:20] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.20',
            "Listing <<2.20|5a:0>>. search/search.go: lines 29\x{2013}30
      
      29     // Launch a goroutine for each feed to find the results.
30     for _, feed := range feeds {
      
      This is the second time you see the blank identifier being used. You first saw it in main.go when we imported the matchers package. Now it\x{2019}s being used as a substitution for the variable that would be assigned to the index value for the range call.
         When you have a function that returns multiple values, and you don\x{2019}t have a need for one, you can use the blank identifier
         to ignore those values. In our case with this range, we won\x{2019}t be using the index value, so the blank identifier allows us
         to ignore it.",
          ],
          [
            1,
            '[ap 02:21] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.21',
            "Listing <<2.21|5a:1>>. search/search.go: lines 31\x{2013}35
      
      31         // Retrieve a matcher for the search.
32         matcher, exists := matchers[feed.Type]

33         if !exists {
34             matcher = matchers[\"default\"]
35         }
      
      We haven\x{2019}t talked about how this map gets its values yet. You\x{2019}ll see later on how the program initializes itself and populates
         this map. On line 32 we check the map for a key that matches the feed type. When looking up a key in a map, you have two options:
         you can assign a single variable or two variables for the lookup call. The first variable is always the value returned for
         the key lookup, and the second value, if specified, is a Boolean flag that reports whether the key exists or not. When a key
         doesn\x{2019}t exist, the map will return the zero value for the type of value being stored in the map. When the key does exist,
         the map will return a copy of the value for that key.",
          ],
          [
            1,
            '[ap 02:22] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.22',
            "Listing <<2.22|5a:0>>. search/search.go: lines 37\x{2013}41
      
      37         // Launch the goroutine to perform the search.
38         go func(matcher Matcher, feed *Feed) {
39             Match(matcher, feed, searchTerm, results)
40             waitGroup.Done()
41         }(matcher, feed)
      
      In chapter 6 we\x{2019}ll go into more detail about goroutines, but for now a goroutine is a function that\x{2019}s launched to run independently from other functions in the program. Use the keyword go to launch and schedule goroutines to run concurrently. On line 38 we use the keyword go to launch an anonymous function as a goroutine. An anonymous function is a function that\x{2019}s declared without a name. In our for range loop, we launch an anonymous function as a goroutine for each feed. This allows each feed to be processed independently in
         a concurrent fashion.",
          ],
          [
            1,
            '[ap 02:23] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.23',
            "Listing <<2.23|5a:0>>. search/search.go: lines 39\x{2013}40
      
      39             Match(matcher, feed, searchTerm, results)
40             waitGroup.Done()
      
      The first thing the goroutine does is call a function called Match, which can be found in the match.go code file. The Match function takes a value of type Matcher, a pointer to a value of type Feed, the search term, and the channel where the results are written to. We\x{2019}ll look at the internals of this function later, but
         for now it\x{2019}s enough to know that Match will search the feed and output matches to the results channel.",
          ],
          [
            1,
            '[ap 02:24] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.24',
            "Listing <<2.24|5a:0>>. search/search.go: lines 29\x{2013}32
      
      29     // Launch a goroutine for each feed to find the results.
30     for _, feed := range feeds {
31         // Retrieve a matcher for the search.
32         matcher, exists := matchers[feed.Type]
      
      The values of the feed and matcher variables are changing with each iteration of the loop, as you can see on lines 30 and 32. If we used closures for these
         variables, as the values of these variables changed in the outer function, those changes would be reflected in the anonymous
         function. All the goroutines would be sharing the same variables as the outer function thanks to closures. Unless we passed
         these values in as function parameters, most of the goroutines would end up processing the same feed using the same matcher\x{2014}most
         likely the last one in the feeds slice.",
          ],
          [
            1,
            '[ap 02:25] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.25',
            "Listing <<2.25|5a:0>>. search/search.go: lines 44\x{2013}57
      
      44     // Launch a goroutine to monitor when all the work is done.
45     go func() {
46         // Wait for everything to be processed.

47         waitGroup.Wait()
48
49         // Close the channel to signal to the Display
50         // function that we can exit the program.
51         close(results)
52     }()
53
54     // Start displaying results as they are available and
55     // return after the final result is displayed.
56     Display(results)
57 }
      
      The code between lines 45 and 56 is tricky to explain until we dive deeper into some of the other code in the search package. For now let\x{2019}s describe what we see and come back to it later to understand the mechanics. On lines 45 through 52
         we launch yet another anonymous function as a goroutine. This anonymous function takes no parameters and uses closures to
         access both the WaitGroup and results variables. This goroutine calls the method Wait on the WaitGroup value, which is causing the goroutine to block until the count for the WaitGroup hits zero. Once that happens, the goroutine calls the built-in function close on the channel, which as you\x{2019}ll see causes the program to terminate.",
          ],
          [
            1,
            '[ap 02:26] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.26',
            "Listing <<2.26|5a:0>>. feed.go: lines 01\x{2013}08
      
      01 package search
02
03 import (
04     \"encoding/json\"
05     \"os\"
06 )
07
08 const dataFile = \"data/data.json\"
      
      This code file exists in the search folder, and on line 01 the code file is declared to be in package search. You can see that on lines 03 through 06 we import two packages from the standard library. The json package provides support for encoding and decoding JSON and the os package provides support for accessing operating system functionality like reading files.",
          ],
          [
            1,
            '[ap 02:27] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.27',
            "Listing <<2.27|5a:0>>. data.json
      
      [
    {
        \"site\" : \"npr\",
        \"link\" : \"http://www.npr.org/rss/rss.php?id=1001\",
        \"type\" : \"rss\"
    },
    {
        \"site\" : \"cnn\",
        \"link\" : \"http://rss.cnn.com/rss/cnn_world.rss\",
        \"type\" : \"rss\"
    },
    {
        \"site\" : \"foxnews\",
        \"link\" : \"http://feeds.foxnews.com/foxnews/world?format=xml\",
        \"type\" : \"rss\"
    },
    {
        \"site\" : \"nbcnews\",
        \"link\" : \"http://feeds.nbcnews.com/feeds/topstories\",
        \"type\" : \"rss\"
    }
]
      
      The actual data file contains more than four data feeds, but listing <<2.27|5a:0>> shows a valid version of the data file. The data file contains an array of JSON documents. Each document in the data file
         provides a name of the site we\x{2019}re getting the data from, a link to the data, and the type of data we expect to receive.",
          ],
          [
            1,
            '[ap 02:28] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.28',
            "Listing <<2.28|5a:0>>. feed.go: lines 10\x{2013}15
      
      10 // Feed contains information we need to process a feed.
11 type Feed struct {
12     Name string `json:\"site\"`

13     URI  string `json:\"link\"`
14     Type string `json:\"type\"`
15 }
      
      On lines 11 through 15 we declare a struct type named Feed, which is an exported type. This type is declared with three fields, each of which are strings that match the fields for
         each document in the data file. If you look at each field declaration, tags have been included to provide the metadata that
         the JSON decoding function needs to create the slice of Feed type values. Each tag maps a field name in the struct type to a field name in the document.",
          ],
          [
            1,
            '[ap 02:29] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.29',
            "Listing <<2.29|5a:1>>. feed.go: lines 17\x{2013}36
      
      17 // RetrieveFeeds reads and unmarshals the feed data file.
18 func RetrieveFeeds() ([]*Feed, error) {
19    // Open the file.
20    file, err := os.Open(dataFile)
21    if err != nil {
22        return nil, err
23    }
24
25    // Schedule the file to be closed once
26    // the function returns.
27    defer file.Close()
28
29    // Decode the file into a slice of pointers
30    // to Feed values.
31    var feeds []*Feed
32    err = json.NewDecoder(file).Decode(&feeds)
33
34    // We don't need to check for errors, the caller can do this.
35    return feeds, err
36 }
      
      Let\x{2019}s start with the declaration of the function on line 18. The function takes no parameters and returns two values. The
         first return value is a slice of pointers to Feed type values. The second return value is an error value that reports back if the function call was successful. As you\x{2019}ll continue
         to see, returning error values is common practice in this code example and throughout the standard library.",
          ],
          [
            1,
            '[ap 02:30] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.30',
            "Listing <<2.30|5a:0>>. feed.go: lines 25\x{2013}27
      
      25    // Schedule the file to be closed once
26    // the function returns.
27    defer file.Close()
      
      The keyword defer is used to schedule a function call to be executed right after a function returns. It\x{2019}s our responsibility to close the file
         once we\x{2019}re done with it. By using the keyword defer to schedule the call to the close method, we can guarantee that the method will be called. This will happen even if the function panics and terminates unexpectedly.
         The keyword defer lets us write this statement close to where the opening of the file occurs, which helps with readability and reducing bugs.",
          ],
          [
            1,
            '[ap 02:31] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.31',
            "Listing <<2.31|5a:0>>. feed.go: lines 29\x{2013}36
      
      29    // Decode the file into a slice of pointers
30    // to Feed values.
31    var feeds []*Feed
32    err = json.NewDecoder(file).Decode(&feeds)
33
34    // We don't need to check for errors, the caller can do this.
35    return feeds, err
36 }
      
      On line 31 we declare a nil slice named feeds that contains pointers to Feed type values. Then on line 32 we make a call to the Decode method off the value returned by the NewDecoder function from the json package. The NewDecoder function takes the file handle we created from the method call to Open and returns a pointer to a value of type Decoder. From that value we call the Decode method, passing the address to the slice. The Decode method then decodes the data file and populates our slice with a set of Feed type values.",
          ],
          [
            1,
            '[ap 02:32] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.32',
            "Listing <<2.32|5a:0>>. Using the empty interface
      
      func (dec *Decoder) Decode(v interface{}) error
      
      The parameter for the Decode method accepts a value of type interface{}. This is a special type in Go and works with the reflection support that can be found in the reflect package. In chapter 9 we\x{2019}ll go into more detail about reflection and how this method works.",
          ],
          [
            1,
            '[ap 02:33] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.33',
            "Listing <<2.33|5a:0>>. search/search.go : lines 29 - 42
      
      29     // Launch a goroutine for each feed to find the results.
30     for _, feed := range feeds {
31         // Retrieve a matcher for the search.
32         matcher, exists := matchers[feed.Type]
33         if !exists {
34             matcher = matchers[\"default\"]
35         }
36
37         // Launch the goroutine to perform the search.
38         go func(matcher Matcher, feed *Feed) {
39             Match(matcher, feed, searchTerm, results)
40             waitGroup.Done()
41         }(matcher, feed)
42     }
      
      The code on line 32 looks up a matcher value based on the feed type; that value is then used to process a search against that
         specific feed. Then on line 38 through 41, a goroutine is launched for that matcher and feed value. The key to making this
         code work is the ability of this framework code to use an interface type to capture and call into the specific implementation
         for each matcher value. This allows the code to handle different types of matcher values in a consistent and generic way.
         Let\x{2019}s look at the code in match.go and see how we\x{2019}re able to implement this functionality.",
          ],
          [
            1,
            '[ap 02:34] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.34',
            "Listing <<2.34|5a:0>>. search/match.go: lines 01\x{2013}17
      
      01 package search
02
03 import (
04     \"log\"
05 )
06
07 // Result contains the result of a search.
08 type Result struct {
09     Field   string
10     Content string
11 }
12

13 // Matcher defines the behavior required by types that want
14 // to implement a new search type.
15 type Matcher interface {
16     Search(feed *Feed, searchTerm string) ([]*Result, error)
17 }
      
      Let\x{2019}s jump to lines 15 through 17 and look at the declaration of the interface type named Matcher. Up until now we\x{2019}ve only been declaring struct types, but here you see code that\x{2019}s declaring an interface type. We\x{2019}ll get into a lot more detail about interfaces in chapter 5, but for now know that interfaces declare behavior that\x{2019}s required to be implemented by struct or named types to satisfy
         the interface. The behavior of an interface is defined by the methods that are declared within the interface type.",
          ],
          [
            1,
            '[ap 02:35] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.35',
            "Listing <<2.35|5a:0>>. search/default.go: lines 01\x{2013}15
      
      01 package search
02
03 // defaultMatcher implements the default matcher.
04 type defaultMatcher struct{}
05
06 // init registers the default matcher with the program.
07 func init() {
08     var matcher defaultMatcher
09     Register(\"default\", matcher)
10 }
11
12 // Search implements the behavior for the default matcher.
13 func (m defaultMatcher) Search(feed *Feed, searchTerm string)
                                                   ([]*Result, error) {
14     return nil, nil
15 }
      
      On line 04 we declare a struct type named defaultMatcher using an empty struct. An empty struct allocates zero bytes when values of this type are created. They\x{2019}re great when you
         need a type but not any state. For the default matcher, we don\x{2019}t need to maintain any state; we only need to implement the
         interface.",
          ],
          [
            1,
            '[ap 02:36] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.36',
            "Listing <<2.36|5a:0>>. search/default.go: line 13
      
      13 func (m defaultMatcher) Search
      
      The use of a receiver with any function declaration declares a method that\x{2019}s bound to the specified receiver type. In our
         case, the declaration of the Search method is now bound to values of type defaultMatcher. This means we can call the method Search from values and pointers of type defaultMatcher. Whether we use a value or pointer of the receiver type to make the method call, the compiler will reference or dereference
         the value if necessary to support the call.",
          ],
          [
            1,
            '[ap 02:37] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.37',
            "Listing <<2.37|5a:0>>. Example of method calls
      
      // Method declared with a value receiver of type defaultMatcher
func (m defaultMatcher) Search(feed *Feed, searchTerm string)

// Declare a pointer of type defaultMatch
dm := new(defaultMatch)

// The compiler will dereference the dm pointer to make the call
dm.Search(feed, \"test\")

// Method declared with a pointer receiver of type defaultMatcher
func (m *defaultMatcher) Search(feed *Feed, searchTerm string)

// Declare a value of type defaultMatch
var dm defaultMatch

// The compiler will reference the dm value to make the call
dm.Search(feed, \"test\")
      
      It\x{2019}s best practice to declare methods using pointer receivers, since many of the methods you implement need to manipulate
         the state of the value being used to make the method call. In the case of the defaultMatcher type, we want to use a value receiver because creating values of type defaultMatcher result in values of zero allocation. Using a pointer makes no sense since there\x{2019}s no state to be manipulated.",
          ],
          [
            1,
            '[ap 02:38] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.38',
            "Listing <<2.38|5a:0>>. Example of interface method call restrictions
      
      // Method declared with a pointer receiver of type defaultMatcher
func (m *defaultMatcher) Search(feed *Feed, searchTerm string)

// Call the method via an interface type value
var dm defaultMatcher
var matcher Matcher = dm     // Assign value to interface type
matcher.Search(feed, \"test\") // Call interface method with value

> go build
cannot use dm (type defaultMatcher) as type Matcher in assignment

// Method declared with a value receiver of type defaultMatcher
func (m defaultMatcher) Search(feed *Feed, searchTerm string)

// Call the method via an interface type value
var dm defaultMatcher
var matcher Matcher = &dm    // Assign pointer to interface type
matcher.Search(feed, \"test\") // Call interface method with pointer

> go build
Build Successful
      
      There\x{2019}s nothing else that the defaultMatcher type needs to do to implement the interface. From this point forward, values and pointers of type defaultMatcher satisfy the interface and can be used as values of type Matcher. That\x{2019}s the key to making this work. Values and pointers of type defaultMatcher are now also values of type Matcher and can be assigned or passed to functions accepting values of type Matcher.",
          ],
          [
            1,
            '[ap 02:39] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.39',
            "Listing <<2.39|5a:0>>. search/match.go: lines 19\x{2013}33
      
      19 // Match is launched as a goroutine for each individual feed to run
20 // searches concurrently.
21 func Match(matcher Matcher, feed *Feed, searchTerm string,
                                              results chan<- *Result) {
22     // Perform the search against the specified matcher.
23     searchResults, err := matcher.Search(feed, searchTerm)
24     if err != nil {
25         log.Println(err)
26         return
27     }
28
29     // Write the results to the channel.
30     for _, result := range searchResults {
31         results <- result
32     }
33 }
      
      This is the function that performs the actual search using values or pointers that implement the Matcher interface. This function accepts values of type Matcher as the first parameter. Only values or pointers that implement the Matcher interface will be accepted for this parameter. Since the defaultMatcher type now implements the interface declared with a value receiver, values or pointers of type defaultMatcher can be passed into this function.",
          ],
          [
            1,
            '[ap 02:40] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.40',
            "Listing <<2.40|5a:0>>. search/match.go: lines 35\x{2013}43
      
      35 // Display writes results to the terminal window as they
36 // are received by the individual goroutines.
37 func Display(results chan *Result) {
38     // The channel blocks until a result is written to the channel.
39     // Once the channel is closed the for loop terminates.
40     for result := range results {
41         fmt.Printf(\"%s:\\n%s\\n\\n\", result.Field, result.Content)
42     }
43 }
      
      A bit of channel magic allows this function to process all of the results before returning. It\x{2019}s based on how channels and
         the keyword range behaves when a channel is closed. Let\x{2019}s briefly look at the code in the Run function again that closes the results channel and calls the Display function.",
          ],
          [
            1,
            '[ap 02:41] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.41',
            "Listing <<2.41|5a:0>>. search/search.go: lines 44\x{2013}57
      
      44     // Launch a goroutine to monitor when all the work is done.
45     go func() {
46         // Wait for everything to be processed.
47         waitGroup.Wait()
48
49         // Close the channel to signal to the Display
50         // function that we can exit the program.
51         close(results)
52     }()
53
54     // Start displaying results as they are available and
55     // return after the final result is displayed.
56     Display(results)
57 }
      
      The goroutine on lines 45 through 52 waits on the waitGroup for all the search goroutines to call the Done method. Once the last search goroutine calls Done, the Wait method returns, and then the code on line 51 closes the results channel. Once the channel is closed, the goroutine terminates and is no more.",
          ],
          [
            1,
            '[ap 02:42] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.42',
            "Listing <<2.42|5a:0>>. search/match.go: lines 29\x{2013}32
      
      29     // Write the results to the channel.
30     for _, result := range searchResults {
31         results <- result
32     }
      
      If we look back at the for range loop on lines 40 through 42 of the match.go code file, we can connect the writing of the results, the closing of the channel,
         and the processing of results all together.",
          ],
          [
            1,
            '[ap 02:43] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.43',
            "Listing <<2.43|5a:0>>. search/match.go: lines 38\x{2013}42
      
      38     // The channel blocks until a result is written to the channel.
39     // Once the channel is closed the for loop terminates.
40     for result := range results {
41         log.Printf(\"%s:\\n%s\\n\\n\", result.Field, result.Content)
42     }
      
      The for range loop on line 40 of the match.go code file will block until a result is written to the channel. As each search goroutine writes
         its results to the channel (as you see on line 31 of the code file match.go), the for range loop wakes up and is given those results. The results are then immediately written to the log. It seems this for range loop is stuck in an endless loop, but it isn\x{2019}t. Once the channel is closed on line 51 of the search.go code file, the for range loop is terminated and the Display function returns.",
          ],
          [
            1,
            '[ap 02:44] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.44',
            "Listing <<2.44|5a:0>>. search/default.go: lines 06\x{2013}10
      
      06 // init registers the default matcher with the program.
07 func init() {
08     var matcher defaultMatcher
09     Register(\"default\", matcher)
10 }
      
      The default.go code file has a special function declared called init. You saw this function also declared in the main.go code file, and we talked about how all the init functions in the program would be called before the main function begins. Let\x{2019}s look at the imports again from the main.go code file.",
          ],
          [
            1,
            '[ap 02:45] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.45',
            "Listing <<2.45|5a:0>>. main.go: lines 07\x{2013}08
      
      07   _ \"github.com/goinaction/code/chapter2/sample/matchers\"
08    \"github.com/goinaction/code/chapter2/sample/search\"
      
      The import to the search package on line 08 allows the compiler to find the init function in the default.go code file. Once the compiler sees the init function, it\x{2019}s scheduled to be called prior to the main function being called.",
          ],
          [
            1,
            '[ap 02:46] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.46',
            "Listing <<2.46|5a:0>>. search/search.go: lines 59\x{2013}67
      
      59 // Register is called to register a matcher for use by the program.
60 func Register(feedType string, matcher Matcher) {
61     if _, exists := matchers[feedType]; exists {
62         log.Fatalln(feedType, \"Matcher already registered\")
63     }
64
65     log.Println(\"Register\", feedType, \"matcher\")
66     matchers[feedType] = matcher
67 }
      
      This function is responsible for adding the Matcher value to the map of registered matchers. All of this registration needs to happen before the main function gets called. Using init functions is a great way to accomplish this type of initialized registration.",
          ],
          [
            1,
            '[ap 02:47] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.47',
            "The RSS document in listing <<2.47|5a:0>> shows you a sample of what we expect to receive when we use any link in the data feed that\x{2019}s typed as an RSS feed.",
          ],
          [
            1,
            '[ap 02:47] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.47',
            "Listing <<2.47|5a:0>>. Expected RSS feed document
      
      <rss xmlns:npr=\"http://www.npr.org/rss/\" xmlns:nprml=\"http://api
    <channel>
        <title>News</title>
        <link>...</link>
        <description>...</description>

        <language>en</language>
        <copyright>Copyright 2014 NPR - For Personal Use
        <image>...</image>
        <item>
            <title>
                Putin Says He'll Respect Ukraine Vote But U.S.
            </title>
            <description>
                The White House and State Department have called on the
            </description>
      
      If you take any link from listing <<2.47|5a:0>> and put it in a browser, you\x{2019}ll be able to see a complete view of the expected RSS document. The implementation of the RSS
         matcher pulls down these RSS documents, searches the title and description fields for the search term, and sends the results
         over the results channel. Let\x{2019}s start by looking at the first 12 lines of code for the rss.go code file.",
          ],
          [
            1,
            '[ap 02:48] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.48',
            "Listing <<2.48|5a:0>>. matchers/rss.go: lines 01\x{2013}12
      
      01 package matchers
02
03 import (
04     \"encoding/xml\"
05     \"errors\"
06     \"fmt\"
07     \"log\"
08     \"net/http\"
09     \"regexp\"
10
11     \"github.com/goinaction/code/chapter2/sample/search\"
12 )
      
      As with every code file, we start on line 01 with the name of the package. This code file can be found in a folder called
         matchers, so the package name is matchers. Next we have six imports from the standard library and one import to the search package. Again, we have some packages from the standard library being imported from subfolders within the standard library,
         such as xml and http. Just like with the json package, the name of the last folder in the path represents the name of the package.",
          ],
          [
            1,
            '[ap 02:49] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.49',
            "Listing <<2.49|5a:0>>. matchers/rss.go: lines 14\x{2013}58
      
      14 type (
15     // item defines the fields associated with the item tag
16     // in the rss document.
17     item struct {
18         XMLName     xml.Name `xml:\"item\"`
19         PubDate     string   `xml:\"pubDate\"`
20         Title       string   `xml:\"title\"`
21         Description string   `xml:\"description\"`

22         Link        string   `xml:\"link\"`
23         GUID        string   `xml:\"guid\"`
24         GeoRssPoint string   `xml:\"georss:point\"`
25     }
26
27     // image defines the fields associated with the image tag
28     // in the rss document.
29     image struct {
30         XMLName xml.Name `xml:\"image\"`
31         URL     string   `xml:\"url\"`
32         Title   string   `xml:\"title\"`
33         Link    string   `xml:\"link\"`
34     }
35
36     // channel defines the fields associated with the channel tag
37     // in the rss document.
38     channel struct {
39         XMLName        xml.Name `xml:\"channel\"`
40         Title          string   `xml:\"title\"`
41         Description    string   `xml:\"description\"`
42         Link           string   `xml:\"link\"`
43         PubDate        string   `xml:\"pubDate\"`
44         LastBuildDate  string   `xml:\"lastBuildDate\"`
45         TTL            string   `xml:\"ttl\"`
46         Language       string   `xml:\"language\"`
47         ManagingEditor string   `xml:\"managingEditor\"`
48         WebMaster      string   `xml:\"webMaster\"`
49         Image          image    `xml:\"image\"`
50         Item           []item   `xml:\"item\"`
51    }
52
53    // rssDocument defines the fields associated with the rss document
54    rssDocument struct {
55         XMLName xml.Name `xml:\"rss\"`
56         Channel channel  `xml:\"channel\"`
57    }
58 )
      
      If you match these structures to the RSS document from any of the feed links, you\x{2019}ll see how everything correlates. Decoding
         XML is identical to how we decoded JSON in the feed.go code file. Next we can look at the declaration of the rssMatcher type.",
          ],
          [
            1,
            '[ap 02:50] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.50',
            "Listing <<2.50|5a:0>>. matchers/rss.go: lines 60\x{2013}61
      
      60 // rssMatcher implements the Matcher interface.
61 type rssMatcher struct{}
      
      Again, this looks just like how we declared the defaultMatcher type. We use an empty struct since we don\x{2019}t need to maintain any state; we just implement the Matcher interface. Next we have the implementation of the matcher init function.",
          ],
          [
            1,
            '[ap 02:51] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.51',
            "Listing <<2.51|5a:0>>. matchers/rss.go: lines 63\x{2013}67
      
      63 // init registers the matcher with the program.
64 func init() {
65     var matcher rssMatcher
66     search.Register(\"rss\", matcher)
67 }
      
      Just like you saw with the default matcher, the init function registers a value of the rssMatcher type with the program for use. Let\x{2019}s look at the import in the main.go code file once more.",
          ],
          [
            1,
            '[ap 02:52] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.52',
            "Listing <<2.52|5a:0>>. main.go: lines 07\x{2013}08
      
      07   _ \"github.com/goinaction/code/chapter2/sample/matchers\"
08    \"github.com/goinaction/code/chapter2/sample/search\"
      
      The code in the main.go code file doesn\x{2019}t directly use any identifiers from the matchers package. Yet we need the compiler to schedule the call to the init function in the rss.go code file. On line 07 we accomplish this by using the blank identifier as the alias name for the import.
         This allows the compiler to not produce an error for declaring the import and to locate the init function. With all of the imports, types, and initialization set, let\x{2019}s look at the two remaining methods that support the
         implementation of the Matcher interface.",
          ],
          [
            1,
            '[ap 02:53] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.53',
            "Listing <<2.53|5a:0>>. matchers/rss.go: lines 114\x{2013}140
      
      114 // retrieve performs a HTTP Get request for the rss feed and decodes
115 func (m rssMatcher) retrieve(feed *search.Feed)
                                                 (*rssDocument, error) {
116     if feed.URI == \"\" {
117         return nil, errors.New(\"No rss feed URI provided\")
118     }
119
120     // Retrieve the rss feed document from the web.
121     resp, err := http.Get(feed.URI)
122     if err != nil {
123         return nil, err
124     }
125
126     // Close the response once we return from the function.
127     defer resp.Body.Close()
128
129     // Check the status code for a 200 so we know we have received a
130     // proper response.
131     if resp.StatusCode != 200 {
132         return nil, fmt.Errorf(\"HTTP Response Error %d\\n\",
                                                        resp.StatusCode)
133     }
134
135     // Decode the rss feed document into our struct type.

136     // We don't need to check for errors, the caller can do this.
137     var document rssDocument
138     err = xml.NewDecoder(resp.Body).Decode(&document)
139     return &document, err
140 }
      
      The unexported method retrieve performs the logic for pulling the RSS document from the web for each individual feed link. On line 121 you can see the use
         of the Get method from the http package. In chapter 8 we\x{2019}ll explore this package more, but for now Go makes it really easy to make web requests using the http package. When the Get method returns, we\x{2019}ll get back a pointer to a value of type Response. After checking for errors, we need to schedule the call to the Close method, which we do on line 127.",
          ],
          [
            1,
            '[ap 02:54] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.54',
            "Listing <<2.54|5a:0>>. matchers/rss.go: lines 69\x{2013}112
      
       69 // Search looks at the document for the specified search term.
 70 func (m rssMatcher) Search(feed *search.Feed, searchTerm string)
                                            ([]*search.Result, error) {
 71     var results []*search.Result
 72
 73     log.Printf(\"Search Feed Type[%s] Site[%s] For Uri[%s]\\n\",
                                        feed.Type, feed.Name, feed.URI)
 74
 75     // Retrieve the data to search.
 76     document, err := m.retrieve(feed)
 77     if err != nil {
 78         return nil, err
 79     }
 80
 81     for _, channelItem := range document.Channel.Item {
 82         // Check the title for the search term.
 83         matched, err := regexp.MatchString(searchTerm,
                                                     channelItem.Title)
 84         if err != nil {
 85             return nil, err
 86         }
 87
 88         // If we found a match save the result.
 89         if matched {
 90            results = append(results, &search.Result{
 91                Field:   \"Title\",
 92                Content: channelItem.Title,

 93            })
 94         }
 95
 96         // Check the description for the search term.
 97         matched, err = regexp.MatchString(searchTerm,
                                               channelItem.Description)
 98         if err != nil {
 99             return nil, err
100         }
101
102         // If we found a match save the result.
103         if matched {
104             results = append(results, &search.Result{
105                 Field:   \"Description\",
106                 Content: channelItem.Description,
107             })
108         }
109     }
110
111     return results, nil
112 }
      
      We start on line 71 with the declaration of the results variable, which will be used to store and return any results that may be found.",
          ],
          [
            1,
            '[ap 02:55] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.55',
            'Listing <<2.55|5a:0>>. matchers/rss.go: line 71
      
      71      var results []*search.Result
      
      We use the keyword var and declare a nil slice of pointers to Result type values. The declaration of the Result type can be found again on line 08 of the match.go code file. Next on line 76 we make a web call using the retrieve method we just reviewed.',
          ],
          [
            1,
            '[ap 02:56] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.56',
            "Listing <<2.56|5a:0>>. matchers/rss.go: lines 75\x{2013}79
      
      75      // Retrieve the data to search.
76      document, err := m.retrieve(feed)
77      if err != nil {
78          return nil, err
79      }
      
      The call to the retrieve method returns a pointer to a value of type rssDocument and an error value. Then, as you\x{2019}ve seen throughout the code, we check the error value for errors and return if there was
         an error. If no error exists, we then iterate through the results performing the match of the search term against the title
         and description of the retrieved RSS document.",
          ],
          [
            1,
            '[ap 02:57] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.57',
            "Listing <<2.57|5a:0>>. matchers/rss.go: lines 81\x{2013}86
      
      81      for _, channelItem := range document.Channel.Item {
82          // Check the title for the search term.
83          matched, err := regexp.MatchString(searchTerm,
                                                      channelItem.Title)

84          if err != nil {
85              return nil, err
86          }
      
      Since the value of document.Channel.Item is a slice of item type values, we use a for range loop on line 81 to iterate through all the items. On line 83 we use the MatchString function from the regexp package to match the search term against the content in the Title field of the channelItem value. Then we check for errors on line 84. If there are no errors, we move to lines 89 through 94 to check the results of
         the match.",
          ],
          [
            1,
            '[ap 02:58] Go in Action - William Kennedy.epub (kindle_split_010.html) - 2.58',
            "Listing <<2.58|5a:0>>. matchers/rss.go: lines 88\x{2013}94
      
      88          // If we found a match save the result.
89          if matched {
90             results = append(results, &search.Result{
91                 Field:   \"Title\",
92                 Content: channelItem.Title,
93             })
94          }
      
      If the value of matched is true after the call to the MatchString method, we use the built-in function append to add the search results to the results slice. The built-in function append will grow the length and capacity of the slice as it needs to. You\x{2019}ll learn more about the built-in function append in chapter 4. The first parameter to append is the value of the slice you want to append to, and the second parameter is the value you want to append. In our case, we
         use a struct literal to declare and initialize a value of type Result, and then we use the ampersand (&) operator to get the address of this new value, which is stored in the slice.",
          ],
          [
            1,
            '[ap 03:14] Go in Action - William Kennedy.epub (kindle_split_011.html) - 3.14',
            "Listing 3.8. Working with go vet
      01 package main
02
03 import \"fmt\"
04
05 func main() {
06     fmt.Printf(\"The quick brown fox jumped over lazy dogs\", <<3.14|5a:0>>)
07 }
      
      This program inserts the floating-point number 3.14, but there\x{2019}s no placeholder in the formatted string. If you run go vet against this source code, you get the following message:",
          ],
          [
            1,
            '[ap 03:10] Go in Action - William Kennedy.epub (kindle_split_011.html) - 3.10',
            'Listing <<3.10|5a:0>>. Before vendoring
      
      01 package main
02
03 import (
04     "bitbucket.org/ww/goautoneg"
05     "github.com/beorn7/perks"
06 )
      
      
      
      Listing <<3.11|5a:0>>. After vendoring
      
      01 package main
02
03 import (
04     "github.ardanstudios.com/myproject/Godeps/_workspace/src/
                                             bitbucket.org/ww/goautoneg"
05     "github.ardanstudios.com/myproject/Godeps/_workspace/src/
                                                github.com/beorn7/perks"
06 )
      
      Before the dependencies were vendored, the import statements used the canonical path for the package. The code was physically located on disk within the scope of GOPATH. After vendoring, import path rewriting became necessary to reference the packages, which are now physically located on disk
         inside the project itself. You can see these imports are very large and tedious to use.',
          ],
          [
            1,
            '[ap 03:12] Go in Action - William Kennedy.epub (kindle_split_011.html) - 3.12',
            'Listing <<3.12|5a:0>>. Example of a gb project
      
      /home/bill/devel/myproject ($PROJECT)
|-- src
|   |-- cmd
|   |   |-- myproject
|   |   |   |-- main.go
|   |-- examples
|   |-- model
|   |-- README.md
|-- vendor
    |-- src
        |-- bitbucket.org
        |   |-- ww
        |       |-- goautoneg
        |       |-- Makefile
        |       |-- README.txt
        |       |-- autoneg.go
        |       |-- autoneg_test.go
        |-- github.com
            |-- beorn7
                |-- perks
                |-- README.md
                |-- quantile
                |-- bench_test.go
        |-- example_test.go
        |-- exampledata.txt
        |-- stream.go
      
      A gb project is simply a directory on disk that contains a subdirectory named src/. The symbol $PROJECT refers to the root directory on disk where the src/ directory is located and is only used as a shortcut for describing the location on disk for the project. $PROJECT is not an environmental variable that needs to be set. In fact, gb requires no environmental variables to be set at all.',
          ],
          [
            1,
            '[ap 03:13] Go in Action - William Kennedy.epub (kindle_split_011.html) - 3.13',
            "Listing <<3.13|5a:0>>. The location for the code you write for the project
      
      \$PROJECT/src/
      
      
      
      Listing <<3.14|5a:0>>. The location of vendored code
      
      \$PROJECT/vendor/src/
      
      One of the best things about gb is that there\x{2019}s no need for import path rewriting. Look at the import statements that are declared inside of main.go\x{2014}nothing needs to change to reference the vendored dependencies.",
          ],
          [
            1,
            '[ap 03:15] Go in Action - William Kennedy.epub (kindle_split_011.html) - 3.15',
            "Listing <<3.15|5a:0>>. Import paths for gb projects
      
      01 package main
02
03 import (
04     \"bitbucket.org/ww/goautoneg\"
05     \"github.com/beorn7/perks\"
06 )
      
      The gb tool will look inside the \$PROJECT/vendor/src/ directory for these imports if they can\x{2019}t be located inside the \$PROJECT/src/ directory first. The entire source code for the project is located within a single repo and directory on disk, split between
         the src/ and vendor/src/ subdirectories. This, in conjunction with no need to rewrite import paths and the freedom to place your project anywhere
         you wish on disk, makes gb a popular tool in the community to develop projects that require reproducible builds.",
          ],
          [
            1,
            '[ap 03:16] Go in Action - William Kennedy.epub (kindle_split_011.html) - 3.16',
            'Listing <<3.16|5a:0>>. Building a gb project
      
      gb build all
      
      Many of the same features that are supported by the Go tooling are supported in gb. Gb also has a plugin system to allow the
         community to extend support. One such plugin is called vendor, which provides conveniences to manage the dependencies in the $PROJECT/vendor/src/ directory, something the Go tooling does not have today. To learn more about gb, check out the website: getgb.io.',
          ],
          [
            1,
            '[ap 04:10] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.10',
            'Listing <<4.10|5a:0>>. Declaring two-dimensional arrays
      
      // Declare a two dimensional integer array of four elements
// by two elements.
var array [4][2]int

// Use an array literal to declare and initialize a two
// dimensional integer array.
array := [4][2]int{{10, 11}, {20, 21}, {30, 31}, {40, 41}}

// Declare and initialize index 1 and 3 of the outer array.
array := [4][2]int{1: {20, 21}, 3: {40, 41}}

// Declare and initialize individual elements of the outer
// and inner array.
array := [4][2]int{1: {0: 20}, 3: {1: 41}}
      
      Figure 4.8 shows the values each array contains after declaring and initializing these arrays.',
          ],
          [
            1,
            '[ap 04:11] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.11',
            'Listing <<4.11|5a:0>>. Accessing elements of a two-dimensional array
      
      // Declare a two dimensional integer array of two elements.
var array [2][2]int

// Set integer values to each individual element.
array[0][0] = 10
array[0][1] = 20
array[1][0] = 30
array[1][1] = 40
      
      You can copy multidimensional arrays into each other as long as they have the same type. The type of a multidimensional array
         is based on the length of each dimension and the type of data that can be stored in each element.',
          ],
          [
            1,
            '[ap 04:12] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.12',
            'Listing <<4.12|5a:0>>. Assigning multidimensional arrays of the same type
      
      // Declare two different two dimensional integer arrays.
var array1 [2][2]int
var array2 [2][2]int

// Add integer values to each individual element.
array2[0][0] = 10
array2[0][1] = 20
array2[1][0] = 30
array2[1][1] = 40

// Copy the values from array2 into array1.
array1 = array2
      
      Because an array is a value, you can copy individual dimensions.',
          ],
          [
            1,
            '[ap 04:13] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.13',
            "Listing <<4.13|5a:0>>. Assigning multidimensional arrays by index
      
      // Copy index 1 of array1 into a new array of the same type.
var array3 [2]int = array1[1]

// Copy the integer found in index 1 of the outer array
// and index 0 of the interior array into a new variable of
// type integer.
var value int = array1[1][0]
      
      
      
      4.1.5. Passing arrays between functions
      
      
      Passing an array between functions can be an expensive operation in terms of memory and performance. When you pass variables
         between functions, they\x{2019}re always passed by value. When your variable is an array, this means the entire array, regardless
         of its size, is copied and passed to the function.",
          ],
          [
            1,
            '[ap 04:14] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.14',
            "Listing <<4.14|5a:0>>. Passing a large array by value between functions
      
      // Declare an array of 8 megabytes.
var array [1e6]int

// Pass the array to the function foo.
foo(array)

// Function foo accepts an array of one million integers.
func foo(array [1e6]int) {
    ...
}
      
      Every time the function foo is called, eight megabytes of memory has to be allocated on the stack. Then the value of the array, all eight megabytes of
         memory, has to be copied into that allocation. Go can handle this copy operation, but there\x{2019}s a better and more efficient
         way of doing this. You can pass a pointer to the array and only copy eight bytes, instead of eight megabytes of memory on
         the stack.",
          ],
          [
            1,
            '[ap 04:15] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.15',
            'Listing <<4.15|5a:0>>. Passing a large array by pointer between functions
      
      // Allocate an array of 8 megabytes.
var array [1e6]int

// Pass the address of the array to the function foo.
foo(&array)

// Function foo accepts a pointer to an array of one million integers.
func foo(array *[1e6]int) {
    ...
}
      
      This time the function foo takes a pointer to an array of one million elements of type integer. The function call now passes the address of the array,
         which only requires eight bytes of memory to be allocated on the stack for the pointer variable.',
          ],
          [
            1,
            '[ap 04:16] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.16',
            'Listing <<4.16|5a:0>>. Declaring a slice of strings by length
      
      // Create a slice of strings.
// Contains a length and capacity of 5 elements.
slice := make([]string, 5)
      
      When you just specify the length, the capacity of the slice is the same. You can also specify the length and capacity separately.',
          ],
          [
            1,
            '[ap 04:17] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.17',
            "Listing <<4.17|5a:0>>. Declaring a slice of integers by length and capacity
      
      // Create a slice of integers.
// Contains a length of 3 and has a capacity of 5 elements.
slice := make([]int, 3, 5)
      
      When you specify the length and capacity separately, you can create a slice with available capacity in the underlying array
         that you don\x{2019}t have access to initially. Figure 4.9 depicts what the slice of integers declared in listing <<4.17|5a:0>> could look like after it\x{2019}s initialized with some values.",
          ],
          [
            1,
            '[ap 04:17] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.17',
            'The slice in listing <<4.17|5a:0>> has access to three elements, but the underlying array has five elements. The two elements not associated with the length
         of the slice can be incorporated so the slice can use those elements as well. New slices can also be created to share this
         same underlying array and use any existing capacity.',
          ],
          [
            1,
            '[ap 04:18] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.18',
            "Listing <<4.18|5a:0>>. Compiler error setting capacity less than length
      
      // Create a slice of integers.
// Make the length larger than the capacity.
slice := make([]int, 5, 3)

Compiler Error:
len larger than cap in make([]int)
      
      An idiomatic way of creating a slice is to use a slice literal. It\x{2019}s similar to creating an array, except you don\x{2019}t specify
         a value inside of the [ ] operator. The initial length and capacity will be based on the number of elements you initialize.",
          ],
          [
            1,
            '[ap 04:19] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.19',
            'Listing <<4.19|5a:0>>. Declaring a slice with a slice literal
      
      // Create a slice of strings.
// Contains a length and capacity of 5 elements.
slice := []string{"Red", "Blue", "Green", "Yellow", "Pink"}

// Create a slice of integers.
// Contains a length and capacity of 3 elements.
slice := []int{10, 20, 30}
      
      When using a slice literal, you can set the initial length and capacity. All you need to do is initialize the index that represents
         the length and capacity you need. The following syntax will create a slice with a length and capacity of 100 elements.',
          ],
          [
            1,
            '[ap 04:20] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.20',
            "Listing <<4.20|5a:0>>. Declaring a slice with index positions
      
      // Create a slice of strings.
// Initialize the 100th element with an empty string.
slice := []string{99: \"\"}
      
      Remember, if you specify a value inside the [ ] operator, you\x{2019}re creating an array. If you don\x{2019}t specify a value, you\x{2019}re creating a slice.",
          ],
          [
            1,
            '[ap 04:21] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.21',
            'Listing <<4.21|5a:0>>. Declaration differences between arrays and slices
      
      // Create an array of three integers.
array := [3]int{10, 20, 30}

// Create a slice of integers with a length and capacity of three.
slice := []int{10, 20, 30}
      
      
      
      nil and empty slices
      
      
      Sometimes in your programs you may need to declare a nil slice. A nil slice is created by declaring a slice without any initialization.',
          ],
          [
            1,
            '[ap 04:22] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.22',
            "Listing <<4.22|5a:0>>. Declaring a nil slice
      
      // Create a nil slice of integers.
var slice []int
      
      A nil slice is the most common way you create slices in Go. They can be used with many of the standard library and built-in functions
         that work with slices. They\x{2019}re useful when you want to represent a slice that doesn\x{2019}t exist, such as when an exception occurs
         in a function that returns a slice (see figure 4.10).",
          ],
          [
            1,
            '[ap 04:23] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.23',
            'Listing <<4.23|5a:0>>. Declaring an empty slice
      
      // Use make to create an empty slice of integers.
slice := make([]int, 0)

// Use a slice literal to create an empty slice of integers.
slice := []int{}
      
      An empty slice contains a zero-element underlying array that allocates no storage. Empty slices are useful when you want to
         represent an empty collection, such as when a database query returns zero results (see figure 4.11).',
          ],
          [
            1,
            '[ap 04:24] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.24',
            'Listing <<4.24|5a:0>>. Declaring an array using an array literal
      
      // Create a slice of integers.
// Contains a length and capacity of 5 elements.
slice := []int{10, 20, 30, 40, 50}

// Change the value of index 1.
slice[1] = 25
      
      Slices are called such because you can slice a portion of the underlying array to create a new slice.',
          ],
          [
            1,
            '[ap 04:25] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.25',
            'Listing <<4.25|5a:0>>. Taking the slice of a slice
      
      // Create a slice of integers.
// Contains a length and capacity of 5 elements.
slice := []int{10, 20, 30, 40, 50}


// Create a new slice.
// Contains a length of 2 and capacity of 4 elements.
newSlice := slice[1:3]
      
      After the slicing operation performed in listing <<4.25|5a:0>>, we have two slices that are sharing the same underlying array. However, each slice views the underlying array in a different
         way (see figure 4.12).',
          ],
          [
            1,
            '[ap 04:26] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.26',
            'Listing <<4.26|5a:0>>. How length and capacity are calculated
      
      For slice[i:j] with an underlying array of capacity k

Length:   j - i
Capacity: k - i
      
      If you apply this formula to newSlice you get the following.',
          ],
          [
            1,
            '[ap 04:27] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.27',
            "Listing <<4.27|5a:0>>. Calculating the new length and capacity
      
      For slice[1:3] with an underlying array of capacity 5

Length:   3 - 1 = 2
Capacity: 5 - 1 = 4
      
      Another way to look at this is that the first value represents the starting index position of the element the new slice will
         start with\x{2014}in this case, 1. The second value represents the starting index position (1) plus the number of elements you want
         to include (2); 1 plus 2 is 3, so the second value is 3. Capacity will be the total number of elements associated with the
         slice.",
          ],
          [
            1,
            '[ap 04:28] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.28',
            'Listing <<4.28|5a:0>>. Potential consequence of making changes to a slice
      
      // Create a slice of integers.
// Contains a length and capacity of 5 elements.
slice := []int{10, 20, 30, 40, 50}

// Create a new slice.
// Contains a length of 2 and capacity of 4 elements.
newSlice := slice[1:3]

// Change index 1 of newSlice.
// Change index 2 of the original slice.
newSlice[1] = 35
      
      After the number 35 is assigned to the second element of newSlice, that change can also be seen by the original slice in element 3 (see figure 4.13).',
          ],
          [
            1,
            '[ap 04:29] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.29',
            "Listing <<4.29|5a:0>>. Runtime error showing index out of range
      
      // Create a slice of integers.
// Contains a length and capacity of 5 elements.
slice := []int{10, 20, 30, 40, 50}

// Create a new slice.
// Contains a length of 2 and capacity of 4 elements.
newSlice := slice[1:3]

// Change index 3 of newSlice.
// This element does not exist for newSlice.
newSlice[3] = 45

Runtime Exception:
panic: runtime error: index out of range
      
      Having capacity is great, but useless if you can\x{2019}t incorporate it into your slice\x{2019}s length. Luckily, Go makes this easy when
         you use the built-in function append.",
          ],
          [
            1,
            '[ap 04:30] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.30',
            'Listing <<4.30|5a:0>>. Using append to add an element to a slice
      
      // Create a slice of integers.
// Contains a length and capacity of 5 elements.
slice := []int{10, 20, 30, 40, 50}

// Create a new slice.
// Contains a length of 2 and capacity of 4 elements.
newSlice := slice[1:3]

// Allocate a new element from capacity.
// Assign the value of 60 to the new element.
newSlice = append(newSlice, 60)
      
      After the append operation in listing <<4.30|5a:0>>, the slices and the underlying array will look like figure 4.14.',
          ],
          [
            1,
            '[ap 04:31] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.31',
            'Listing <<4.31|5a:0>>. Using append to increase the length and capacity of a slice
      
      // Create a slice of integers.
// Contains a length and capacity of 4 elements.
slice := []int{10, 20, 30, 40}

// Append a new value to the slice.
// Assign the value of 50 to the new element.
newSlice := append(slice, 50)
      
      After this append operation, newSlice is given its own underlying array, and the capacity of the array is doubled from its original size (see figure 4.15).',
          ],
          [
            1,
            '[ap 01:25] Go in Action - William Kennedy.epub (kindle_split_012.html) - 1.25',
            'The append operation is clever when growing the capacity of the underlying array. Capacity is always doubled when the existing capacity
         of the slice is under 1,000 elements. Once the number of elements goes over 1,000, the capacity is grown by a factor of <<1.25|5a:0>>,
         or 25%. This growth algorithm may change in the language over time.',
          ],
          [
            1,
            '[ap 04:32] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.32',
            'Listing <<4.32|5a:0>>. Declaring a slice of string using a slice literal
      
      // Create a slice of strings.
// Contains a length and capacity of 5 elements.
source := []string{"Apple", "Orange", "Plum", "Banana", "Grape"}
      
      If you inspect the values for this slice of fruit, it will look something like figure 4.16.',
          ],
          [
            1,
            '[ap 04:33] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.33',
            'Listing <<4.33|5a:0>>. Performing a three-index slice
      
      // Slice the third element and restrict the capacity.
// Contains a length of 1 element and capacity of 2 elements.
slice := source[2:3:4]
      
      After this slicing operation, we have a new slice that references one element from the underlying array and has a capacity
         of two elements. Specifically, the new slice references the Plum element and has capacity up to the Banana element, as shown in figure 4.17.',
          ],
          [
            1,
            '[ap 04:34] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.34',
            "Listing <<4.34|5a:0>>. How length and capacity are calculated
      
      For slice[i:j:k]  or  [2:3:4]

Length:   j - i  or  3 - 2 = 1
Capacity: k - i  or  4 - 2 = 2
      
      Again, the first value represents the starting index position of the element the new slice will start with\x{2014}in this case, 2.
         The second value represents the starting index position (2) plus the number of elements you want to include (1); 2 plus 1
         is 3, so the second value is 3. For setting capacity, you take the starting index position of 2, plus the number of elements
         you want to include in the capacity (2), and you get the value of 4.",
          ],
          [
            1,
            '[ap 04:35] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.35',
            "Listing <<4.35|5a:0>>. Runtime error setting capacity larger than existing capacity
      
      // This slicing operation attempts to set the capacity to 4.
// This is greater than what is available.
slice := source[2:3:6]

Runtime Error:
panic: runtime error: slice bounds out of range
      
      As we\x{2019}ve discussed, the built-in function append will use any available capacity first. Once that capacity is reached, it
         will allocate a new underlying array. It\x{2019}s easy to forget which slices are sharing the same underlying array. When this happens,
         making changes to a slice can result in random and odd-looking bugs. Suddenly changes appear on multiple slices out of nowhere.",
          ],
          [
            1,
            '[ap 04:36] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.36',
            "Listing <<4.36|5a:0>>. Benefits of setting length and capacity to be the same
      
      // Create a slice of strings.
// Contains a length and capacity of 5 elements.
source := []string{\"Apple\", \"Orange\", \"Plum\", \"Banana\", \"Grape\"}

// Slice the third element and restrict the capacity.
// Contains a length and capacity of 1 element.
slice := source[2:3:3]

// Append a new string to the slice.
slice = append(slice, \"Kiwi\")
      
      Without this third index, appending Kiwi to our slice would\x{2019}ve changed the value of Banana in index 3 of the underlying array, because all of the remaining capacity would still belong to the slice. But in listing <<4.36|5a:0>>, we restricted the capacity of the slice to 1. When we call append for the first time on the slice, it will create a new underlying array of two elements, copy the fruit Plum, add the new fruit Kiwi, and return a new slice that references this underlying array, as in figure 4.18.",
          ],
          [
            1,
            '[ap 04:37] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.37',
            'Listing <<4.37|5a:0>>. Appending to a slice from another slice
      
      // Create two slices each initialized with two integers.
s1 := []int{1, 2}
s2 := []int{3, 4}

// Append the two slices together and display the results.
fmt.Printf("%v\\n", append(s1, s2...))

Output:
[1 2 3 4]
      
      As you can see by the output, all the values of slice s2 have been appended to slice s1. The value of the new slice returned by the append function is then displayed by the call to Printf.',
          ],
          [
            1,
            '[ap 04:38] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.38',
            'Listing <<4.38|5a:0>>. Iterating over a slice using for range
      // Create a slice of integers.
// Contains a length and capacity of 4 elements.
slice := []int{10, 20, 30, 40}

// Iterate over each element and display each value.
for index, value := range slice {
  fmt.Printf("Index: %d  Value: %d\\n", index, value)
}


Output:
Index: 0  Value: 10
Index: 1  Value: 20
Index: 2  Value: 30
Index: 3  Value: 40
      
      The keyword range, when iterating over a slice, will return two values. The first value is the index position and the second value is a copy
         of the value in that index position (see figure 4.19).',
          ],
          [
            1,
            '[ap 04:39] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.39',
            "Listing <<4.39|5a:0>>. range provides a copy of each element
      
      // Create a slice of integers.
// Contains a length and capacity of 4 elements.
slice := []int{10, 20, 30, 40}

// Iterate over each element and display the value and addresses.
for index, value := range slice {
   fmt.Printf(\"Value: %d  Value-Addr: %X  ElemAddr: %X\\n\",
       value, &value, &slice[index])
}

Output:
Value: 10  Value-Addr: 10500168  ElemAddr: 1052E100
Value: 20  Value-Addr: 10500168  ElemAddr: 1052E104
Value: 30  Value-Addr: 10500168  ElemAddr: 1052E108
Value: 40  Value-Addr: 10500168  ElemAddr: 1052E10C
      
      The address for the value variable is always the same because it\x{2019}s a variable that contains a copy. The address of each individual element can be captured
         using the slice variable and the index value.",
          ],
          [
            1,
            '[ap 04:40] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.40',
            'Listing <<4.40|5a:0>>. Using the blank identifier to ignore the index value
      
      // Create a slice of integers.
// Contains a length and capacity of 4 elements.
slice := []int{10, 20, 30, 40}

// Iterate over each element and display each value.
for _, value := range slice {
    fmt.Printf("Value: %d\\n", value)
}

Output:
Value: 10
Value: 20
Value: 30
Value: 40
      
      The keyword range will always start iterating over a slice from the beginning. If you need more control iterating over a slice, you can always
         use a traditional for loop.',
          ],
          [
            1,
            '[ap 04:41] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.41',
            'Listing <<4.41|5a:1>>. Iterating over a slice using a traditional for loop
      
      // Create a slice of integers.
// Contains a length and capacity of 4 elements.
slice := []int{10, 20, 30, 40}

// Iterate over each element starting at element 3.
for index := 2; index < len(slice); index++ {
    fmt.Printf("Index: %d  Value: %d\\n", index, slice[index])
}

Output:
Index: 2  Value: 30
Index: 3  Value: 40
      
      There are two special built-in functions called len and cap that work with arrays, slices, and channels. For slices, the len function returns the length of the slice, and the cap function returns the capacity. In listing <<4.41|5a:1>>, we used the len function to determine when to stop iterating over the slice.',
          ],
          [
            1,
            '[ap 04:42] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.42',
            'Listing <<4.42|5a:0>>. Declaring a multidimensional slice
      
      // Create a slice of a slice of integers.
slice := [][]int{{10}, {100, 200}}
      
      We now have an outer slice of two elements that contain an inner slice of integers. The values for our slice of a slice of
         integers will look like figure 4.20.',
          ],
          [
            1,
            '[ap 04:43] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.43',
            'Listing <<4.43|5a:0>>. Composing slices of slices
      
      // Create a slice of a slice of integers.
slice := [][]int{{10}, {100, 200}}

// Append the value of 20 to the first slice of integers.
slice[0] = append(slice[0], 20)
      
      The append function and Go are elegant in how they handle growing and assigning the new slice of integers back into the first element
         of the outer slice. When the operation in listing <<4.43|5a:0>> is complete, an entire new slice of integers and a new underlying array is allocated and then copied back into index 0 of
         the outer slice, as shown in figure 4.21.',
          ],
          [
            1,
            '[ap 04:44] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.44',
            'Listing <<4.44|5a:0>>. Passing slices between functions
      
      // Allocate a slice of 1 million integers.
slice := make([]int, 1e6)

// Pass the slice to the function foo.
slice = foo(slice)

// Function foo accepts a slice of integers and returns the slice back.
func foo(slice []int) []int {
    ...
    return slice
}
      
      On a 64-bit architecture, a slice requires 24 bytes of memory. The pointer field requires 8 bytes, and the length and capacity
         fields require 8 bytes respectively. Since the data associated with a slice is contained in the underlying array, there are
         no problems passing a copy of a slice to any function. Only the slice is being copied, not the underlying array (see figure 4.22).',
          ],
          [
            1,
            '[ap 04:45] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.45',
            'Listing <<4.45|5a:0>>. Declaring a map using make
      // Create a map with a key of type string and a value of type int.
dict := make(map[string]int)

// Create a map with a key and value of type string.
// Initialize the map with 2 key/value pairs.
dict := map[string]string{"Red": "#da1337", "Orange": "#e95a22"}
      
      Using a map literal is the idiomatic way of creating a map. The initial length will be based on the number of key/value pairs
         you specify during initialization.',
          ],
          [
            1,
            '[ap 04:46] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.46',
            "Listing <<4.46|5a:0>>. Declaring an empty map using a map literal
      
      // Create a map using a slice of strings as the key.
dict := map[[]string]int{}

Compiler Exception:
invalid map key type []string
      
      There\x{2019}s nothing stopping you from using a slice as a map value. This can come in handy when you need a single map key to be
         associated with a collection of data.",
          ],
          [
            1,
            '[ap 04:47] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.47',
            'Listing <<4.47|5a:0>>. Declaring a map that stores slices of strings
      
      // Create a map using a slice of strings as the value.
dict := map[int][]string{}
      
      
      
      4.3.3. Working with maps
      
      
      Assigning a key/value pair to a map is performed by specifying a key of the proper type and assigning a value to that key.',
          ],
          [
            1,
            '[ap 04:48] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.48',
            "Listing <<4.48|5a:0>>. Assigning values to a map
      
      // Create an empty map to store colors and their color codes.
colors := map[string]string{}

// Add the Red color code to the map.
colors[\"Red\"] = \"#da1337\"
      
      You can create a nil map by declaring a map without any initialization. A nil map can\x{2019}t be used to store key/value pairs. Trying will produce a runtime error.",
          ],
          [
            1,
            '[ap 04:49] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.49',
            "Listing <<4.49|5a:0>>. Runtime error assigned to a nil map
      
      // Create a nil map by just declaring the map.
var colors map[string]string

// Add the Red color code to the map.
colors[\"Red\"] = \"#da1337\"

Runtime Error:
panic: runtime error: assignment to entry in nil map
      
      Testing if a map key exists is an important part of working with maps. It allows you to write logic that can determine if
         you\x{2019}ve performed an operation or if you\x{2019}ve cached some particular data in the map. It can also be used to compare two maps
         to identify what key/value pairs match or are missing.",
          ],
          [
            1,
            '[ap 04:50] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.50',
            'Listing <<4.50|5a:0>>. Retrieving a value from a map and testing existence.
      
      // Retrieve the value for the key "Blue".
value, exists := colors["Blue"]

// Did this key exist?
if exists {
    fmt.Println(value)
}
      
      The other option is to just return the value and test for the zero value to determine if the key exists. This will only work
         if the zero value is not a valid value for the map.',
          ],
          [
            1,
            '[ap 04:51] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.51',
            "Listing <<4.51|5a:0>>. Retrieving a value from a map testing the value for existence
      
      // Retrieve the value for the key \"Blue\".
value := colors[\"Blue\"]

// Did this key exist?
if value != \"\" {
    fmt.Println(value)
}
      
      When you index a map in Go, it will always return a value, even when the key doesn\x{2019}t exist. In this case, the zero value for
         the value\x{2019}s type is returned.",
          ],
          [
            1,
            '[ap 04:52] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.52',
            'Listing <<4.52|5a:0>>. Iterating over a map using for range
      
      // Create a map of colors and color hex codes.
colors := map[string]string{
    "AliceBlue":   "#f0f8ff",
    "Coral":       "#ff7F50",
    "DarkGray":    "#a9a9a9",
    "ForestGreen": "#228b22",
}

// Display all the colors in the map.
for key, value := range colors {
    fmt.Printf("Key: %s  Value: %s\\n", key, value)
}
      
      If you want to remove a key/value pair from the map, you use the built-in function delete.',
          ],
          [
            1,
            '[ap 04:53] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.53',
            'Listing <<4.53|5a:0>>. Removing an item from a map
      
      // Remove the key/value pair for the key "Coral".
delete(colors, "Coral")

// Display all the colors in the map.

for key, value := range colors {
    fmt.Printf("Key: %s  Value: %s\\n", key, value)
}
      
      This time when you iterate through the map, the color Coral would not be displayed on the screen.',
          ],
          [
            1,
            '[ap 04:54] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.54',
            "Listing <<4.54|5a:0>>. Passing maps between functions
      
      func main() {
    // Create a map of colors and color hex codes.
    colors := map[string]string{
       \"AliceBlue\":   \"#f0f8ff\",
       \"Coral\":       \"#ff7F50\",
       \"DarkGray\":    \"#a9a9a9\",
       \"ForestGreen\": \"#228b22\",
    }

    // Display all the colors in the map.
    for key, value := range colors {
        fmt.Printf(\"Key: %s  Value: %s\\n\", key, value)
    }

    // Call the function to remove the specified key.
    removeColor(colors, \"Coral\")

    // Display all the colors in the map.
    for key, value := range colors {
        fmt.Printf(\"Key: %s  Value: %s\\n\", key, value)
    }
}

// removeColor removes keys from the specified map.
func removeColor(colors map[string]string, key string) {
    delete(colors, key)
}
      
      If you run this program, you\x{2019}ll get the following output.",
          ],
          [
            1,
            '[ap 04:55] Go in Action - William Kennedy.epub (kindle_split_012.html) - 4.55',
            'Listing <<4.55|5a:0>>. Output for listing <<4.54|5a:0>>
      Key: AliceBlue Value: #F0F8FF
Key: Coral Value: #FF7F50
Key: DarkGray Value: #A9A9A9
Key: ForestGreen Value: #228B22

Key: AliceBlue Value: #F0F8FF
Key: DarkGray Value: #A9A9A9
Key: ForestGreen Value: #228B22
      
      You can see that after the call to removeColor is complete, the color Coral is no longer present in the map referenced by main. Maps are designed to be cheap, similar to slices.',
          ],
          [
            1,
            '[ap 05:10] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.10',
            "Listing <<5.10|5a:0>>. Actual compiler error
      
      prog.go:7: cannot use int64(1000) (type int64) as type Duration
           in assignment
      
      The compiler is clear as to what the problem is. Values of type int64 can\x{2019}t be used as values of type Duration. In other words, even though type int64 is the base type for Duration, Duration is still its own unique type. Values of two different types can\x{2019}t be assigned to each other, even if they\x{2019}re compatible.
         The compiler doesn\x{2019}t implicitly convert values of different types.",
          ],
          [
            1,
            '[ap 05:11] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.11',
            'Listing <<5.11|5a:0>>. listing11.go
      
      01 // Sample program to show how to declare methods and how the Go
02 // compiler supports them.
03 package main
04
05 import (
06     "fmt"
07 )
08
09 // user defines a user in the program.
10 type user struct {
11     name  string

12     email string
13 }
14
15 // notify implements a method with a value receiver.
16 func (u user) notify() {
17     fmt.Printf("Sending User Email To %s<%s>\\n",
18         u.name,
19         u.email)
20 }
21
22 // changeEmail implements a method with a pointer receiver.
23 func (u *user) changeEmail(email string) {
24     u.email = email
25 }
26
27 // main is the entry point for the application.
28 func main() {
29     // Values of type user can be used to call methods
30     // declared with a value receiver.
31     bill := user{"Bill", "bill@email.com"}
32     bill.notify()
33
34     // Pointers of type user can also be used to call methods
35     // declared with a value receiver.
36     lisa := &user{"Lisa", "lisa@email.com"}
37     lisa.notify()
38
39     // Values of type user can be used to call methods
40     // declared with a pointer receiver.
41     bill.changeEmail("bill@newdomain.com")
42     bill.notify()
43
44     // Pointers of type user can be used to call methods
45     // declared with a pointer receiver.
46     lisa.changeEmail("lisa@comcast.com")
47     lisa.notify()
48 }
      
      Lines 16 and 23 of listing <<5.11|5a:0>> show two different methods. The parameter between the keyword func and the function name is called a receiver and binds the function to the specified type. When a function has a receiver, that function is called a method. When you run the program, you get the following output.',
          ],
          [
            1,
            '[ap 05:12] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.12',
            "Listing <<5.12|5a:0>>. Output for listing11.go
      
      Sending User Email To Bill<bill\@email.com>
Sending User Email To Lisa<lisa\@email.com>
Sending User Email To Bill<bill\@newdomain.com>
Sending User Email To Lisa<lisa\@comcast.com>
      
      Let\x{2019}s examine what the program is doing. On line 10, the program declares a struct type named user and then declares a method named notify.",
          ],
          [
            1,
            '[ap 05:13] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.13',
            "Listing <<5.13|5a:0>>. listing11.go: lines 09\x{2013}20
      
      09 // user defines a user in the program.
10 type user struct {
11     name  string
12     email string
13 }
14
15 // notify implements a method with a value receiver.
16 func (u user) notify() {
17     fmt.Printf(\"Sending User Email To %s<%s>\\n\",
18         u.name,
19         u.email)
20 }
      
      There are two types of receivers in Go: value receivers and pointer receivers. In listing <<5.13|5a:0>> on line 16, the notify method is declared with a value receiver.",
          ],
          [
            1,
            '[ap 05:14] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.14',
            "Listing <<5.14|5a:0>>. Declaration of a method with a value receiver
      
      func (u user) notify() {
      
      The receiver for notify is declared as a value of type user. When you declare a method using a value receiver, the method will always be operating against a copy of the value used to
         make the method call. Let\x{2019}s skip to line 32 of the program in listing <<5.11|5a:0>> to see a method call on notify.",
          ],
          [
            1,
            '[ap 05:15] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.15',
            "Listing <<5.15|5a:0>>. listing11.go: lines 29\x{2013}32
      
      29     // Values of type user can be used to call methods
30     // declared with a value receiver.
31     bill := user{\"Bill\", \"bill\@email.com\"}
32     bill.notify()
      
      Listing <<5.15|5a:0>> shows a call to the notify method using a value of type user. On line 31, a variable named bill of type user is declared and initialized with a name and email address. Then on line 32, the notify method is called using the variable bill.",
          ],
          [
            1,
            '[ap 05:16] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.16',
            'Listing <<5.16|5a:0>>. Calling a method from a variable
      
      bill.notify()
      
      The syntax looks similar to when you call a function from a package. In this case however, bill is not a package name but a variable name. When we call the notify method in this case, the value of bill is the receiver value for the call and the notify method is operating on a copy of this value.',
          ],
          [
            1,
            '[ap 05:17] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.17',
            "Listing <<5.17|5a:0>>. listing11.go: lines 34\x{2013}37
      
      34     // Pointers of type user can also be used to call methods
35     // declared with a value receiver.
36     lisa := &user{\"Lisa\", \"lisa\@email.com\"}
37     lisa.notify()
      
      Listing <<5.17|5a:0>> shows a call to the notify method using a pointer of type user. On line 36, a variable named lisa of pointer type user is declared and initialized with a name and email address. Then on line 37, the notify method is called using the pointer variable. To support the method call, Go adjusts the pointer value to comply with the
         method\x{2019}s receiver. You can imagine that Go is performing the following operation.",
          ],
          [
            1,
            '[ap 05:18] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.18',
            'Listing <<5.18|5a:0>>. What Go is doing underneath the code
      
      (*lisa).notify()
      
      Listing <<5.18|5a:0>> shows essentially what the Go compiler is doing to support the method call. The pointer value is dereferenced so the method
         call is in compliance with the value receiver. Once again, notify is operating against a copy, but this time a copy of the value that the lisa pointer points to.',
          ],
          [
            1,
            '[ap 05:19] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.19',
            "Listing <<5.19|5a:0>>. listing11.go: lines 22\x{2013}25
      
      22 // changeEmail implements a method with a pointer receiver.
23 func (u *user) changeEmail(email string) {
24     u.email = email
25 }
      
      Listing <<5.19|5a:0>> shows the declaration of the changeEmail method, which is declared with a pointer receiver. This time, the receiver is not a value of type user but a pointer of type user. When you call a method declared with a pointer receiver, the value used to make the call is shared with the method.",
          ],
          [
            1,
            '[ap 05:20] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.20',
            "Listing <<5.20|5a:0>>. listing11.go: lines 36, 44\x{2013}46
      
      36     lisa := &user{\"Lisa\", \"lisa\@email.com\"}

44     // Pointers of type user can be used to call methods
45     // declared with a pointer receiver.
46     lisa.changeEmail(\"lisa\@newdomain.com\")
      
      In listing <<5.20|5a:0>> you see the declaration of the lisa pointer variable followed by the method call to changeEmail on line 46. Once the call to changeEmail returns, any changes to the value that the lisa pointer points to will be reflected after the call. This is thanks to the pointer receiver. Value receivers operate on a
         copy of the value used to make the method call and pointer receivers operate on the actual value.",
          ],
          [
            1,
            '[ap 05:21] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.21',
            "Listing <<5.21|5a:0>>. listing11.go: line 31
      
      31     bill := user{\"Bill\", \"bill\@email.com\"}

39     // Values of type user can be used to call methods
40     // declared with a pointer receiver.
41     bill.changeEmail(\"bill\@newdomain.com\")
      
      In listing <<5.21|5a:0>>, you see the declaration of the variable bill and then a call to the changeEmail method, which is declared with a pointer receiver. Once again, Go adjusts the value to comply with the method\x{2019}s receiver
         to support the call.",
          ],
          [
            1,
            '[ap 05:22] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.22',
            "Listing <<5.22|5a:0>>. What Go is doing underneath the code
      
      (&bill).notify()
      
      Listing <<5.22|5a:0>> shows essentially what the Go compiler is doing to support the method call. In this case, the value is referenced so the
         method call is in compliance with the receiver type. This is a great convenience Go provides, allowing method calls with values
         and pointers that don\x{2019}t match a method\x{2019}s receiver type natively.",
          ],
          [
            1,
            '[ap 05:23] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.23',
            "Listing <<5.23|5a:0>>. golang.org/src/strings/strings.go: lines 620\x{2013}625
      
      620 func Trim(s string, cutset string) string {
621     if s == \"\" || cutset == \"\" {
622         return s
623     }
624     return TrimFunc(s, makeCutsetFunc(cutset))
625 }
      
      In listing <<5.23|5a:0>>, you see the Trim function, which comes from the strings package in the standard library. The Trim function is passed a string value to operate on and a string value with characters to find. It then returns a new string
         value that\x{2019}s the result of the operation. The function operates on copies of the caller\x{2019}s original string values and returns
         a copy of the new string value. Strings, just like integers, floats, and Booleans, are primitive data values and should be
         copied when passed in and out of functions or methods.",
          ],
          [
            1,
            '[ap 05:24] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.24',
            "Listing <<5.24|5a:0>>. golang.org/src/os/env.go: lines 38\x{2013}44
      
      38 func isShellSpecialVar(c uint8) bool {
39     switch c {
40     case '*', '#', '\$', '\@', '!', '?', '0', '1', '2', '3', '4', '5',
                                                     '6', '7', '8', '9':
41         return true
42     }
43     return false
44 }
      
      Listing <<5.24|5a:0>> shows the isShellSpecialVar function from the env package. This function is passed a value of type uint8 and returns a value of type bool. Note how pointers aren\x{2019}t being used to share the value for the parameter or return value. The caller passes a copy of their
         uint8 value and receives a value of true or false.",
          ],
          [
            1,
            '[ap 05:25] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.25',
            'Listing <<5.25|5a:0>>. golang.org/src/net/ip.go: line 32
      
      32 type IP []byte
      
      Listing <<5.25|5a:0>> shows a type called IP which is declared as a slice of bytes. Declaring a type like this is useful when you want to declare behavior around a built-in
         or reference type. The compiler will only let you declare methods for user-defined types that are named.',
          ],
          [
            1,
            '[ap 05:26] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.26',
            "Listing <<5.26|5a:0>>. golang.org/src/net/ip.go: lines 329\x{2013}337
      
      329 func (ip IP) MarshalText() ([]byte, error) {
330     if len(ip) == 0 {
331         return []byte(\"\"), nil
332     }
333     if len(ip) != IPv4len && len(ip) != IPv6len {
334         return nil, errors.New(\"invalid IP address\")
335     }
336     return []byte(ip.String()), nil
337 }
      
      The MarshalText method in listing <<5.26|5a:0>> has been declared using a value receiver of type IP. A value receiver is exactly what you expect to see since you don\x{2019}t share reference type values. This also applies to passing
         reference type values as parameters to functions and methods.",
          ],
          [
            1,
            '[ap 05:27] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.27',
            "Listing <<5.27|5a:0>>. golang.org/src/net/ip.go: lines 318\x{2013}325
      
      318 // ipEmptyString is like ip.String except that it returns
319 // an empty string when ip is unset.
320 func ipEmptyString(ip IP) string {
321     if len(ip) == 0 {
322         return \"\"
323     }
324     return ip.String()
325 }
      
      In listing <<5.27|5a:0>> you see the ipEmptyString function. This function is passed a value of the type IP. Once again, you can see how the caller\x{2019}s reference type value for this parameter is not shared with the function. The function
         is passed a copy of the caller\x{2019}s reference type value. This also applies to return values. In the end, reference type values
         are treated like primitive data values.",
          ],
          [
            1,
            '[ap 05:28] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.28',
            "Listing <<5.28|5a:1>>. golang.org/src/time/time.go: lines 39\x{2013}55
      
      39 type Time struct {
40     // sec gives the number of seconds elapsed since
41     // January 1, year 1 <<00:00|2>>:00 UTC.
42     sec int64
43
44     // nsec specifies a non-negative nanosecond
45     // offset within the second named by Seconds.
46     // It must be in the range [0, 999999999].
47     nsec int32
48
49     // loc specifies the Location that should be used to
50     // determine the minute, hour, month, day, and year
51     // that correspond to this Time.
52     // Only the zero Time has a nil Location.
53     // In that case it is interpreted to mean UTC.
54     loc *Location
55 }
      
      The Time struct in listing <<5.28|5a:1>> comes from the time package. When you think about time, you realize that any given point in time is not something that can change. This is exactly
         how the standard library implements the Time type. Let\x{2019}s look at the Now function that creates values of type Time.",
          ],
          [
            1,
            '[ap 05:29] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.29',
            "Listing <<5.29|5a:0>>. golang.org/src/time/time.go: lines 781\x{2013}784
      
      781 func Now() Time {
782     sec, nsec := now()
783     return Time{sec + unixToInternal, nsec, Local}
784 }
      
      The code in listing <<5.29|5a:0>> shows the implementation of the Now function. This function creates a value of type Time and returns a copy of that Time value back to the caller. A pointer is not used to share the Time value created by the function. Next, let\x{2019}s look at a method declared against the Time type.",
          ],
          [
            1,
            '[ap 05:30] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.30',
            "Listing <<5.30|5a:0>>. golang.org/src/time/time.go: lines 610\x{2013}622
      
      610 func (t Time) Add(d Duration) Time {
611     t.sec += int64(d / 1e9)
612     nsec := int32(t.nsec) + int32(d%1e9)
613     if nsec >= 1e9 {
614         t.sec++
615         nsec -= 1e9
616     } else if nsec < 0 {
617         t.sec--
618         nsec += 1e9
619     }
620     t.nsec = nsec
621     return t
622 }
      
      The method Add in listing <<5.30|5a:0>> is a great example of how the standard library treats the Time type as having a primitive nature. The method is declared using a value receiver and returns a new Time value. The method is operating on its own copy of the caller\x{2019}s Time value and returns a copy of its local Time value back to the caller. It\x{2019}s up to the caller whether they want to replace their Time value with what\x{2019}s returned or declare a new Time variable to hold the result.",
          ],
          [
            1,
            '[ap 05:31] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.31',
            "Listing <<5.31|5a:0>>. golang.org/src/os/file_unix.go: lines 15\x{2013}29
      
      15 // File represents an open file descriptor.
16 type File struct {
17     *file
18 }
19
20 // file is the real representation of *File.
21 // The extra level of indirection ensures that no clients of os
22 // can overwrite this data, which could cause the finalizer
23 // to close the wrong file descriptor.
24 type file struct {
25     fd int
26     name string
27     dirinfo *dirInfo // nil unless directory being read
28     nepipe int32 // number of consecutive EPIPE in Write
29 }
      
      In listing <<5.31|5a:0>> you see the declaration of the File type from the standard library. The nature of this type is nonprimitive. Values of this type are actually unsafe to be copied.
         The comments for the unexported type make this clear. Since there\x{2019}s no way to prevent programmers from making copies, the
         implementation of the File type uses an embedded pointer of an unexported type. We\x{2019}ll talk about embedding types later in this chapter, but this extra
         level of indirection provides protection from copies. Not every struct type requires or should be implemented with this extra
         protection. Programmers should respect the nature of each type and use it accordingly.",
          ],
          [
            1,
            '[ap 05:32] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.32',
            "Listing <<5.32|5a:0>>. golang.org/src/os/file.go: lines 238\x{2013}240
      
      238 func Open(name string) (file *File, err error) {
239     return OpenFile(name, O_RDONLY, 0)
240 }
      
      The implementation of the Open function in listing <<5.32|5a:0>> shows how a pointer is used to share File type values with the caller of the function. Open creates a value of type File and returns a pointer to that value. When a factory function returns a pointer, it\x{2019}s a good indication that the nature of
         the value being returned is nonprimitive.",
          ],
          [
            1,
            '[ap 05:33] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.33',
            "Listing <<5.33|5a:0>>. golang.org/src/os/file.go: lines 224\x{2013}232
      
      224 func (f *File) Chdir() error {
225     if f == nil {
226         return ErrInvalid
227     }
228     if e := syscall.Fchdir(f.fd); e != nil {
229         return &PathError{\"chdir\", f.name, e}
230     }
231     return nil
232 }
      
      The Chdir method in listing <<5.33|5a:0>> shows how a pointer receiver is declared even though no changes are made to the receiver value. Since values of type File have a nonprimitive nature, they\x{2019}re always shared and never copied.",
          ],
          [
            1,
            '[ap 05:34] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.34',
            'Listing <<5.34|5a:0>>. listing34.go
      
      01 // Sample program to show how to write a simple version of curl using
02 // the io.Reader and io.Writer interface support.
03 package main
04
05 import (
06     "fmt"
07     "io"
08     "net/http"
09     "os"
10 )
11
12 // init is called before main.
13 func init() {
14     if len(os.Args) != 2 {
15         fmt.Println("Usage: ./example2 <url>")
16         os.Exit(-1)
17     }
18 }
19
20 // main is the entry point for the application.
21 func main() {
22     // Get a response from the web server.
23     r, err := http.Get(os.Args[1])
24     if err != nil {
25         fmt.Println(err)
26         return
27     }
28
29     // Copies from the Body to Stdout.
30     io.Copy(os.Stdout, r.Body)
31     if err := r.Body.Close(); err != nil {
32         fmt.Println(err)
33     }
34 }
      
      Listing <<5.34|5a:0>> shows the power of interfaces and their use in the standard library. In a few lines of code, we have a curl program by leveraging
         two functions that work with interface values. On line 23, we call the Get function from the http package. The http.Get function returns a pointer of type http.Request after it successfully communicates with the server. The http.Request type contains a field named Body, which is an interface value of type io.ReadCloser.',
          ],
          [
            1,
            '[ap 05:35] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.35',
            'Listing <<5.35|5a:0>>. listing35.go
      
      01 // Sample program to show how a bytes.Buffer can also be used
02 // with the io.Copy function.
03 package main
04
05 import (
06     "bytes"
07     "fmt"
08     "io"
09     "os"
10 )
11
12 // main is the entry point for the application.
13 func main() {
14     var b bytes.Buffer
15
16     // Write a string to the buffer.
17     b.Write([]byte("Hello"))
18
19     // Use Fprintf to concatenate a string to the Buffer.
20     fmt.Fprintf(&b, "World!")
21
22     // Write the content of the Buffer to stdout.
23     io.Copy(os.Stdout, &b)
24 }
      
      Listing <<5.35|5a:0>> shows a program that uses interfaces to concatenate and then stream data to standard out. On line 14, a variable of type
         Buffer from the bytes package is created, and then the Write method is used on line 17 to add the string Hello to the buffer. On line 20, the Fprintf function from the fmt package is called to append a second string to the buffer.',
          ],
          [
            1,
            '[ap 05:36] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.36',
            "Listing <<5.36|5a:0>>. listing36.go
      
      01 // Sample program to show how to use an interface in Go.
02 package main
03
04 import (
05     \"fmt\"
06 )
07
08 // notifier is an interface that defined notification
09 // type behavior.
10 type notifier interface {
11     notify()
12 }
13
14 // user defines a user in the program.
15 type user struct {
16     name  string
17     email string
18 }
19
20 // notify implements a method with a pointer receiver.
21 func (u *user) notify() {
22     fmt.Printf(\"Sending user email to %s<%s>\\n\",
23         u.name,
24         u.email)
25 }
26
27 // main is the entry point for the application.
28 func main() {
29     // Create a value of type User and send a notification.
30     u := user{\"Bill\", \"bill\@email.com\"}
31
32     sendNotification(u)
33

34     // ./listing36.go:32: cannot use u (type user) as type
35     //                     notifier in argument to sendNotification:
36     //   user does not implement notifier
37     //                          (notify method has pointer receiver)
38 }
39
40 // sendNotification accepts values that implement the notifier
41 // interface and sends notifications.
42 func sendNotification(n notifier) {
43     n.notify()
44 }
      
      In listing <<5.36|5a:0>> you see code that you would expect to compile, but it doesn\x{2019}t. On line 10, we declare an interface named notifier with a single method named notify. Then on line 15, we have the declaration of our concrete type named user and the implementation of the notifier interface via the method declaration on line 21. The method is implemented with a pointer receiver of type user.",
          ],
          [
            1,
            '[ap 05:37] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.37',
            "Listing <<5.37|5a:0>>. listing36.go: lines 40\x{2013}44
      
      40 // sendNotification accepts values that implement the notifier
41 // interface and sends notifications.
42 func sendNotification(n notifier) {
43     n.notify()
44 }
      
      On line 42 in listing <<5.37|5a:0>>, a function named sendNotification is declared and accepts a single value of the interface type notifier. Then the interface value is used to call the notify method against the stored value. Any value that implements the notifier interface can be passed into the sendNotification function. Now let\x{2019}s look at the main function.",
          ],
          [
            1,
            '[ap 05:38] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.38',
            "Listing <<5.38|5a:0>>. listing36.go: lines 28\x{2013}38
      
      28 func main() {
29     // Create a value of type User and send a notification.
30     u := user{\"Bill\", \"bill\@email.com\"}
31
32     sendNotification(u)
33
34     // ./listing36.go:32: cannot use u (type user) as type
35     //                     notifier in argument to sendNotification:
36     //   user does not implement notifier
37     //                          (notify method has pointer receiver)
38 }
      
      In the main function, a value of the concrete type user is created and assigned to the variable u on line 30 in listing <<5.38|5a:0>>. Then the value of u is passed to the send-Notification function on line 32. But the call to sendNotification results in a compiler error.",
          ],
          [
            1,
            '[ap 05:39] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.39',
            "Listing <<5.39|5a:0>>. Compiler error storing a value of type user to the interface value
      
      ./listing36.go:32: cannot use u (type user) as type
                   notifier in argument to sendNotification:
  user does not implement notifier (notify method has pointer receiver)
      
      So why do we receive a compiler error when the user type implements the notify method on line 21? Let\x{2019}s take a look at that code again.",
          ],
          [
            1,
            '[ap 05:40] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.40',
            "Listing <<5.40|5a:0>>. listing36.go: lines 08\x{2013}12, 21\x{2013}25
      
      08 // notifier is an interface that defined notification
09 // type behavior.
10 type notifier interface {
11     notify()
12 }

21 func (u *user) notify() {
22     fmt.Printf(\"Sending user email to %s<%s>\\n\",
23         u.name,
24         u.email)
25 }
      
      Listing <<5.40|5a:0>> shows how the interface has been implemented, yet the compiler tells us that a value of type user doesn\x{2019}t implement the interface. If you look closer at the compiler message, it actually tells us why.",
          ],
          [
            1,
            '[ap 05:41] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.41',
            "Listing <<5.41|5a:0>>. Closer look at compiler error
      
      (notify method has pointer receiver)
      
      To understand why values of type user don\x{2019}t implement the interface when an interface is implemented with a pointer receiver, you need to understand what method sets are. Method sets define the set of methods that are associated with values or pointers of a given type. The type of receiver
         used will determine whether a method is associated with a value, pointer, or both.",
          ],
          [
            1,
            '[ap 05:42] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.42',
            "Listing <<5.42|5a:0>>. Method sets as described by the specification
      
      Values                    Methods Receivers
-----------------------------------------------
    T                        (t T)
   *T                        (t T) and (t *T)
      
      Listing <<5.42|5a:0>> shows how the specification describes method sets. It says that a value of type T only has methods declared that have a value receiver, as part of its method set. But pointers of type T have methods declared with both value and pointer receivers, as part of its method set. Looking at these rules from the perspective
         of the value is confusing. Let\x{2019}s look at these rules from the perspective of the receiver.",
          ],
          [
            1,
            '[ap 05:43] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.43',
            'Listing <<5.43|5a:0>>. Method sets from the perspective of the receiver type
      
      Methods Receivers         Values
-----------------------------------------------
   (t T)                     T and *T
   (t *T)                    *T
      
      Listing <<5.43|5a:0>> shows the same rules, but from the perspective of the receiver. It says that if you implement an interface using a pointer
         receiver, then only pointers of that type implement the interface. If you implement an interface using a value receiver, then
         both values and pointers of that type implement the interface. If you look at the code in listing <<5.36|5a:0>> again, you now have the context to understand the compiler error.',
          ],
          [
            1,
            '[ap 05:44] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.44',
            "Listing <<5.44|5a:0>>. listing36.go: lines 28\x{2013}38
      
      28 func main() {
29     // Create a value of type User and send a notification.
30     u := user{\"Bill\", \"bill\@email.com\"}
31
32     sendNotification(u)
33
34     // ./listing36.go:32: cannot use u (type user) as type
35     //                     notifier in argument to sendNotification:
36     //   user does not implement notifier
37     //                          (notify method has pointer receiver)
38 }
      
      We implemented the interface using a pointer receiver and attempted to pass a value of type user to the sendNotification function. Lines 30 and 32 in listing <<5.44|5a:0>> show this clearly. But if we pass the address of the user value instead, you\x{2019}ll see that it now compiles and works.",
          ],
          [
            1,
            '[ap 05:45] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.45',
            "Listing <<5.45|5a:0>>. listing36.go: lines 28\x{2013}35
      
      28 func main() {
29     // Create a value of type User and send a notification.
30     u := user{\"Bill\", \"bill\@email.com\"}
31
32     sendNotification(&u)
33
34     // PASSED THE ADDRESS AND NO MORE ERROR.
35 }
      
      In listing <<5.45|5a:0>>, we now have a program that compiles and runs. Only pointers of type user can be passed to the sendNotification function, since a pointer receiver was used to implement the interface.",
          ],
          [
            1,
            '[ap 05:46] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.46',
            "Listing <<5.46|5a:0>>. listing46.go
      
      01 // Sample program to show how you can't always get the
02 // address of a value.
03 package main
04
05 import \"fmt\"
06
07 // duration is a type with a base type of int.
08 type duration int
09
10 // format pretty-prints the duration value.
11 func (d *duration) pretty() string {
12     return fmt.Sprintf(\"Duration: %d\", *d)
13 }
14
15 // main is the entry point for the application.
16 func main() {
17     duration(42).pretty()
18
19     // ./listing46.go:17: cannot call pointer method on duration(42)
20     // ./listing46.go:17: cannot take the address of duration(42)
21 }
      
      The code in listing <<5.46|5a:0>> attempts to get the address of a value of type duration and can\x{2019}t. This shows that it\x{2019}s not always possible to get the address of a value. Let\x{2019}s look at the method set rules again.",
          ],
          [
            1,
            '[ap 05:47] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.47',
            "Listing <<5.47|5a:0>>. Second look at the method set rules
      
      Values                    Methods Receivers
-----------------------------------------------
    T                        (t T)
   *T                        (t T) and (t *T)

  Methods Receivers         Values
-----------------------------------------------
   (t T)                     T and *T
   (t *T)                    *T
      
      Because it\x{2019}s not always possible to get the address of a value, the method set for a value only includes methods that are
         implemented with a value receiver.",
          ],
          [
            1,
            '[ap 05:48] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.48',
            'Listing <<5.48|5a:0>>. listing48.go
      
      01 // Sample program to show how polymorphic behavior with interfaces.
02 package main
03
04 import (
05     "fmt"
06 )
07
08 // notifier is an interface that defines notification
09 // type behavior.
10 type notifier interface {
11     notify()
12 }
13
14 // user defines a user in the program.
15 type user struct {
16     name  string
17     email string
18 }
19
20 // notify implements the notifier interface with a pointer receiver.
21 func (u *user) notify() {
22     fmt.Printf("Sending user email to %s<%s>\\n",
23         u.name,
24         u.email)
25 }
26
27 // admin defines a admin in the program.
28 type admin struct {
29     name  string
30     email string
31 }
32
33 // notify implements the notifier interface with a pointer receiver.
34 func (a *admin) notify() {
35     fmt.Printf("Sending admin email to %s<%s>\\n",
36         a.name,
37         a.email)
38 }
39
40 // main is the entry point for the application.
41 func main() {
42     // Create a user value and pass it to sendNotification.
43     bill := user{"Bill", "bill@email.com"}
44     sendNotification(&bill)
45
46     // Create an admin value and pass it to sendNotification.
47     lisa := admin{"Lisa", "lisa@email.com"}
48     sendNotification(&lisa)
49 }
50
51 // sendNotification accepts values that implement the notifier
52 // interface and sends notifications.

53 func sendNotification(n notifier) {
54     n.notify()
55 }
      
      In listing <<5.48|5a:0>>, we have a final example of how interfaces provide polymorphic behavior. On line 10, we have the same notifier interface that we declared in previous listings. Then on lines 15 through 25, we have the declaration of a struct named user with the implementation of the notifier interface using a pointer receiver. On lines 28 through 38, we have the declaration of a struct named admin with the implementation of the notifier interface as well. We have two concrete types implementing the notifier interface.',
          ],
          [
            1,
            '[ap 05:49] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.49',
            "Listing <<5.49|5a:0>>. listing48.go: lines 40\x{2013}49
      
      40 // main is the entry point for the application.
41 func main() {
42     // Create a user value and pass it to sendNotification.
43     bill := user{\"Bill\", \"bill\@email.com\"}
44     sendNotification(&bill)
45
46     // Create an admin value and pass it to sendNotification.
47     lisa := admin{\"Lisa\", \"lisa\@email.com\"}
48     sendNotification(&lisa)
49 }
      
      Finally, in listing <<5.49|5a:0>> you see it all come together. A value of type user is created on line 43 in the main function, and then the address of that value is passed into send-Notification on line 44. This causes the notify method declared by the user type to be executed. Then we do the same with a value of type admin on lines 47 and 48. In the end, because sendNotification accepts interface values of type notifier, the function can execute the behavior implemented by both user and admin.",
          ],
          [
            1,
            '[ap 05:50] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.50',
            'Listing <<5.50|5a:0>>. listing50.go
      
      01 // Sample program to show how to embed a type into another type and
02 // the relationship between the inner and outer type.
03 package main
04
05 import (
06     "fmt"
07 )
08
09 // user defines a user in the program.
10 type user struct {
11     name  string
12     email string
13 }
14
15 // notify implements a method that can be called via
16 // a value of type user.
17 func (u *user) notify() {
18     fmt.Printf("Sending user email to %s<%s>\\n",
19     u.name,
20     u.email)
21 }
22
23 // admin represents an admin user with privileges.
24 type admin struct {
25     user  // Embedded Type
26     level string
27 }
28
29 // main is the entry point for the application.
30 func main() {
31     // Create an admin user.
32     ad := admin{
33         user: user{
34             name:  "john smith",
35             email: "john@yahoo.com",
36         },
37         level: "super",
38     }
39
40     // We can access the inner type\'s method directly.
41     ad.user.notify()
42
43     // The inner type\'s method is promoted.
44     ad.notify()
45 }
      
      In listing <<5.50|5a:0>>, we have a program that shows how to embed a type and access the embedded identifiers. We start with the declaration of two
         struct types on lines 10 and 24.',
          ],
          [
            1,
            '[ap 05:51] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.51',
            "Listing <<5.51|5a:0>>. listing50.go: lines 09\x{2013}13, 23\x{2013}27
      
      09 // user defines a user in the program.
10 type user struct {
11     name  string
12     email string
13 }

23 // admin represents an admin user with privileges.
24 type admin struct {
25     user  // Embedded Type
26     level string
27 }
      
      On line 10 in listing <<5.51|5a:0>>, we have the declaration of a struct type named user, and then on line 24 we have the declaration of a second struct type named admin. Inside the declaration of the admin type on line 25, we have the embedding of the user type as an inner type of admin. To embed a type, all that needs to happen is for the type name to be declared. One line 26, we have the declaration of a
         field named level. Notice the difference between declaring a field and embedding a type.",
          ],
          [
            1,
            '[ap 05:52] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.52',
            "Listing <<5.52|5a:0>>. listing50.go: lines 15\x{2013}21
      
      15 // notify implements a method that can be called via
16 // a value of type user.
17 func (u *user) notify() {
18     fmt.Printf(\"Sending user email to %s<%s>\\n\",
19     u.name,
20     u.email)
21 }
      
      Listing <<5.52|5a:0>> shows the declaration of a method named notify using a pointer receiver of type user. The method just displays a friendly message stating an email is being sent to a specific user and email address. Now let\x{2019}s
         look at the main function.",
          ],
          [
            1,
            '[ap 05:53] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.53',
            "Listing <<5.53|5a:0>>. listing50.go: lines 30\x{2013}45
      
      30 func main() {
31     // Create an admin user.
32     ad := admin{
33         user: user{
34             name:  \"john smith\",
35             email: \"john\@yahoo.com\",
36         },

37         level: \"super\",
38     }
39
40     // We can access the inner type's method directly.
41     ad.user.notify()
42
43     // The inner type's method is promoted.
44     ad.notify()
45 }
      
      The main function in listing <<5.53|5a:0>> shows the mechanics behind type embedding. On line 32, a value of type admin is created. The initialization of the inner type is performed using a struct literal, and to access the inner type we just
         need to use the type\x{2019}s name. Something special about an inner type is that it always exists in and of itself. This means the
         inner type never loses its identity and can always be accessed directly.",
          ],
          [
            1,
            '[ap 05:54] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.54',
            "Listing <<5.54|5a:0>>. listing50.go: lines 40\x{2013}41
      
      40     // We can access the inner type's method directly.
41     ad.user.notify()
      
      On line 41 in listing <<5.54|5a:0>>, you see a call to the notify method. This call is made by accessing the user inner type directly through the admin outer type variable ad. This shows how the inner type exists in and of itself and is always accessible. But thanks to inner type promotion, the
         notify method can also be accessed directly from the ad variable.",
          ],
          [
            1,
            '[ap 05:55] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.55',
            "Listing <<5.55|5a:0>>. listing50.go: lines 43\x{2013}45
      
      43     // The inner type's method is promoted.
44     ad.notify()
45 }
      
      Listing <<5.55|5a:0>> on line 44 shows the method call to notify from the outer type variable. Since the identifiers of the inner type are promoted up to the outer type, we can access the
         inner type\x{2019}s identifiers through values of the outer type. Let\x{2019}s change the sample by adding an interface.",
          ],
          [
            1,
            '[ap 05:56] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.56',
            'Listing <<5.56|5a:0>>. listing56.go
      
      01 // Sample program to show how embedded types work with interfaces.
02 package main
03
04 import (
05     "fmt"
06 )
07
08 // notifier is an interface that defined notification
09 // type behavior.
10 type notifier interface {
11     notify()

12 }
13
14 // user defines a user in the program.
15 type user struct {
16     name  string
17     email string
18 }
19
20 // notify implements a method that can be called via
21 // a value of type user.
22 func (u *user) notify() {
23     fmt.Printf("Sending user email to %s<%s>\\n",
24     u.name,
25     u.email)
26 }
27
28 // admin represents an admin user with privileges.
29 type admin struct {
30     user
31     level string
32 }
33
34 // main is the entry point for the application.
35 func main() {
36     // Create an admin user.
37     ad := admin{
38         user: user{
39             name:  "john smith",
40             email: "john@yahoo.com",
41         },
42         level: "super",
43     }
44
45     // Send the admin user a notification.
46     // The embedded inner type\'s implementation of the
47     // interface is "promoted" to the outer type.
48     sendNotification(&ad)
49 }
50
51 // sendNotification accepts values that implement the notifier
52 // interface and sends notifications.
53 func sendNotification(n notifier) {
54     n.notify()
55 }
      
      The sample code in listing <<5.56|5a:0>> uses the same code from before but with a few changes.',
          ],
          [
            1,
            '[ap 05:57] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.57',
            "Listing <<5.57|5a:0>>. listing56.go: lines 08\x{2013}12, 51\x{2013}55
      
      08 // notifier is an interface that defined notification
09 // type behavior.
10 type notifier interface {
11     notify()
12 }

51 // sendNotification accepts values that implement the notifier
52 // interface and sends notifications.
53 func sendNotification(n notifier) {
54     n.notify()
55 }
      
      On line 08 in listing <<5.57|5a:0>>, we have the declaration of the notifier interface. Then on line 53, we have the sendNotification function that accepts an interface value of type notifier. We know from the code before that the user type has declared a method named notify that implements the notifier interface with a pointer receiver. Therefore, we can move on to the changes made to the main function.",
          ],
          [
            1,
            '[ap 05:58] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.58',
            "Listing <<5.58|5a:0>>. listing56.go: lines 35\x{2013}49
      
      35 func main() {
36     // Create an admin user.
37     ad := admin{
38         user: user{
39             name:  \"john smith\",
40             email: \"john\@yahoo.com\",
41         },
42         level: \"super\",
43     }
44
45     // Send the admin user a notification.
46     // The embedded inner type's implementation of the
47     // interface is \"promoted\" to the outer type.
48     sendNotification(&ad)
49 }
      
      This is where things get interesting. On line 37 in listing <<5.58|5a:0>>, we create the admin outer type variable ad. Then on line 48, we pass the address of the outer type variable to the sendNotification function. The compiler accepts the assignment of the outer type pointer as a value that implements the notifier interface. But if you look at the entire sample program, you won\x{2019}t see the admin type implement the interface.",
          ],
          [
            1,
            '[ap 05:59] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.59',
            "Listing <<5.59|5a:0>>. Output for listing56.go
      
      Output:
Sending user email to john smith<john\@yahoo.com>

20 // notify implements a method that can be called via
21 // a value of type user.
22 func (u *user) notify() {
23     fmt.Printf(\"Sending user email to %s<%s>\\n\",
24     u.name,
25     u.email)
26 }
      
      You can see in listing <<5.59|5a:0>> that the inner type\x{2019}s implementation of the interface was called.",
          ],
          [
            1,
            '[ap 06:00] Go in Action - William Kennedy.epub (kindle_split_013.html) - 5.60',
            'Listing <<5.60|5a:0>>. listing60.go
      
      01 // Sample program to show what happens when the outer and inner
02 // types implement the same interface.
03 package main
04
05 import (
06     "fmt"
07 )
08
09 // notifier is an interface that defined notification
10 // type behavior.
11 type notifier interface {
12     notify()
13 }
14
15 // user defines a user in the program.
16 type user struct {
17     name  string
18     email string
19 }
20
21 // notify implements a method that can be called via
22 // a value of type user.
23 func (u *user) notify() {
24     fmt.Printf("Sending user email to %s<%s>\\n",
25         u.name,
26         u.email)
27 }
28
29 // admin represents an admin user with privileges.
30 type admin struct {
31     user
32     level string
33 }
34
35 // notify implements a method that can be called via
36 // a value of type admin.
37 func (a *admin) notify() {
38     fmt.Printf("Sending admin email to %s<%s>\\n",
39         a.name,
40         a.email)
41 }
42
43 // main is the entry point for the application.
44 func main() {
45     // Create an admin user.

46     ad := admin{
47         user: user{
48             name:  "john smith",
49             email: "john@yahoo.com",
50         },
51         level: "super",
52     }
53
54     // Send the admin user a notification.
55     // The embedded inner type\'s implementation of the
56     // interface is NOT "promoted" to the outer type.
57     sendNotification(&ad)
58
59     // We can access the inner type\'s method directly.
60     ad.user.notify()
61
62     // The inner type\'s method is NOT promoted.
63     ad.notify()
64 }
65
66 // sendNotification accepts values that implement the notifier
67 // interface and sends notifications.
68 func sendNotification(n notifier) {
69     n.notify()
70 }
      
      The sample code in listing <<5.60|5a:0>> uses the same code from before, but with a few more changes.',
          ],
          [
            1,
            '[ap 06:10] Go in Action - William Kennedy.epub (kindle_split_014.html) - 6.10',
            'Listing <<6.10|5a:0>>. Output for listing09.go
      
      Final Counter: 2
      
      The counter variable is read and written to four times, twice by each goroutine, but the value of the counter variable when the program terminates is 2. Figure 6.5 provides a clue as to why this is happening.',
          ],
          [
            1,
            '[ap 06:11] Go in Action - William Kennedy.epub (kindle_split_014.html) - 6.11',
            'Listing <<6.11|5a:0>>. Building and running listing09 with the race detector
      
      go build -race   // Build the code using the race detector flag
./example        // Run the code

==================
WARNING: DATA RACE
Write by goroutine 5:

  main.incCounter()
      /example/main.go:49 +0x96

Previous read by goroutine 6:
  main.incCounter()
      /example/main.go:40 +0x66

Goroutine 5 (running) created at:
  main.main()
      /example/main.go:25 +0x5c

Goroutine 6 (running) created at:
  main.main()
      /example/main.go:26 +0x73
==================
Final Counter: 2
Found 1 data race(s)
      
      The race detector in listing <<6.11|5a:0>> has pointed out the following four lines of code from our example.',
          ],
          [
            1,
            '[ap 06:12] Go in Action - William Kennedy.epub (kindle_split_014.html) - 6.12',
            "Listing <<6.12|5a:0>>. Lines of code called out by the race detector
      
      Line 49: counter = value
Line 40: value := counter
Line 25: go incCounter(1)
Line 26: go incCounter(2)
      
      Listing <<6.12|5a:0>> shows that the race detector has told us which goroutine is causing the data race and which two lines of code are in conflict.
         It\x{2019}s not surprising that the code that\x{2019}s pointed out is reading from and writing to the counter variable.",
          ],
          [
            1,
            '[ap 06:13] Go in Action - William Kennedy.epub (kindle_split_014.html) - 6.13',
            'Listing <<6.13|5a:0>>. listing13.go
      
      01 // This sample program demonstrates how to use the atomic
02 // package to provide safe access to numeric types.
03 package main

04
05 import (
06     "fmt"
07     "runtime"
08     "sync"
09     "sync/atomic"
10 )
11
12 var (
13     // counter is a variable incremented by all goroutines.
14     counter int64
15
16     // wg is used to wait for the program to finish.
17     wg sync.WaitGroup
18 )
19
20 // main is the entry point for all Go programs.
21 func main() {
22     // Add a count of two, one for each goroutine.
23     wg.Add(2)
24
25     // Create two goroutines.
26     go incCounter(1)
27     go incCounter(2)
28
29     // Wait for the goroutines to finish.
30     wg.Wait()
31
32     // Display the final value.
33     fmt.Println("Final Counter:", counter)
34 }
35
36 // incCounter increments the package level counter variable.
37 func incCounter(id int) {
38     // Schedule the call to Done to tell main we are done.
39     defer wg.Done()
40
41     for count := 0; count < 2; count++ {
42         // Safely Add One To Counter.
43         atomic.AddInt64(&counter, 1)
44
45         // Yield the thread and be placed back in queue.
46         runtime.Gosched()
47     }
48 }',
          ],
          [
            1,
            '[ap 06:14] Go in Action - William Kennedy.epub (kindle_split_014.html) - 6.14',
            "Listing <<6.14|5a:0>>. Output for listing13.go
      
      Final Counter: 4
      
      On line 43 the program is now using the AddInt64 function from the atomic package. This function synchronizes the adding of integer values by enforcing that only one goroutine can perform and complete
         this add operation at a time. When goroutines attempt to call any atomic function, they\x{2019}re automatically synchronized against the variable that\x{2019}s referenced. Now we get
         the correct value of 4.",
          ],
          [
            1,
            '[ap 06:15] Go in Action - William Kennedy.epub (kindle_split_014.html) - 6.15',
            'Listing <<6.15|5a:1>>. listing15.go
      
      01 // This sample program demonstrates how to use the atomic
02 // package functions Store and Load to provide safe access
03 // to numeric types.
04 package main
05
06 import (
07     "fmt"
08     "sync"
09     "sync/atomic"
10     "time"
11 )
12
13 var (
14     // shutdown is a flag to alert running goroutines to shutdown.
15     shutdown int64
16
17     // wg is used to wait for the program to finish.
18     wg sync.WaitGroup
19 )
20
21 // main is the entry point for all Go programs.
22 func main() {
23     // Add a count of two, one for each goroutine.
24     wg.Add(2)
25
26     // Create two goroutines.
27     go doWork("A")
28     go doWork("B")
29
30     // Give the goroutines time to run.
31     time.Sleep(1 * time.Second)
32
33     // Safely flag it is time to shutdown.
34     fmt.Println("Shutdown Now")
35     atomic.StoreInt64(&shutdown, 1)
36
37     // Wait for the goroutines to finish.
38     wg.Wait()
39 }
40
41 // doWork simulates a goroutine performing work and
42 // checking the Shutdown flag to terminate early.
43 func doWork(name string) {
44     // Schedule the call to Done to tell main we are done.

45     defer wg.Done()
46
47     for {
48         fmt.Printf("Doing %s Work\\n", name)
49         time.Sleep(250 * time.Millisecond)
50
51         // Do we need to shutdown.
52         if atomic.LoadInt64(&shutdown) == 1 {
53             fmt.Printf("Shutting %s Down\\n", name)
54             break
55         }
56     }
57 }
      
      In this example two goroutines are launched and begin to perform some work. After every iteration of their respective loop,
         the goroutines check the value of the shutdown variable by using the LoadInt64 function on line 52. This function returns a safe copy of the shutdown variable. If the value equals 1, the goroutine breaks out of the loop and terminates.',
          ],
          [
            1,
            '[ap 06:16] Go in Action - William Kennedy.epub (kindle_split_014.html) - 6.16',
            "Listing <<6.16|5a:0>>. listing16.go
      
      01 // This sample program demonstrates how to use a mutex
02 // to define critical sections of code that need synchronous
03 // access.
04 package main
05
06 import (
07     \"fmt\"
08     \"runtime\"
09     \"sync\"
10 )
11
12 var (
13     // counter is a variable incremented by all goroutines.
14     counter int
15
16     // wg is used to wait for the program to finish.
17     wg sync.WaitGroup

18
19     // mutex is used to define a critical section of code.
20     mutex sync.Mutex
21 )
22
23 // main is the entry point for all Go programs.
24 func main() {
25     // Add a count of two, one for each goroutine.
26     wg.Add(2)
27
28     // Create two goroutines.
29     go incCounter(1)
30     go incCounter(2)
31
32     // Wait for the goroutines to finish.
33     wg.Wait()
34     fmt.Printf(\"Final Counter: %d\\\\n\", counter)
35 }
36
37 // incCounter increments the package level Counter variable
38 // using the Mutex to synchronize and provide safe access.
39 func incCounter(id int) {
40     // Schedule the call to Done to tell main we are done.
41     defer wg.Done()
42
43     for count := 0; count < 2; count++ {
44         // Only allow one goroutine through this
45         // critical section at a time.
46         mutex.Lock()
47         {
48             // Capture the value of counter.
49             value := counter
50
51             // Yield the thread and be placed back in queue.
52             runtime.Gosched()
53
54             // Increment our local value of counter.
55             value++
56
57             // Store the value back into counter.
58             counter = value
59         }
60         mutex.Unlock()
61         // Release the lock and allow any
62         // waiting goroutine through.
63     }
64 }
      
      The operations against the counter variable are now protected within a critical section defined by the calls to Lock() and Unlock() on lines 46 and 60. The use of the curly brackets is just to make the critical section easier to see; they\x{2019}re not necessary.
         Only one goroutine can enter the critical section at a time. Not until the call to the Unlock() function is made can another goroutine enter the critical section. When the thread is yielded on line 52, the scheduler assigns
         the same goroutine to continue running. After the program completes, we get the correct value of 4 and the race condition no longer exists.",
          ],
          [
            1,
            '[ap 06:17] Go in Action - William Kennedy.epub (kindle_split_014.html) - 6.17',
            "Listing <<6.17|5a:0>>. Using make to create a channel
      
      // Unbuffered channel of integers.
unbuffered := make(chan int)

// Buffered channel of strings.
buffered := make(chan string, 10)
      
      In listing <<6.17|5a:0>> you see the use of the built-in function make to create both an unbuffered and buffered channel. The first argument to make requires the keyword chan and then the type of data the channel will allow to be exchanged. If you\x{2019}re creating a buffered channel, then you specify
         the size of the channel\x{2019}s buffer as the second argument.",
          ],
          [
            1,
            '[ap 06:18] Go in Action - William Kennedy.epub (kindle_split_014.html) - 6.18',
            "Listing <<6.18|5a:0>>. Sending values into a channel
      
      // Buffered channel of strings.
buffered := make(chan string, 10)

// Send a string through the channel.
buffered <- \"Gopher\"
      
      In listing <<6.18|5a:0>> we create a buffered channel of type string that contains a buffer of 10 values. Then we send the string \x{201c}Gopher\x{201d} through the channel. For another goroutine to receive that string from the channel, we use the same <- operator, but this time as a unary operator.",
          ],
          [
            1,
            '[ap 06:19] Go in Action - William Kennedy.epub (kindle_split_014.html) - 6.19',
            'Listing <<6.19|5a:0>>. Receiving values from a channel
      
      // Receive a string from the channel.
value := <-buffered
      
      When receiving a value or pointer from a channel, the <- operator is attached to the left side of the channel variable, as seen in listing <<6.19|5a:0>>.',
          ],
          [
            1,
            '[ap 06:20] Go in Action - William Kennedy.epub (kindle_split_014.html) - 6.20',
            'Listing <<6.20|5a:0>>. listing20.go
      
      01 // This sample program demonstrates how to use an unbuffered
02 // channel to simulate a game of tennis between two goroutines.
03 package main
04
05 import (
06     "fmt"
07     "math/rand"
08     "sync"
09     "time"
10 )
11
12 // wg is used to wait for the program to finish.
13 var wg sync.WaitGroup
14
15 func init() {
16     rand.Seed(time.Now().UnixNano())
17 }
18
19 // main is the entry point for all Go programs.
20 func main() {
21     // Create an unbuffered channel.
22     court := make(chan int)
23
24     // Add a count of two, one for each goroutine.
25     wg.Add(2)
26
27     // Launch two players.
28     go player("Nadal", court)
29     go player("Djokovic", court)
30
31     // Start the set.
32     court <- 1
33
34     // Wait for the game to finish.
35     wg.Wait()
36 }
37

38 // player simulates a person playing the game of tennis.
39 func player(name string, court chan int) {
40     // Schedule the call to Done to tell main we are done.
41     defer wg.Done()
42
43     for {
44         // Wait for the ball to be hit back to us.
45         ball, ok := <-court
46         if !ok {
47             // If the channel was closed we won.
48             fmt.Printf("Player %s Won\\n", name)
49             return
50         }
51
52         // Pick a random number and see if we miss the ball.
53         n := rand.Intn(100)
54         if n%13 == 0 {
55             fmt.Printf("Player %s Missed\\n", name)
56
57             // Close the channel to signal we lost.
58             close(court)
59             return
60         }
61
62         // Display and then increment the hit count by one.
63         fmt.Printf("Player %s Hit %d\\n", name, ball)
64         ball++
65
66         // Hit the ball back to the opposing player.
67         court <- ball
68     }
69 }
      
      When you run the program, you get the following output.',
          ],
          [
            1,
            '[ap 06:21] Go in Action - William Kennedy.epub (kindle_split_014.html) - 6.21',
            'Listing <<6.21|5a:0>>. Output for listing20.go
      
      Player Nadal Hit 1
Player Djokovic Hit 2
Player Nadal Hit 3
Player Djokovic Missed
Player Nadal Won
      
      In the main function on line 22, an unbuffered channel of type int is created to synchronize the exchange of the ball being hit by both goroutines. Then the two goroutines that will be playing
         the game are created on lines 28 and 29. At this point both goroutines are locked waiting to receive the ball. On line 32
         a ball is sent into the channel, and the game is played until one of the goroutines lose.',
          ],
          [
            1,
            '[ap 06:22] Go in Action - William Kennedy.epub (kindle_split_014.html) - 6.22',
            'Listing <<6.22|5a:0>>. listing22.go
      
      01 // This sample program demonstrates how to use an unbuffered
02 // channel to simulate a relay race between four goroutines.
03 package main
04
05 import (
06     "fmt"
07     "sync"
08     "time"
09 )
10
11 // wg is used to wait for the program to finish.
12 var wg sync.WaitGroup
13
14 // main is the entry point for all Go programs.
15 func main() {
16     // Create an unbuffered channel.
17     baton := make(chan int)
18
19     // Add a count of one for the last runner.
20     wg.Add(1)
21
22     // First runner to his mark.
23     go Runner(baton)
24
25     // Start the race.
26     baton <- 1
27
28     // Wait for the race to finish.
29     wg.Wait()
30 }
31
32 // Runner simulates a person running in the relay race.
33 func Runner(baton chan int) {
34     var newRunner int

35
36     // Wait to receive the baton.
37     runner := <-baton
38
39     // Start running around the track.
40     fmt.Printf("Runner %d Running With Baton\\n", runner)
41
42     // New runner to the line.
43     if runner != 4 {
44         newRunner = runner + 1
45         fmt.Printf("Runner %d To The Line\\n", newRunner)
46         go Runner(baton)
47     }
48
49     // Running around the track.
50     time.Sleep(100 * time.Millisecond)
51
52     // Is the race over.
53     if runner == 4 {
54         fmt.Printf("Runner %d Finished, Race Over\\n", runner)
55         wg.Done()
56         return
57     }
58
59     // Exchange the baton for the next runner.
60     fmt.Printf("Runner %d Exchange With Runner %d\\n",
61         runner,
62         newRunner)
63
64     baton <- newRunner
65 }
      
      When you run the program, you get the following output.',
          ],
          [
            1,
            '[ap 06:23] Go in Action - William Kennedy.epub (kindle_split_014.html) - 6.23',
            'Listing <<6.23|5a:0>>. Output for listing22.go
      
      Runner 1 Running With Baton
Runner 1 Exchange With Runner 2
Runner 2 Running With Baton
Runner 2 Exchange With Runner 3
Runner 3 Running With Baton
Runner 3 Exchange With Runner 4
Runner 4 Running With Baton
Runner 4 Finished, Race Over
      
      In the main function on line 17, an unbuffered channel of type int is created to synchronize the exchange of the baton. On line 20 we add a count of 1 to the WaitGroup so the main function can wait until the last runner is finished. The first runner takes to the track on line 23 with the creation of
         a goroutine, and then on line 26 the baton is given to the runner and the race begins. Finally, on line 29 the main function waits on the WaitGroup for the last runner to finish.',
          ],
          [
            1,
            '[ap 06:24] Go in Action - William Kennedy.epub (kindle_split_014.html) - 6.24',
            'Listing <<6.24|5a:0>>. listing24.go
      
      01 // This sample program demonstrates how to use a buffered
02 // channel to work on multiple tasks with a predefined number
03 // of goroutines.
04 package main
05
06 import (
07     "fmt"
08     "math/rand"
09     "sync"
10     "time"
11 )
12
13 const (
14     numberGoroutines = 4  // Number of goroutines to use.
15     taskLoad         = 10 // Amount of work to process.
16 )
17
18 // wg is used to wait for the program to finish.
19 var wg sync.WaitGroup
20
21 // init is called to initialize the package by the
22 // Go runtime prior to any other code being executed.
23 func init() {
24     // Seed the random number generator.
25     rand.Seed(time.Now().Unix())
26 }
27
28 // main is the entry point for all Go programs.
29 func main() {
30     // Create a buffered channel to manage the task load.
31     tasks := make(chan string, taskLoad)
32
33     // Launch goroutines to handle the work.
34     wg.Add(numberGoroutines)
35     for gr := 1; gr <= numberGoroutines; gr++ {
36         go worker(tasks, gr)
37     }
38
39     // Add a bunch of work to get done.
40     for post := 1; post <= taskLoad; post++ {
41         tasks <- fmt.Sprintf("Task : %d", post)
42     }

43
44     // Close the channel so the goroutines will quit
45     // when all the work is done.
46     close(tasks)
47
48     // Wait for all the work to get done.
49     wg.Wait()
50 }
51
52 // worker is launched as a goroutine to process work from
53 // the buffered channel.
54 func worker(tasks chan string, worker int) {
55     // Report that we just returned.
56     defer wg.Done()
57
58     for {
59         // Wait for work to be assigned.
60         task, ok := <-tasks
61         if !ok {
62             // This means the channel is empty and closed.
63             fmt.Printf("Worker: %d : Shutting Down\\n", worker)
64             return
65         }
66
67         // Display we are starting the work.
68         fmt.Printf("Worker: %d : Started %s\\n", worker, task)
69
70         // Randomly wait to simulate work time.
71         sleep := rand.Int63n(100)
72         time.Sleep(time.Duration(sleep) * time.Millisecond)
73
74         // Display we finished the work.
75         fmt.Printf("Worker: %d : Completed %s\\n", worker, task)
76     }
77 }
      
      When you run the program, you get the following output.',
          ],
          [
            1,
            '[ap 06:25] Go in Action - William Kennedy.epub (kindle_split_014.html) - 6.25',
            "Listing <<6.25|5a:0>>. Output for listing24.go
      
      Worker: 1 : Started Task : 1
Worker: 2 : Started Task : 2
Worker: 3 : Started Task : 3
Worker: 4 : Started Task : 4
Worker: 1 : Completed Task : 1
Worker: 1 : Started Task : 5
Worker: 4 : Completed Task : 4
Worker: 4 : Started Task : 6
Worker: 1 : Completed Task : 5

Worker: 1 : Started Task : 7
Worker: 2 : Completed Task : 2
Worker: 2 : Started Task : 8
Worker: 3 : Completed Task : 3
Worker: 3 : Started Task : 9
Worker: 1 : Completed Task : 7
Worker: 1 : Started Task : 10
Worker: 4 : Completed Task : 6
Worker: 4 : Shutting Down
Worker: 3 : Completed Task : 9
Worker: 3 : Shutting Down
Worker: 2 : Completed Task : 8
Worker: 2 : Shutting Down
Worker: 1 : Completed Task : 10
Worker: 1 : Shutting Down
      
      Because of the random nature of the program and the Go scheduler, the output for this program will be different every time
         you run it. But the use of all four goroutines to process work from the buffered channel won\x{2019}t change. You can see from the
         output how each goroutine is receiving work distributed from the channel.",
          ],
          [
            1,
            '[ap 07:10] Go in Action - William Kennedy.epub (kindle_split_015.html) - 7.10',
            "Listing <<7.10|5a:0>>. runner/runner.go: lines 72\x{2013}85
      
      72 // run executes each registered task.
73 func (r *Runner) run() error {
74     for id, task := range r.tasks {

75         // Check for an interrupt signal from the OS.
76         if r.gotInterrupt() {
77             return ErrInterrupt
78         }
79
80         // Execute the registered task.
81         task(id)
82     }
83
84     return nil
85 }
      
      The run method on line 73 in listing <<7.10|5a:0>> iterates over the tasks slice and executes each function in order. Before any function is executed on line 81, the gotInterrupt method is called on line 76 to see if there are any events to receive from the operating system.",
          ],
          [
            1,
            '[ap 07:11] Go in Action - William Kennedy.epub (kindle_split_015.html) - 7.11',
            "Listing <<7.11|5a:0>>. runner/runner.go: lines 87\x{2013}101
      
       87 // gotInterrupt verifies if the interrupt signal has been issued.
 88 func (r *Runner) gotInterrupt() bool {
 89     select {
 90     // Signaled when an interrupt event is sent.
 91     case <-r.interrupt:
 92         // Stop receiving any further signals.
 93         signal.Stop(r.interrupt)
 95         return true
 96
 97     // Continue running as normal.
 98     default:
 99         return false
100     }
101 }
      
      The gotInterrupt method in listing <<7.11|5a:0>> shows a classic use of the select statement with a default case. On line 91, the code attempts to receive on the interrupt channel. Normally that would block if there was nothing to receive, but we have a default case on line 98. The default case turns the attempt to receive on the interrupt channel into a nonblocking call. If there\x{2019}s an interrupt to receive, then it\x{2019}s received and processed. If there\x{2019}s nothing
         to receive, the default case is then executed.",
          ],
          [
            1,
            '[ap 07:12] Go in Action - William Kennedy.epub (kindle_split_015.html) - 7.12',
            "Listing <<7.12|5a:0>>. runner/runner.go: lines 51\x{2013}70
      
      51 // Start runs all tasks and monitors channel events.
52 func (r *Runner) Start() error {

53     // We want to receive all interrupt based signals.
54     signal.Notify(r.interrupt, os.Interrupt)
55
56     // Run the different tasks on a different goroutine.
57     go func() {
58         r.complete <- r.run()
59     }()
60
61     select {
62     // Signaled when processing is done.
63     case err := <-r.complete:
64         return err
65
66     // Signaled when we run out of time.
67     case <-r.timeout:
68         return ErrTimeout
69     }
70 }
      
      The Start method implements the main workflow for the program. In listing <<7.12|5a:0>> on line 52, Start sets up the ability for the gotInterrupt method to receive interrupt events from the operating system. On lines 56 through 59, an anonymous function is declared and
         created as a goroutine. This is the goroutine that executes the set of assigned tasks for the program. On line 58, inside
         this goroutine, the run method is called and the returned error interface value is sent on the complete channel. Once the error interface value is received, the goroutine returns that value to the caller.",
          ],
          [
            1,
            '[ap 07:13] Go in Action - William Kennedy.epub (kindle_split_015.html) - 7.13',
            'Listing <<7.13|5a:0>>. runner/main/main.go
      
      01 // This sample program demonstrates how to use a channel to
02 // monitor the amount of time the program is running and terminate
03 // the program if it runs too long.
03 package main
04
05 import (
06     "log"
07     "time"
08
09     "github.com/goinaction/code/chapter7/patterns/runner"
10 )

11
12 // timeout is the number of second the program has to finish.
13 const timeout = 3 * time.Second
14
15 // main is the entry point for the program.
16 func main() {
17     log.Println("Starting work.")
18
19     // Create a new timer value for this run.
20     r := runner.New(timeout)
21
22     // Add the tasks to be run.
23     r.Add(createTask(), createTask(), createTask())
24
25     // Run the tasks and handle the result.
26     if err := r.Start(); err != nil {
27         switch err {
28         case runner.ErrTimeout:
29             log.Println("Terminating due to timeout.")
30             os.Exit(1)
31         case runner.ErrInterrupt:
32             log.Println("Terminating due to interrupt.")
33             os.Exit(2)
34         }
35     }
36
37     log.Println("Process ended.")
38 }
39
40 // createTask returns an example task that sleeps for the specified
41 // number of seconds based on the id.
42 func createTask() func(int) {
43     return func(id int) {
44         log.Printf("Processor - Task #%d.", id)
45         time.Sleep(time.Duration(id) * time.Second)
46     }
47 }
      
      The main function can be found on line 16 in listing <<7.13|5a:0>>. On line 20 the timeout value is passed to the New function, and a pointer of type Runner is returned. Then the createTask function is added to the Runner several times on line 23. The createTask function, declared on line 42, is a function that just pretends to perform some work for a specified amount of time. Once
         the functions have been added, the Start method is called on line 26 and the main function waits for Start to return.',
          ],
          [
            1,
            '[ap 07:14] Go in Action - William Kennedy.epub (kindle_split_015.html) - 7.14',
            "Listing <<7.14|5a:0>>. pool/pool.go
      
       01 // Example provided with help from Fatih Arslan and Gabriel Aszalos.
 02 // Package pool manages a user defined set of resources.
 03 package pool
 04
 05 import (
 06     \"errors\"
 07     \"log\"
 08     \"io\"
 09     \"sync\"
 10 )
 11
 12 // Pool manages a set of resources that can be shared safely by
 13 // multiple goroutines. The resource being managed must implement
 14 // the io.Closer interface.
 15 type Pool struct {
 16     m         sync.Mutex
 17     resources chan io.Closer
 18     factory   func() (io.Closer, error)
 19     closed    bool
 20 }
 21
 22 // ErrPoolClosed is returned when an Acquire returns on a
 23 // closed pool.
 24 var ErrPoolClosed = errors.New(\"Pool has been closed.\")
 25
 26 // New creates a pool that manages resources. A pool requires a
 27 // function that can allocate a new resource and the size of
 28 // the pool.
 29 func New(fn func() (io.Closer, error), size uint) (*Pool, error) {
 30     if size <= 0 {
 31         return nil, errors.New(\"Size value too small.\")
 32     }
 33
 34     return &Pool{
 35         factory:   fn,
 36         resources: make(chan io.Closer, size),
 37     }, nil
 38 }
 39
 40 // Acquire retrieves a resource from the pool.
 41 func (p *Pool) Acquire() (io.Closer, error) {

 42     select {
 43     // Check for a free resource.
 44     case r, ok := <-p.resources:
 45         log.Println(\"Acquire:\", \"Shared Resource\")
 46         if !ok {
 47             return nil, ErrPoolClosed
 48         }
 49         return r, nil
 50
 51     // Provide a new resource since there are none available.
 52     default:
 53         log.Println(\"Acquire:\", \"New Resource\")
 54         return p.factory()
 55     }
 56 }
 57
 58 // Release places a new resource onto the pool.
 59 func (p *Pool) Release(r io.Closer) {
 60     // Secure this operation with the Close operation.
 61     p.m.Lock()
 62     defer p.m.Unlock()
 63
 64     // If the pool is closed, discard the resource.
 65     if p.closed {
 66         r.Close()
 67         return
 68     }
 69
 70     select {
 71     // Attempt to place the new resource on the queue.
 72     case p.resources <- r:
 73         log.Println(\"Release:\", \"In Queue\")
 74
 75     // If the queue is already at capacity we close the resource.
 76     default:
 77         log.Println(\"Release:\", \"Closing\")
 78         r.Close()
 79     }
 80 }
 81
 82 // Close will shutdown the pool and close all existing resources.
 83 func (p *Pool) Close() {
 84     // Secure this operation with the Release operation.
 85     p.m.Lock()
 86     defer p.m.Unlock()
 87
 88     // If the pool is already closed, don't do anything.
 89     if p.closed {
 90         return
 91     }
 92
 93     // Set the pool as closed.
 94     p.closed = true
 95
 96     // Close the channel before we drain the channel of its

 97     // resources. If we don't do this, we will have a deadlock.
 98     close(p.resources)
 99
100     // Close the resources
101     for r := range p.resources {
102         r.Close()
103     }
104 }
      
      The code for the pool package in listing <<7.14|5a:0>> declares a struct named Pool that allows the caller to create as many different pools as needed. Each pool can manage any type of resource as long as
         the type implements the io.Closer interface. Let\x{2019}s take a look at the declaration of the Pool struct.",
          ],
          [
            1,
            '[ap 07:15] Go in Action - William Kennedy.epub (kindle_split_015.html) - 7.15',
            "Listing <<7.15|5a:0>>. pool/pool.go: lines 12\x{2013}20
      
      12 // Pool manages a set of resources that can be shared safely by
13 // multiple goroutines. The resource being managed must implement
14 // the io.Closer interface.
15 type Pool struct {
16     m         sync.Mutex
17     resources chan io.Closer
18     factory   func() (io.Closer, error)
19     closed    bool
20 }
      
      The Pool struct declares four fields, each of which helps manage the pool in a goroutine-safe way. On line 16 the struct starts off
         with a field of type sync.Mutex. This mutex is used to keep all the operations against a Pool value-safe for multigoroutine access. The second field is named resources and is declared as a channel of interface type io.Closer. This channel will be created as a buffered channel and will contain the resources being shared. Because an interface type
         is being used, the pool can manage any type of resource that implements the io.Closer interface.",
          ],
          [
            1,
            '[ap 07:16] Go in Action - William Kennedy.epub (kindle_split_015.html) - 7.16',
            "Listing <<7.16|5a:0>>. pool/pool.go: lines 22\x{2013}24
      
      22 // ErrPoolClosed is returned when an Acquire returns on a
23 // closed pool.
24 var ErrPoolClosed = errors.New(\"Pool has been closed.\")
      
      Creating error interface variables is a common practice in Go. This allows the caller to identify specific returned error values from any
         function or method within the package. The error interface variable in listing <<7.16|5a:0>> has been declared to report when the user calls the Acquire method and the Pool has been closed. Since the Acquire method can return multiple different errors, returning this error variable when the Pool is closed allows the caller to identify this specific error over others.",
          ],
          [
            1,
            '[ap 07:17] Go in Action - William Kennedy.epub (kindle_split_015.html) - 7.17',
            "Listing <<7.17|5a:0>>. pool/pool.go: lines 26\x{2013}38
      
      26 // New creates a pool that manages resources. A pool requires a
27 // function that can allocate a new resource and the size of
28 // the pool.
29 func New(fn func() (io.Closer, error), size uint) (*Pool, error) {
30     if size <= 0 {
31         return nil, errors.New(\"Size value too small.\")
32     }
33
34     return &Pool{
35         factory:   fn,
36         resources: make(chan io.Closer, size),
37     }, nil
38 }
      
      The New function in listing <<7.17|5a:0>> accepts two parameters and returns two values. The first parameter, fn, is declared as a function type that accepts no parameters and returns an io.Closer and an error interface value. The function parameter represents a factory function that creates values of the resource being managed by
         the pool. The second parameter, size, represents the size of the buffered channel created to hold the resources.",
          ],
          [
            1,
            '[ap 07:18] Go in Action - William Kennedy.epub (kindle_split_015.html) - 7.18',
            "Listing <<7.18|5a:0>>. pool/pool.go: lines 40\x{2013}56
      
      40 // Acquire retrieves a resource from the pool.
41 func (p *Pool) Acquire() (io.Closer, error) {
42     select {
43     // Check for a free resource.
44     case r, ok := <-p.resources:
45         log.Println(\"Acquire:\", \"Shared Resource\")
46         if !ok {
47             return nil, ErrPoolClosed
48         }
49         return r, nil
50
51     // Provide a new resource since there are none available.
52     default:
53         log.Println(\"Acquire:\", \"New Resource\")
54         return p.factory()
55     }
56 }
      
      Listing <<7.18|5a:0>> contains the code for the Acquire method. This method returns a resource from the pool if one is available, or creates a new one for the call. This implementation
         is accomplished by using a select / case statement to check if there\x{2019}s a resource in the buffered channel. If there is, it\x{2019}s received and then returned to the caller.
         This can be seen on lines 44 and 49. If there\x{2019}s no resource in the buffered channel to receive, then the default case is executed. In this case, on line 54 the user\x{2019}s factory function is executed and a new resource is created and returned.",
          ],
          [
            1,
            '[ap 07:19] Go in Action - William Kennedy.epub (kindle_split_015.html) - 7.19',
            "Listing <<7.19|5a:0>>. pool/pool.go: lines 82\x{2013}104
      
       82 // Close will shutdown the pool and close all existing resources.
 83 func (p *Pool) Close() {
 84     // Secure this operation with the Release operation.
 85     p.m.Lock()
 86     defer p.m.Unlock()
 87
 88     // If the pool is already closed, don't do anything.
 89     if p.closed {
 90         return
 91     }
 92
 93     // Set the pool as closed.
 94     p.closed = true
 95
 96     // Close the channel before we drain the channel of its
 97     // resources. If we don't do this, we will have a deadlock.
 98     close(p.resources)
 99

100     // Close the resources
101     for r := range p.resources {
102         r.Close()
103     }
104 }
      
      Once the program is finished with the pool, it should call the Close method. The code for the Close method is shown in listing <<7.19|5a:0>>. The method closes and flushes the buffered channel on lines 98 and 101, closing any resources that exist until the channel
         is empty. All the code in this method must be executed by only one goroutine at a time. In fact, when this code is being executed,
         goroutines must also be prevented from executing code in the Release method. You\x{2019}ll understand why this is important soon.",
          ],
          [
            1,
            '[ap 07:20] Go in Action - William Kennedy.epub (kindle_split_015.html) - 7.20',
            "Listing <<7.20|5a:0>>. pool/pool.go: lines 58\x{2013}80
      
      58 // Release places a new resource onto the pool.
59 func (p *Pool) Release(r io.Closer) {
60     // Secure this operation with the Close operation.
61     p.m.Lock()
62     defer p.m.Unlock()
63
64     // If the pool is closed, discard the resource.
65     if p.closed {
66         r.Close()
67         return
68     }
69
70     select {
71     // Attempt to place the new resource on the queue.
72     case p.resources <- r:
73         log.Println(\"Release:\", \"In Queue\")
74
75     // If the queue is already at capacity we close the resource.
76     default:
77         log.Println(\"Release:\", \"Closing\")
78         r.Close()
79     }
80 }
      
      The implementation of the Release method can be found in listing <<7.20|5a:0>>. The method starts out with the locking and unlocking of a mutex on lines 61 and 62. This is the same mutex as in the Close method. This is how both methods are prevented from being run at the same time by different goroutines. The use of the mutex
         serves two purposes. First, it protects the read on the closed flag on line 65 from happening at the same time as a write on this flag in the Close method. Second, we don\x{2019}t want to attempt to send on a closed channel because this will cause a panic. When the closed field is false, we know the resources channel has been closed.",
          ],
          [
            1,
            '[ap 07:21] Go in Action - William Kennedy.epub (kindle_split_015.html) - 7.21',
            'Listing <<7.21|5a:0>>. pool/main/main.go
      
      01 // This sample program demonstrates how to use the pool package
02 // to share a simulated set of database connections.
03 package main
04
05 import (
06     "log"
07     "io"
08     "math/rand"
09     "sync"
10     "sync/atomic"
11     "time"
12
13     "github.com/goinaction/code/chapter7/patterns/pool"
14 )
15
16 const (
17     maxGoroutines   = 25 // the number of routines to use.
18     pooledResources = 2  // number of resources in the pool
19 )
20
21 // dbConnection simulates a resource to share.
22 type dbConnection struct {
23     ID int32
24 }
25
26 // Close implements the io.Closer interface so dbConnection
27 // can be managed by the pool. Close performs any resource
28 // release management.
29 func (dbConn *dbConnection) Close() error {
30     log.Println("Close: Connection", dbConn.ID)
31     return nil
32 }
33
34 // idCounter provides support for giving each connection a unique id.
35 var idCounter int32
36
37 // createConnection is a factory method that will be called by
38 // the pool when a new connection is needed.
39 func createConnection() (io.Closer, error) {

40     id := atomic.AddInt32(&idCounter, 1)
41     log.Println("Create: New Connection", id)
42
43     return &dbConnection{id}, nil
44 }
45
46 // main is the entry point for all Go programs.
47 func main() {
48     var wg sync.WaitGroup
49     wg.Add(maxGoroutines)
50
51     // Create the pool to manage our connections.
52     p, err := pool.New(createConnection, pooledResources)
53     if err != nil {
54         log.Println(err)
55     }
56
57     // Perform queries using connections from the pool.
58     for query := 0; query < maxGoroutines; query++ {
59         // Each goroutine needs its own copy of the query
60         // value else they will all be sharing the same query
61         // variable.
62         go func(q int) {
63             performQueries(q, p)
64             wg.Done()
65         }(query)
66     }
67
68     // Wait for the goroutines to finish.
69     wg.Wait()
70
71     // Close the pool.
72     log.Println("Shutdown Program.")
73     p.Close()
74 }
75
76 // performQueries tests the resource pool of connections.
77 func performQueries(query int, p *pool.Pool) {
78     // Acquire a connection from the pool.
79     conn, err := p.Acquire()
80     if err != nil {
81         log.Println(err)
82         return
83     }
84
85     // Release the connection back to the pool.
86     defer p.Release(conn)
87
88     // Wait to simulate a query response.
89     time.Sleep(time.Duration(rand.Intn(1000)) * time.Millisecond)
90     log.Printf("QID[%d] CID[%d]\\n", query, conn.(*dbConnection).ID)
91 }
      
      The code in main.go, shown in listing <<7.21|5a:0>>, uses the pool package to manage a simulated pool of database connections. The code starts out declaring two constants, maxGoroutines and pooledResources, to set the number of goroutines and resources the program is going to use. The declaration of the resource and the implementation
         of the io.Closer interface follows.',
          ],
          [
            1,
            '[ap 07:22] Go in Action - William Kennedy.epub (kindle_split_015.html) - 7.22',
            "Listing <<7.22|5a:1>>. pool/main/main.go: lines 21\x{2013}32
      
      21 // dbConnection simulates a resource to share.
22 type dbConnection struct {
23     ID int32
24 }
25
26 // Close implements the io.Closer interface so dbConnection
27 // can be managed by the pool. Close performs any resource
28 // release management.
29 func (dbConn *dbConnection) Close() error {
30     log.Println(\"Close: Connection\", dbConn.ID)
31     return nil
32 }
      
      Listing <<7.22|5a:1>> shows the declaration of the dbConnection struct and its implementation of the io.Closer interface. The dbConnection type simulates a struct that\x{2019}s managing a database connection and currently has one field, ID, that contains a unique ID for each connection. The Close method just reports that the connection is being closed and displays its ID.",
          ],
          [
            1,
            '[ap 07:23] Go in Action - William Kennedy.epub (kindle_split_015.html) - 7.23',
            "Listing <<7.23|5a:0>>. pool/main/main.go: lines 34\x{2013}44
      
      34 // idCounter provides support for giving each connection a unique id.
35 var idCounter int32
36
37 // createConnection is a factory method that will be called by
38 // the pool when a new connection is needed.
39 func createConnection() (io.Closer, error) {
40     id := atomic.AddInt32(&idCounter, 1)
41     log.Println(\"Create: New Connection\", id)
42
43     return &dbConnection{id}, nil
44 }
      
      Listing <<7.23|5a:0>> shows the implementation of the createConnection function. The function generates a new and unique ID for the connection, displays that the connection is being created, and
         returns a pointer to a value of type dbConnection with this unique ID. The generation of the unique ID is performed with the atomic.AddInt32 function. It\x{2019}s used to safely increment the value of the package level variable idCounter. Now that we have our resource and the factory function, we can use it with the pool package.",
          ],
          [
            1,
            '[ap 07:24] Go in Action - William Kennedy.epub (kindle_split_015.html) - 7.24',
            "Listing <<7.24|5a:0>>. pool/main/main.go: lines 48\x{2013}55
      
      48     var wg sync.WaitGroup
49     wg.Add(maxGoroutines)
50
51     // Create the pool to manage our connections.
52     p, err := pool.New(createConnection, pooledResources)
53     if err != nil {
54         log.Println(err)
55     }
      
      The main function starts out with declaring a WaitGroup on line 48 and setting the value of the WaitGroup to match the number of goroutines that will be created. The new Pool is created using the New function from the pool package. The factory function and the number of resources to manage are passed in. This returns a pointer to the Pool value and any possible error is checked. Now that we have a Pool, we can create goroutines that can share resources being managed by the pool.",
          ],
          [
            1,
            '[ap 07:25] Go in Action - William Kennedy.epub (kindle_split_015.html) - 7.25',
            "Listing <<7.25|5a:0>>. pool/main/main.go: lines 57\x{2013}66
      
      57     // Perform queries using connections from the pool.
58     for query := 0; query < maxGoroutines; query++ {
59         // Each goroutine needs its own copy of the query
60         // value else they will all be sharing the same query
61         // variable.
62         go func(q int) {
63             performQueries(q, p)
64             wg.Done()
65         }(query)
66     }
      
      A for loop is used in listing <<7.25|5a:0>> to create goroutines that will use the pool. Each goroutine calls the performQueries function once and then quits. The performQueries function is provided a unique ID for logging and the pointer to the Pool. Once all the goroutines are created, the main function then waits for the goroutines to complete.",
          ],
          [
            1,
            '[ap 07:26] Go in Action - William Kennedy.epub (kindle_split_015.html) - 7.26',
            "Listing <<7.26|5a:0>>. pool/main/main.go: lines 68\x{2013}73
      
      68     // Wait for the goroutines to finish.
69     wg.Wait()
70
71     // Close the pool.
72     log.Println(\"Shutdown Program.\")
73     p.Close()
      
      In listing <<7.26|5a:0>>, the main function waits on the WaitGroup. Once all the goroutines report they\x{2019}re done, the Pool is closed and the program terminates. Next, let\x{2019}s look at the performQueries function, which uses the pool\x{2019}s Acquire and Release methods.",
          ],
          [
            1,
            '[ap 07:27] Go in Action - William Kennedy.epub (kindle_split_015.html) - 7.27',
            "Listing <<7.27|5a:0>>. pool/main/main.go: lines 76\x{2013}91
      
      76 // performQueries tests the resource pool of connections.
77 func performQueries(query int, p *pool.Pool) {
78     // Acquire a connection from the pool.
79     conn, err := p.Acquire()
80     if err != nil {
81         log.Println(err)
82         return
83     }
84
85     // Release the connection back to the pool.
86     defer p.Release(conn)
87
88     // Wait to simulate a query response.
89     time.Sleep(time.Duration(rand.Intn(1000)) * time.Millisecond)
90     log.Printf(\"QID[%d] CID[%d]\\n\", query, conn.(*dbConnection).ID)
91 }
      
      The implementation of the performQueries function in listing <<7.27|5a:0>> shows the use of the pool\x{2019}s Acquire and Release methods. The function starts out by calling the Acquire method to retrieve a dbConnection from the pool. The returned error interface value is checked, and then on line 86 a defer is used to release the dbConnection back into the pool once the function returns. On lines 89 and 90 a random amount of sleep occurs to simulate work time using
         the dbConnection.",
          ],
          [
            1,
            '[ap 07:28] Go in Action - William Kennedy.epub (kindle_split_015.html) - 7.28',
            'Listing <<7.28|5a:0>>. work/work.go
      
      01 // Example provided with help from Jason Waldrip.
02 // Package work manages a pool of goroutines to perform work.
03 package work
04
05 import "sync"
06
07 // Worker must be implemented by types that want to use
08 // the work pool.
09 type Worker interface {
10     Task()

11 }
12
13 // Pool provides a pool of goroutines that can execute any Worker
14 // tasks that are submitted.
15 type Pool struct {
16     work chan Worker
17     wg   sync.WaitGroup
18 }
19
20 // New creates a new work pool.
21 func New(maxGoroutines int) *Pool {
22     p := Pool{
23         tasks: make(chan Worker),
24     }
25
26     p.wg.Add(maxGoroutines)
27     for i := 0; i < maxGoroutines; i++ {
28         go func() {
29             for w := range p.work {
30                 w.Task()
31             }
32             p.wg.Done()
33         }()
34     }
35
36     return &p
37 }
38
39 // Run submits work to the pool.
40 func (p *Pool) Run(w Worker) {
41     p.work <- w
42 }
43
44 // Shutdown waits for all the goroutines to shutdown.
45 func (p *Pool) Shutdown() {
46     close(p.tasks)
47     p.wg.Wait()
48 }
      
      The work package in listing <<7.28|5a:0>> starts off with the declaration of an interface named Worker and a struct named Pool.',
          ],
          [
            1,
            '[ap 07:29] Go in Action - William Kennedy.epub (kindle_split_015.html) - 7.29',
            "Listing <<7.29|5a:0>>. work/work.go: lines 07\x{2013}18
      
      07 // Worker must be implemented by types that want to use
08 // the work pool.
09 type Worker interface {
10     Task()
11 }
12
13 // Pool provides a pool of goroutines that can execute any Worker
14 // tasks that are submitted.
15 type Pool struct {
16     work chan Worker
17     wg   sync.WaitGroup
18 }
      
      The Worker interface on line 09 in listing <<7.29|5a:0>> declares a single method called Task. On line 15 a struct named Pool is declared, which is the type that implements the pool of goroutines and will have methods that process the work. The type
         declares two fields, one named work, which is a channel of the Worker interface type, and a sync.WaitGroup named wg.",
          ],
          [
            1,
            '[ap 07:30] Go in Action - William Kennedy.epub (kindle_split_015.html) - 7.30',
            "Listing <<7.30|5a:0>>. work/work.go: lines 20\x{2013}37
      
      20 // New creates a new work pool.
21 func New(maxGoroutines int) *Pool {
22     p := Pool{
23         work: make(chan Worker),
24     }
25
26     p.wg.Add(maxGoroutines)
27     for i := 0; i < maxGoroutines; i++ {
28         go func() {
29             for w := range p.work {
30                 w.Task()
31             }
32             p.wg.Done()
33         }()
34     }
35
36     return &p
37 }
      
      Listing <<7.30|5a:0>> shows the New function that\x{2019}s used to create work pool that\x{2019}s configured with a fixed number of goroutines. The number of goroutines is
         passed in as a parameter to the New function. On line 22 a value of type Pool is created, and the work field is initialized with an unbuffered channel.",
          ],
          [
            1,
            '[ap 07:31] Go in Action - William Kennedy.epub (kindle_split_015.html) - 7.31',
            "Listing <<7.31|5a:0>>. work/work.go: lines 28\x{2013}33
      
      28         go func() {
29             for w := range w.work {
30                 w.Task()
31             }
32             p.wg.Done()
33         }()
      
      The for range loop blocks until there\x{2019}s a Worker interface value to receive on the work channel. When a value is received, the Task method is called. Once the work channel is closed, the for range loop ends and the call to Done on the WaitGroup is called. Then the goroutine terminates.",
          ],
          [
            1,
            '[ap 07:32] Go in Action - William Kennedy.epub (kindle_split_015.html) - 7.32',
            "Listing <<7.32|5a:0>>. work/work.go: lines 39\x{2013}42
      
      39 // Run submits work to the pool.
40 func (p *Pool) Run(w Worker) {
41     w.work <- w
42 }
      
      Listing <<7.32|5a:0>> shows the Run method. This method is used to submit work into the pool. It accepts an interface value of type Worker and sends that value through the work channel. Since the work channel is an unbuffered channel, the caller must wait for a goroutine from the pool to receive it. This is what we want,
         because the caller needs the guarantee that the work being submitted is being worked on once the call to Run returns.",
          ],
          [
            1,
            '[ap 07:33] Go in Action - William Kennedy.epub (kindle_split_015.html) - 7.33',
            "Listing <<7.33|5a:0>>. work/work.go: lines 44\x{2013}48
      
      44 // Shutdown waits for all the goroutines to shutdown.
45 func (p *Pool) Shutdown() {
46     close(p.work)
47     p.wg.Wait()
48 }
      
      The Shutdown method in listing <<7.33|5a:0>> does two things. First, it closes the work channel, which causes all of the goroutines in the pool to shut down and call the Done method on the WaitGroup. Then the Shutdown method calls the Wait method on the WaitGroup, which causes the Shutdown method to wait for all the goroutines to report they have terminated.",
          ],
          [
            1,
            '[ap 07:34] Go in Action - William Kennedy.epub (kindle_split_015.html) - 7.34',
            'Listing <<7.34|5a:0>>. work/main/main.go
      
      01 // This sample program demonstrates how to use the work package
02 // to use a pool of goroutines to get work done.
03 package main
04
05 import (
06     "log"
07     "sync"
08     "time"
09
10     "github.com/goinaction/code/chapter7/patterns/work"
11 )
12

13 // names provides a set of names to display.
14 var names = []string{
15     "steve",
16     "bob",
17     "mary",
18     "therese",
19     "jason",
20 }
21
22 // namePrinter provides special support for printing names.
23 type namePrinter struct {
24     name string
25 }
26
27 // Task implements the Worker interface.
28 func (m *namePrinter) Task() {
29     log.Println(m.name)
30     time.Sleep(time.Second)
31 }
32
33 // main is the entry point for all Go programs.
34 func main() {
35     // Create a work pool with 2 goroutines.
36     p := work.New(2)
37
38     var wg sync.WaitGroup
39     wg.Add(100 * len(names))
40
41     for i := 0; i < 100; i++ {
42         // Iterate over the slice of names.
43         for _, name := range names {
44             // Create a namePrinter and provide the
45             // specific name.
46             np := namePrinter{
47                 name: name,
48             }
49
50             go func() {
51                 // Submit the task to be worked on. When RunTask
52                 // returns we know it is being handled.
53                 p.Run(&np)
54                 wg.Done()
55             }()
56         }
57     }
58
59     wg.Wait()
60
61     // Shutdown the work pool and wait for all existing work
62     // to be completed.
63     p.Shutdown()
64 }
      
      Listing <<7.34|5a:0>> shows the test program that uses the work package to perform the displaying of names. The code starts out on line 14 with the declaration of a package level variable
         named names, which is declared as a slice of strings. The slice is also initialized with five names. Then a type named namePrinter is declared.',
          ],
          [
            1,
            '[ap 07:35] Go in Action - William Kennedy.epub (kindle_split_015.html) - 7.35',
            "Listing <<7.35|5a:0>>. work/main/main.go: lines 22\x{2013}31
      
      22 // namePrinter provides special support for printing names.
23 type namePrinter struct {
24     name string
25 }
26
27 // Task implements the Worker interface.
28 func (m *namePrinter) Task() {
29     log.Println(m.name)
30     time.Sleep(time.Second)
31 }
      
      On line 23 in listing <<7.35|5a:0>>, the namePrinter type is declared and the implementation of the Worker interface follows. The purpose of the work is to display names to the screen. The type contains a single field, name, that will contain the name to display. The implementation of the Worker interface uses the log.Println function to display the name and then waits a second before returning. The second wait is just to slow the test program down
         so you can see the concurrency is action.",
          ],
          [
            1,
            '[ap 07:36] Go in Action - William Kennedy.epub (kindle_split_015.html) - 7.36',
            "Listing <<7.36|5a:0>>. work/main/main.go: lines 33\x{2013}64
      
      33 // main is the entry point for all Go programs.
34 func main() {
35     // Create a work pool with 2 goroutines.
36     p := work.New(2)
37
38     var wg sync.WaitGroup
39     wg.Add(100 * len(names))
40
41     for i := 0; i < 100; i++ {
42         // Iterate over the slice of names.
43         for _, name := range names {
44             // Create a namePrinter and provide the
45             // specific name.
46             np := namePrinter{
47                 name: name,
48             }
49
50             go func() {
51                 // Submit the task to be worked on. When RunTask
52                 // returns we know it is being handled.
53                 p.Run(&np)

54                 wg.Done()
55             }()
56         }
57     }
58
59     wg.Wait()
60
61     // Shutdown the work pool and wait for all existing work
62     // to be completed.
63     p.Shutdown()
64 }
      
      On line 36 in listing <<7.36|5a:0>>, the New function from the work package is called to create the work pool. The number 2 is passed into the call, indicating the pool should only contain
         two goroutines. On lines 38 and 39 a WaitGroup is declared and initialized to each goroutine that will be created. In this case, a goroutine for each name in the names slice will be created 100 times. This is to create a lot of goroutines competing to submit work to the pool.",
          ],
          [
            1,
            '[23:00] Go in Action - William Kennedy.epub (kindle_split_016.html) - 23:00',
            "Listing 8.2. Sample trace line
      
      TRACE: 2009/11/10 <<23:00|2>>:00.000000 /tmpfs/gosandbox-/prog.go:14: message
      
      In listing 8.2 you see a log entry produced by the log package. This log entry contains a prefix, a datetime stamp, the full path to the source code writing to the log, the line
         of code performing the write, and finally the message. Let\x{2019}s look at a program that allows you to configure the log package to write such a line.",
          ],
          [
            1,
            '[ap 08:10] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.10',
            "Listing <<8.10|5a:0>>. listing03.go: lines 13\x{2013}22
      
      13 func main() {
14     // Println writes to the standard logger.
15     log.Println(\"message\")
16
17     // Fatalln is Println() followed by a call to os.Exit(1).
18     log.Fatalln(\"fatal message\")
19
20     // Panicln is Println() followed by a call to panic().
21     log.Panicln(\"panic message\")
22 }
      
      Listing <<8.10|5a:0>> shows how to write log messages using three different functions: Println, Fatalln, and Panicln. These functions have a format version, as well, that end with the letter f instead of the letters ln. The Fatal family of functions is used to write a log message and then terminate the program using the os.Exit(1) function call. The Panic family of functions is used to write a log message and then issue a panic, which unless recovered, will cause the program
         to terminate and stack trace. The Print family of functions is the standard way to write log messages.",
          ],
          [
            1,
            '[ap 08:11] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.11',
            "Listing <<8.11|5a:0>>. listing11.go
      
      01 // This sample program demonstrates how to create customized loggers.
02 package main
03
04 import (
05     \"io\"
06     \"io/ioutil\"
07     \"log\"
08     \"os\"
09 )
10
11 var (
12     Trace   *log.Logger // Just about anything
13     Info    *log.Logger // Important information
14     Warning *log.Logger // Be concerned
15     Error   *log.Logger // Critical problem
16 )
17
18 func init() {
19     file, err := os.OpenFile(\"errors.txt\",
20         os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)
21     if err != nil {
22         log.Fatalln(\"Failed to open error log file:\", err)
23     }
24
25     Trace = log.New(ioutil.Discard,
26         \"TRACE: \",
27         log.Ldate|log.Ltime|log.Lshortfile)
28
29     Info = log.New(os.Stdout,
30         \"INFO: \",
31         log.Ldate|log.Ltime|log.Lshortfile)
32

33     Warning = log.New(os.Stdout,
34         \"WARNING: \",
35         log.Ldate|log.Ltime|log.Lshortfile)
36
37     Error = log.New(io.MultiWriter(file, os.Stderr),
38         \"ERROR: \",
39         log.Ldate|log.Ltime|log.Lshortfile)
40 }
41
42 func main() {
43     Trace.Println(\"I have something standard to say\")
44     Info.Println(\"Special Information\")
45     Warning.Println(\"There is something you need to know about\")
46     Error.Println(\"Something has failed\")
47 }
      
      Listing <<8.11|5a:0>> shows a complete program that creates four different Logger type pointer variables. They\x{2019}re named Trace, Info, Warning, and Error. Each variable is configured differently because of the importance each represents. Let\x{2019}s break down the code so you can
         learn how all this works.",
          ],
          [
            1,
            '[ap 08:12] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.12',
            "Listing <<8.12|5a:0>>. listing11.go: lines 11\x{2013}16
      
      11 var (
12     Trace   *log.Logger // Just about anything
13     Info    *log.Logger // Important information
14     Warning *log.Logger // Be concerned
15     Error   *log.Logger // Critical problem
16 )
      
      In listing <<8.12|5a:0>> you see the declaration of the Logger type pointer variables. We\x{2019}ve given each logger a short but descriptive variable name. Next, let\x{2019}s look at the code in init() that creates and assigns the address of each Logger type value to each variable.",
          ],
          [
            1,
            '[ap 08:13] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.13',
            "Listing <<8.13|5a:0>>. listing11.go: lines 25\x{2013}39
      
      25     Trace = log.New(ioutil.Discard,
26         \"TRACE: \",
27         log.Ldate|log.Ltime|log.Lshortfile)
28
29     Info = log.New(os.Stdout,
30         \"INFO: \",
31         log.Ldate|log.Ltime|log.Lshortfile)
32
33     Warning = log.New(os.Stdout,
34         \"WARNING: \",
35         log.Ldate|log.Ltime|log.Lshortfile)
36
37     Error = log.New(io.MultiWriter(file, os.Stderr),
38         \"ERROR: \",
39         log.Ldate|log.Ltime|log.Lshortfile)
      
      To create each logger, we use the New function from the log package, which creates a properly initialized Logger type value. The New function returns the address to the newly created value. Before the New function can create a value, we need to pass it some parameters.",
          ],
          [
            1,
            '[ap 08:14] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.14',
            'Listing <<8.14|5a:0>>. golang.org/src/log/log.go
      
      // New creates a new Logger. The out variable sets the
// destination to which log data will be written.
// The prefix appears at the beginning of each generated log line.
// The flag argument defines the logging properties.
func New(out io.Writer, prefix string, flag int) *Logger {
    return &Logger{out: out, prefix: prefix, flag: flag}
}
      
      Listing <<8.14|5a:0>> shows the declaration of the New function from the source code for the log package. The first parameter is the destination we want the logger to write to. This is provided as a value that implements
         the io.Writer interface. The second parameter is the prefix that you saw before, and log flags comprise the final parameter.',
          ],
          [
            1,
            '[ap 08:15] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.15',
            "Listing <<8.15|5a:0>>. listing11.go: lines 25\x{2013}27
      
      25     Trace = log.New(ioutil.Discard,
26         \"TRACE: \",
27         log.Ldate|log.Ltime|log.Lshortfile)
      
      The Discard variable has some very interesting properties.",
          ],
          [
            1,
            '[ap 08:16] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.16',
            'Listing <<8.16|5a:0>>. golang.org/src/io/ioutil/ioutil.go
      
      // devNull is a named type using int as its base type.
type devNull int

// Discard is an io.Writer on which all Write calls succeed
// without doing anything.
var Discard io.Writer = devNull(0)

// Implementation of the io.Writer interface.
func (devNull) Write(p []byte) (int, error) {
    return len(p), nil
}
      
      Listing <<8.16|5a:0>> shows the declaration of the Discard variable and the implementation surrounding it. The Discard variable is declared to be of interface type io.Writer and is given a value of 0 of type devNull. Anything written to this variable is discarded based on the implementation of the Write method for the devNull type. Using the Discard variable is a technique you can use to disable a logging level when the output for that level is not required.',
          ],
          [
            1,
            '[ap 08:17] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.17',
            "Listing <<8.17|5a:0>>. listing11.go: lines 29\x{2013}35
      
      29     Info = log.New(os.Stdout,
30         \"INFO: \",
31         log.Ldate|log.Ltime|log.Lshortfile)
32
33     Warning = log.New(os.Stdout,
34         \"WARNING: \",
35         log.Ldate|log.Ltime|log.Lshortfile)
      
      The declaration of the Stdout variable is also interesting.",
          ],
          [
            1,
            '[ap 08:18] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.18',
            'Listing <<8.18|5a:0>>. golang.org/src/os/file.go
      
      // Stdin, Stdout, and Stderr are open Files pointing to the standard
// input, standard output, and standard error file descriptors.
var (
    Stdin  = NewFile(uintptr(syscall.Stdin), "/dev/stdin")
    Stdout = NewFile(uintptr(syscall.Stdout), "/dev/stdout")
    Stderr = NewFile(uintptr(syscall.Stderr), "/dev/stderr")
)

os/file_unix.go

// NewFile returns a new File with the given file descriptor and name.
func NewFile(fd uintptr, name string) *File {
      
      In listing <<8.18|5a:0>> you can see the declaration for the three variables that represent the standard destinations that exist on all operating
         systems: Stdin, Stdout, and Stderr. All these variables are declared to be pointers of type File, which implements the io.Writer interface. This leads us to the final logger, Error.',
          ],
          [
            1,
            '[ap 08:19] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.19',
            "Listing <<8.19|5a:0>>. listing11.go: lines 37\x{2013}39
      
      37     Error = log.New(io.MultiWriter(file, os.Stderr),
38         \"ERROR: \",
39         log.Ldate|log.Ltime|log.Lshortfile)
      
      In listing <<8.19|5a:0>> you can see that the first parameter to the New function comes from a special function called MultiWriter from the io package.",
          ],
          [
            1,
            '[ap 08:20] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.20',
            'Listing <<8.20|5a:0>>. Declaration of the MultiWriter function in the io package
      
      io.MultiWriter(file, os.Stderr)
      
      Listing <<8.20|5a:0>> isolates the call to the MultiWriter function, which returns an interface type value of io.Writer that contains both the file that we opened and the stderr destination. The MultiWriter function is a variadic function that accepts any number of values that implement the io.Writer interface. The function returns a single io.Writer value that bundles all of the io.Writer values that are passed in. This allows functions like log.New to accept multiple writers within a single writer. Now when we write a log using the Error logger, the output will be written to both the file and stderr.',
          ],
          [
            1,
            '[ap 08:21] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.21',
            "Listing <<8.21|5a:0>>. listing11.go: lines 42\x{2013}47
      
      42 func main() {
43     Trace.Println(\"I have something standard to say\")
44     Info.Println(\"Special Information\")
45     Warning.Println(\"There is something you need to know about\")
46     Error.Println(\"Something has failed\")
47 }
      
      Listing <<8.21|5a:0>> shows the main() function from listing <<8.11|5a:0>>. On lines 43 through 46 we write a single message for each logger that we created. Each logger variable contains a set of
         methods that are identical to the set of functions that are implemented by the log package.",
          ],
          [
            1,
            '[ap 08:22] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.22',
            'Listing <<8.22|5a:0>>. Declarations of the different logging methods
      
      func (l *Logger) Fatal(v ...interface{})
func (l *Logger) Fatalf(format string, v ...interface{})
func (l *Logger) Fatalln(v ...interface{})
func (l *Logger) Flags() int
func (l *Logger) Output(calldepth int, s string) error
func (l *Logger) Panic(v ...interface{})
func (l *Logger) Panicf(format string, v ...interface{})
func (l *Logger) Panicln(v ...interface{})
func (l *Logger) Prefix() string
func (l *Logger) Print(v ...interface{})
func (l *Logger) Printf(format string, v ...interface{})
func (l *Logger) Println(v ...interface{})
func (l *Logger) SetFlags(flag int)
func (l *Logger) SetPrefix(prefix string)
      
      Listing <<8.22|5a:0>> shows all the methods that have been implemented for the Logger type.',
          ],
          [
            1,
            '[ap 08:23] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.23',
            "Listing <<8.23|5a:0>>. Google search API sample JSON response
      
      {
    \"responseData\": {
        \"results\": [
            {
                \"GsearchResultClass\": \"GwebSearch\",
                \"unescapedUrl\": \"https://www.reddit.com/r/golang\",
                \"url\": \"https://www.reddit.com/r/golang\",
                \"visibleUrl\": \"www.reddit.com\",
                \"cacheUrl\": \"http://www.google.com/search?q=cache:W...\",
                \"title\": \"r/\\u003cb\\u003eGolang\\u003c/b\\u003e - Reddit\",
                \"titleNoFormatting\": \"r/Golang - Reddit\",
                \"content\": \"First Open Source \\u003cb\\u003eGolang\\u...\"
            },
            {
                \"GsearchResultClass\": \"GwebSearch\",
                \"unescapedUrl\": \"http://tour.golang.org/\",
                \"url\": \"http://tour.golang.org/\",
                \"visibleUrl\": \"tour.golang.org\",
                \"cacheUrl\": \"http://www.google.com/search?q=cache:O...\",
                \"title\": \"A Tour of Go\",
                \"titleNoFormatting\": \"A Tour of Go\",
                \"content\": \"Welcome to a tour of the Go programming ...\"

            }
        ]
    }
}
      
      Here\x{2019}s the example that retrieves and decodes the response into a struct type.",
          ],
          [
            1,
            '[ap 08:24] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.24',
            "Listing <<8.24|5a:0>>. listing24.go
      
      01 // This sample program demonstrates how to decode a JSON response
02 // using the json package and NewDecoder function.
03 package main
04
05 import (
06     \"encoding/json\"
07     \"fmt\"
08     \"log\"
09     \"net/http\"
10 )
11
12 type (
13     // gResult maps to the result document received from the search.
14     gResult struct {
15         GsearchResultClass string `json:\"GsearchResultClass\"`
16         UnescapedURL       string `json:\"unescapedUrl\"`
17         URL                string `json:\"url\"`
18         VisibleURL         string `json:\"visibleUrl\"`
19         CacheURL           string `json:\"cacheUrl\"`
20         Title              string `json:\"title\"`
21         TitleNoFormatting  string `json:\"titleNoFormatting\"`
22         Content            string `json:\"content\"`
23     }
24
25     // gResponse contains the top level document.
26     gResponse struct {
27         ResponseData struct {
28             Results []gResult `json:\"results\"`
29         } `json:\"responseData\"`
30     }
31 )
32
33 func main() {
34     uri := \"http://ajax.googleapis.com/ajax/services/search/web?
                                                  v=1.0&rsz=8&q=golang\"
35
36     // Issue the search against Google.
37     resp, err := http.Get(uri)
38     if err != nil {
39        log.Println(\"ERROR:\", err)
40        return
41     }
42     defer resp.Body.Close()
43
44     // Decode the JSON response into our struct type.
45     var gr gResponse
46     err = json.NewDecoder(resp.Body).Decode(&gr)

47     if err != nil {
48         log.Println(\"ERROR:\", err)
49         return
50     }
51
52     fmt.Println(gr)
53 }
      
      The code on line 37 in listing <<8.24|5a:0>> shows a program that makes an HTTP Get call that retrieves a JSON document from Google. Then, using the NewDecoder function and Decode method on line 46, the JSON document from the response is decoded into a variable of the struct type that\x{2019}s declared on line
         26. On line 52 the value of the variable is written to stdout.",
          ],
          [
            1,
            '[ap 08:25] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.25',
            "Listing <<8.25|5a:0>>. golang.org/src/encoding/json/stream.go
      
      // NewDecoder returns a new decoder that reads from r.
//
// The decoder introduces its own buffering and may
// read data from r beyond the JSON values requested.
func NewDecoder(r io.Reader) *Decoder

// Decode reads the next JSON-encoded value from its
// input and stores it in the value pointed to by v.
//
// See the documentation for Unmarshal for details about
// the conversion of JSON into a Go value.
func (dec *Decoder) Decode(v interface{}) error
      
      In listing <<8.25|5a:0>> you can see that the NewDecoder function accepts any value whose type implements the io.Reader interface. In the next section you\x{2019}ll learn more about the io.Reader and io.Writer interfaces. For now, understand that many different types from within the standard library implement these interfaces, including
         types from the http package. When types implement these particular interfaces, you get a lot of support and functionality for free.",
          ],
          [
            1,
            '[ap 08:25] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.25',
            'The NewDecoder function returns a pointer value of type Decoder. Since Go supports compound statement calls, the return value from the NewDecoder function can be used to call the Decode method immediately without the need to declare a variable first. In listing <<8.25|5a:0>> you can see that the Decode method accepts a value of type interface{} and returns an error.',
          ],
          [
            1,
            '[ap 08:26] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.26',
            'Listing <<8.26|5a:0>>. Use of the Decode method
      
      var gr *gResponse
err = json.NewDecoder(resp.Body).Decode(&gr)
      
      In listing <<8.26|5a:0>> we pass the address of a pointer variable of type gResponse, with the value of nil, to the Decode method. After the method call, the value of the pointer variable will be assigned to a value of type gResponse and initialized based on the JSON document being decoded.',
          ],
          [
            1,
            '[ap 08:27] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.27',
            "Listing <<8.27|5a:0>>. listing27.go
      
      01 // This sample program demonstrates how to decode a JSON string.
02 package main
03
04 import (
05     \"encoding/json\"
06     \"fmt\"
07     \"log\"
08 )
09
10 // Contact represents our JSON string.
11 type Contact struct {
12     Name    string `json:\"name\"`
13     Title   string `json:\"title\"`
14     Contact struct {
15         Home string `json:\"home\"`
16         Cell string `json:\"cell\"`
17     } `json:\"contact\"`
18 }
19
20 // JSON contains a sample string to unmarshal.
21 var JSON = `{
22     \"name\": \"Gopher\",
23     \"title\": \"programmer\",
24     \"contact\": {
25         \"home\": \"415.333.3333\",
26         \"cell\": \"415.555.5555\"

27     }
28 }`
29
30 func main() {
31     // Unmarshal the JSON string into our variable.
32     var c Contact
33     err := json.Unmarshal([]byte(JSON), &c)
34     if err != nil {
35         log.Println(\"ERROR:\", err)
36         return
37     }
38
39     fmt.Println(c)
40 }
      
      In listing <<8.27|5a:0>> we have an example that takes a JSON document inside of a string variable and uses the Unmarshal function to decode the JSON into a struct type value. If you run the program, you\x{2019}ll get the following output.",
          ],
          [
            1,
            '[ap 08:28] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.28',
            "Listing <<8.28|5a:0>>. Output for listing27.go
      
      {Gopher programmer {415.333.3333 415.555.5555}}
      
      Sometimes it\x{2019}s not possible to declare a struct type and you need more flexibility to work with the JSON document. In these
         cases you can decode or unmarshal the JSON document into a map variable.",
          ],
          [
            1,
            '[ap 08:29] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.29',
            "Listing <<8.29|5a:0>>. listing29.go
      
      01 // This sample program demonstrates how to decode a JSON string.
02 package main
03
04 import (
05     \"encoding/json\"
06     \"fmt\"
07     \"log\"
08 )
09
10 // JSON contains a sample string to unmarshal.
11 var JSON = `{
12     \"name\": \"Gopher\",
13     \"title\": \"programmer\",
14     \"contact\": {
15         \"home\": \"415.333.3333\",
16         \"cell\": \"415.555.5555\"
17     }
18 }`
19
20 func main() {
21     // Unmarshal the JSON string into our map variable.
22     var c map[string]interface{}
23     err := json.Unmarshal([]byte(JSON), &c)
24     if err != nil {

25         log.Println(\"ERROR:\", err)
26         return
27     }
28
29     fmt.Println(\"Name:\", c[\"name\"])
30     fmt.Println(\"Title:\", c[\"title\"])
31     fmt.Println(\"Contact\")
32     fmt.Println(\"H:\", c[\"contact\"].(map[string]interface{})[\"home\"])
33     fmt.Println(\"C:\", c[\"contact\"].(map[string]interface{})[\"cell\"])
34 }
      
      In listing <<8.29|5a:0>> we\x{2019}ve changed the program from listing <<8.27|5a:0>> to use a map variable instead of our struct type variable. The map variable is declared as a map with a key of type string and a value of type interface{}. This means the map can store any type of value for any given key. Though this gives you great flexibility when working with JSON documents,
         it has one minor drawback. Look at the syntax required to access the home field from the contact subdocument.",
          ],
          [
            1,
            '[ap 08:30] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.30',
            "Listing <<8.30|5a:0>>. Syntax for accessing a field from an unmarshaled map
      
      fmt.Println(\"\\tHome:\", c[\"contact\"].(map[string]interface{})[\"home\"])
      
      Because the value for each key is of type interface{}, you need to convert the value to the proper native type in order to work with the value. Listing <<8.30|5a:0>> shows how you need to convert the value of the contact key to another map with a key of type string and a value of type interface{}. This can make using maps that contain JSON documents sometimes unfriendly to work with. But if you never need to dig into
         the JSON documents you\x{2019}re working with or you plan to do very little manipulation, using a map can be fast, and then there\x{2019}s no need to declare new types.",
          ],
          [
            1,
            '[ap 08:31] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.31',
            "Listing <<8.31|5a:0>>. listing31.go
      
      01 // This sample program demonstrates how to marshal a JSON string.
02 package main
03
04 import (
05     \"encoding/json\"
06     \"fmt\"
07     \"log\"
08 )
09
10 func main() {

11     // Create a map of key/value pairs.
12     c := make(map[string]interface{})
13     c[\"name\"] = \"Gopher\"
14     c[\"title\"] = \"programmer\"
15     c[\"contact\"] = map[string]interface{}{
16         \"home\": \"415.333.3333\",
17         \"cell\": \"415.555.5555\",
18     }
19
20     // Marshal the map into a JSON string.
21     data, err := json.MarshalIndent(c, \"\", \"    \")
22     if err != nil {
23         log.Println(\"ERROR:\", err)
24         return
25     }
26
27     fmt.Println(string(data))
28 }
      
      Listing <<8.31|5a:0>> shows how to use the MarshalIndent function from the json package to convert a map to a JSON string. The MarshalIndent function returns a byte slice that represents the JSON string and an error value. Here\x{2019}s a look at the declaration of the
         MarshalIndent function from the json package.",
          ],
          [
            1,
            '[ap 08:32] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.32',
            'Listing <<8.32|5a:0>>. golang.org/src/encoding/json/encode.go
      
      // MarshalIndent is like Marshal but applies Indent to format the output
func MarshalIndent(v interface{}, prefix, indent string)
                                                       ([]byte, error) {
      
      You can see the use of the empty interface type again as the parameter to the MarshalIndent function. The MarshalIndent function uses reflection to determine how to transform the map type into a JSON string.',
          ],
          [
            1,
            '[ap 08:33] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.33',
            'Listing <<8.33|5a:0>>. Declaration of the io.Writer interface
      
      type Writer interface {
        Write(p []byte) (n int, err error)
}
      
      Listing <<8.33|5a:0>> shows the declaration of the io.Writer interface. The interface declares a single method called Write that accepts a byte slice and returns two values. The first value is the number of bytes written, and the second value is an error. The rules for implementing this method are as follows.',
          ],
          [
            1,
            '[ap 08:34] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.34',
            "Listing <<8.34|5a:1>>. Documentation for the io.Writer interface
      
      Write writes len(p) bytes from p to the underlying data stream. It
returns the number of bytes written from p (0 <= n <= len(p)) and any
error encountered that caused the write to stop early. Write must
return a non-nil error if it returns n < len(p). Write must not modify
the slice data, even temporarily.
      
      The rules in listing <<8.34|5a:1>> come from the standard library. They mean that the implementation of the Write method should attempt to write the entire length of the byte slice that\x{2019}s passed in. But if that isn\x{2019}t possible, then the method must return an error. The number of bytes reported as
         written can be less than the length of the byte slice, but never more. Finally, the byte slice must never be modified in any way.",
          ],
          [
            1,
            '[ap 08:35] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.35',
            'Listing <<8.35|5a:0>>. Declaration of the io.Reader interface
      
      type Reader interface {
        Read(p []byte) (n int, err error)
}
      
      The io.Reader interface in listing <<8.35|5a:0>> declares a single method, Read, that accepts a byte slice and returns two values. The first value is the number of bytes read and the second value is an error. The rules for implementing this method are as follows.',
          ],
          [
            1,
            '[ap 08:36] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.36',
            "Listing <<8.36|5a:0>>. Documentation for the io.Reader interface
      
      (1) Read reads up to len(p) bytes into p. It returns the number of bytes
read (0 <= n <= len(p)) and any error encountered. Even if Read returns
n < len(p), it may use all of p as scratch space during the call. If
some data is available but not len(p) bytes, Read conventionally
returns what is available instead of waiting for more.

(2) When Read encounters an error or end-of-file condition after
successfully reading n > 0 bytes, it returns the number of bytes read.
It may return the (non-nil) error from the same call or return the
error (and n == 0) from a subsequent call. An instance of this general
case is that a Reader returning a non-zero number of bytes at the end
of the input stream may return either err == EOF or err == nil. The next
Read should return 0, EOF regardless.

(3) Callers should always process the n > 0 bytes returned before
considering the error err. Doing so correctly handles I/O errors that
happen after reading some bytes and also both of the allowed EOF
behaviors.

(4) Implementations of Read are discouraged from returning a zero byte
count with a nil error, and callers should treat that situation as a
no-op.
      
      There are four rules listed in the standard library about implementing the Read method. The first rule states that the implementation should attempt to read the entire length of the byte slice that\x{2019}s passed in. It\x{2019}s okay to read less than the entire length, and it shouldn\x{2019}t wait to read the entire length if
         that much data isn\x{2019}t available at the time of the call.",
          ],
          [
            1,
            '[ap 08:37] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.37',
            "Listing <<8.37|5a:0>>. listing37.go
      
      01 // Sample program to show how different functions from the
02 // standard library use the io.Writer interface.
03 package main
04
05 import (
06     \"bytes\"
07     \"fmt\"
08     \"os\"
09 )
10
11 // main is the entry point for the application.
12 func main() {
13     // Create a Buffer value and write a string to the buffer.
14     // Using the Write method that implements io.Writer.
15     var b bytes.Buffer
16     b.Write([]byte(\"Hello \"))
17
18     // Use Fprintf to concatenate a string to the Buffer.
19     // Passing the address of a bytes.Buffer value for io.Writer.
20     fmt.Fprintf(&b, \"World!\")
21
22     // Write the content of the Buffer to the stdout device.
23     // Passing the address of a os.File value for io.Writer.
24     b.WriteTo(os.Stdout)
25 }
      
      When you run the program in listing <<8.37|5a:0>>, you\x{2019}ll get the following output.",
          ],
          [
            1,
            '[ap 08:38] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.38',
            "Listing <<8.38|5a:0>>. Output for listing37.go
      
      Hello World!
      
      This program is using three packages from the standard library to write \x{201c}Hello World!\x{201d} to the terminal window. The program
         starts on line 15 by declaring a variable of type Buffer from the bytes package, which is initialized to its zero value. On line 16 a byte slice is created and initialized with the string \"Hello\". The byte slice is passed into the Write method and becomes the initial content for the buffer.",
          ],
          [
            1,
            '[ap 08:39] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.39',
            "Listing <<8.39|5a:0>>. golang.org/src/fmt/print.go
      
      // Fprintf formats according to a format specifier and writes to w. It
// returns the number of bytes written and any write error encountered.
func Fprintf(w io.Writer, format string, a ...interface{})
                                                     (n int, err error)
      
      What\x{2019}s important to note is the first parameter of the Fprintf function. It accepts values from types that implement the io.Writer interface. This means that the Buffer type from the bytes package must implement this interface since we\x{2019}re able to pass the address of a variable of that type through. In the source
         code for the bytes package, we should then find the Write method declared for the Buffer type.",
          ],
          [
            1,
            '[ap 08:40] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.40',
            'Listing <<8.40|5a:0>>. golang.org/src/bytes/buffer.go
      
      // Write appends the contents of p to the buffer, growing the buffer
// as needed. The return value n is the length of p; err is always
// nil. If the buffer becomes too large, Write will panic with ...
func (b *Buffer) Write(p []byte) (n int, err error) {
    b.lastRead = opInvalid
    m := b.grow(len(p))
    return copy(b.buf[m:], p), nil
}
      
      Listing <<8.40|5a:0>> shows the current implementation of the Write method for the Buffer type that implements the io.Writer interface. Because of the implementation of this method, we can pass pointers of type Buffer as the first parameter to Fprintf. We use the Fprintf function in our example to append the string "World!" to the internal buffer of the Buffer type variable via the implementation of the Write method.',
          ],
          [
            1,
            '[ap 08:37] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.37',
            "Let\x{2019}s review the last line of listing <<8.37|5a:0>>, which writes the entire buffer to stdout.",
          ],
          [
            1,
            '[ap 08:41] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.41',
            "Listing <<8.41|5a:0>>. listing37.go: lines 22\x{2013}25
      
      22 // Write the content of the Buffer to the stdout device.
23     // Passing the address of a os.File value for io.Writer.
24     b.WriteTo(os.Stdout)
25 }
      
      On line 24 of listing <<8.37|5a:0>>, the contents of the Buffer type variable are written to stdout using the WriteTo method. This method accepts a value that implements the io.Writer interface. In our program we pass the value of the Stdout variable from the os package.",
          ],
          [
            1,
            '[ap 08:42] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.42',
            'Listing <<8.42|5a:0>>. golang.org/src/os/file.go
      
      var (
    Stdin  = NewFile(uintptr(syscall.Stdin), "/dev/stdin")
    Stdout = NewFile(uintptr(syscall.Stdout), "/dev/stdout")
    Stderr = NewFile(uintptr(syscall.Stderr), "/dev/stderr")
)
      
      The declaration of these variables comes from the type returned by the NewFile function.',
          ],
          [
            1,
            '[ap 08:43] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.43',
            'Listing <<8.43|5a:0>>. golang.org/src/os/file_unix.go
      
      // NewFile returns a new File with the given file descriptor and name.
func NewFile(fd uintptr, name string) *File {
    fdi := int(fd)
    if fdi < 0 {
        return nil
    }
    f := &File{&file{fd: fdi, name: name}}
    runtime.SetFinalizer(f.file, (*file).close)
    return f
}
      
      As you can see in listing <<8.43|5a:0>>, the NewFile function returns a pointer of type File. This is the type of the Stdout variable. Since we can pass pointers of this type as a parameter to the WriteTo method, it must implement the io.Writer interface. In the source code for the os package, we should find the Write method.',
          ],
          [
            1,
            '[ap 08:44] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.44',
            'Listing <<8.44|5a:0>>. golang.org/src/os/file.go
      
      // Write writes len(b) bytes to the File.
// It returns the number of bytes written and an error, if any.
// Write returns a non-nil error when n != len(b).
func (f *File) Write(b []byte) (n int, err error) {
    if f == nil {
        return 0, ErrInvalid
    }
    n, e := f.write(b)
    if n < 0 {
        n = 0
    }
    if n != len(b) {
        err = io.ErrShortWrite
    }

    epipecheck(f, e)

    if e != nil {

        err = &PathError{"write", f.name, e}
    }
    return n, err
}
      
      Sure enough, listing <<8.44|5a:0>> shows the implementation of the io.Writer interface for pointers of type File. Look again at line 24 from listing <<8.37|5a:0>>.',
          ],
          [
            1,
            '[ap 08:45] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.45',
            "Listing <<8.45|5a:0>>. listing37.go: lines 22\x{2013}25
      
      22     // Write the content of the Buffer to the stdout device.
23     // Using the io.Writer implementation for os.File.
24     b.WriteTo(os.Stdout)
25 }
      
      You see that the WriteTo method is able to write the contents of the buffer to stdout which results in the string \"Hello World!\" being displayed on our terminal window. The method will use the implementation of the Write method from the File type via the interface value.",
          ],
          [
            1,
            '[ap 08:46] Go in Action - William Kennedy.epub (kindle_split_016.html) - 8.46',
            "Listing <<8.46|5a:0>>. listing46.go
      
      01 // Sample program to show how to write a simple version of curl using
02 // the io.Reader and io.Writer interface support.
03 package main
04
05 import (
06     \"io\"
07     \"log\"
08     \"net/http\"
09     \"os\"
10 )
11
12 // main is the entry point for the application.
13 func main() {
14     // r here is a response, and r.Body is an io.Reader.
15     r, err := http.Get(os.Args[1])

16     if err != nil {
17         log.Fatalln(err)
18     }
19
20     // Create a file to persist the response.
21     file, err := os.Create(os.Args[2])
22     if err != nil {
23         log.Fatalln(err)
24     }
25     defer file.Close()
26
27     // Use MultiWriter so we can write to stdout and
28     // a file on the same write operation.
29     dest := io.MultiWriter(os.Stdout, file)
30
31     // Read the response and write to both destinations.
32     io.Copy(dest, r.Body)
33     if err := r.Body.Close(); err != nil {
34         log.Println(err)
35     }
36 }
      
      Listing <<8.46|5a:0>> shows a very bare-bones implementation of curl that can be used to download, display, and save the content of any HTTP Get request. The example will write the response to a file and to stdout at the same time. To keep the example small, the program doesn\x{2019}t check for valid command-line arguments nor provide switches
         for advanced options.",
          ],
          [
            1,
            '[ap 09:10] Go in Action - William Kennedy.epub (kindle_split_017.html) - 9.10',
            "Listing <<9.10|5a:0>>. listing08_test.go: lines 29\x{2013}34
      
      29     t.Log(\"Given the need to test downloading different content.\")
30     {
31         for _, u := range urls {
32             t.Logf(\"\\tWhen checking \\\"%s\\\" for status code \\\"%d\\\"\",
33                 u.url, u.statusCode)
34             {
      
      The for range loop on line 31 in listing <<9.10|5a:0>> allows the test to iterate over the table and run the test code for each different URL. The original code from the basic
         unit test is the same except for the use of the table values.",
          ],
          [
            1,
            '[ap 09:11] Go in Action - William Kennedy.epub (kindle_split_017.html) - 9.11',
            "Listing <<9.11|5a:0>>. listing08_test.go: lines 35\x{2013}55
      
      35                 resp, err := http.Get(u.url)
36                 if err != nil {
37                     t.Fatal(\"\\t\\tShould be able to Get the url.\",
38                         ballotX, err)
39                 }
40                 t.Log(\"\\t\\tShould be able to Get the url\",
41                     checkMark)
42
43                 defer resp.Body.Close()
44
45                 if resp.StatusCode == u.statusCode {
46                     t.Logf(\"\\t\\tShould have a \\\"%d\\\" status. %v\",
47                         u.statusCode, checkMark)
48                 } else {
49                     t.Errorf(\"\\t\\tShould have a \\\"%d\\\" status %v %v\",
50                         u.statusCode, ballotX, resp.StatusCode)
51                 }
52             }
53         }
54     }
55 }
      
      Listing <<9.11|5a:0>> shows how, on line 35, the code uses the u.url field for the URL to call. On line 45 the u.statusCode field is used to compare the actual status code from the response. In the future, new URLs and status codes can be added
         to the table and the core of the test doesn\x{2019}t need to change.",
          ],
          [
            1,
            '[ap 09:12] Go in Action - William Kennedy.epub (kindle_split_017.html) - 9.12',
            "Listing <<9.12|5a:0>>. listing12_test.go: lines 01\x{2013}41
      
      01 // Sample test to show how to mock an HTTP GET call internally.
02 // Differs slightly from the book to show more.
03 package listing12
04
05 import (
06     \"encoding/xml\"
07     \"fmt\"
08     \"net/http\"
09     \"net/http/httptest\"
10     \"testing\"
11 )
12
13 const checkMark = \"\\u2713\"
14 const ballotX = \"\\u2717\"
15
16 // feed is mocking the XML document we except to receive.
17 var feed = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>
18 <rss>
19 <channel>
20     <title>Going Go Programming</title>
21     <description>Golang : https://github.com/goinggo</description>
22     <link>http://www.goinggo.net/</link>
23     <item>
24         <pubDate>Sun, 15 Mar 2015 <<15:04|2>>:00 +0000</pubDate>
25         <title>Object Oriented Programming Mechanics</title>
26         <description>Go is an object oriented language.</description>
27         <link>http://www.goinggo.net/2015/03/object-oriented</link>
28     </item>
29 </channel>
30 </rss>`
31
32 // mockServer returns a pointer to a server to handle the get call.
33 func mockServer() *httptest.Server {

34     f := func(w http.ResponseWriter, r *http.Request) {
35         w.WriteHeader(200)
36         w.Header().Set(\"Content-Type\", \"application/xml\")
37         fmt.Fprintln(w, feed)
38     }
39
40     return httptest.NewServer(http.HandlerFunc(f))
41 }
      
      Listing <<9.12|5a:0>> shows how we can mock a call to the goinggo.net website to simulate the downloading of the RSS feed. On line 17 a package-level
         variable named feed is declared and initialized with a literal string that represents the RSS XML document we\x{2019}ll receive from our mock server
         call. It\x{2019}s a small snippet of the actual RSS feed document and is enough to conduct our test. On line 32 we have the declaration
         of a function named mockServer that leverages the support inside the httptest package to simulate a call to a real server on the internet.",
          ],
          [
            1,
            '[ap 09:13] Go in Action - William Kennedy.epub (kindle_split_017.html) - 9.13',
            "Listing <<9.13|5a:0>>. listing12_test.go: lines 32\x{2013}40
      
      32 func mockServer() *httptest.Server {
33     f := func(w http.ResponseWriter, r *http.Request) {
34         w.WriteHeader(200)
35         w.Header().Set(\"Content-Type\", \"application/xml\")
36         fmt.Fprintln(w, feed)
37     }
38
39     return httptest.NewServer(http.HandlerFunc(f))
40 }
      
      The mockServer function in listing <<9.13|5a:0>> is declared to return a pointer of type httptest.Server. The httptest.Server value is the key to making all of this work. The code starts out with declaring an anonymous function that has the same signature
         as the http.HandlerFunc function type.",
          ],
          [
            1,
            '[ap 09:14] Go in Action - William Kennedy.epub (kindle_split_017.html) - 9.14',
            "Listing <<9.14|5a:0>>. golang.org/pkg/net/http/#HandlerFunc
      
      type HandlerFunc func(ResponseWriter, *Request)

The HandlerFunc type is an adapter to allow the use of ordinary
functions as HTTP handlers. If f is a function with the appropriate
signature, HandlerFunc(f) is a Handler object that calls f
      
      This makes the anonymous function a handler function. Once the handler function is declared, then on line 39 it\x{2019}s used as
         a parameter for the httptest.NewServer function call to create our mock server. Then the mock server is returned via a pointer on line 39.",
          ],
          [
            1,
            '[ap 09:15] Go in Action - William Kennedy.epub (kindle_split_017.html) - 9.15',
            "Listing <<9.15|5a:0>>. listing12_test.go: lines 43\x{2013}74
      
      43 // TestDownload validates the http Get function can download content
44 // and the content can be unmarshaled and clean.
45 func TestDownload(t *testing.T) {
46     statusCode := http.StatusOK
47
48     server := mockServer()
49     defer server.Close()
50
51     t.Log(\"Given the need to test downloading content.\")
52     {
53         t.Logf(\"\\tWhen checking \\\"%s\\\" for status code \\\"%d\\\"\",
54             server.URL, statusCode)
55         {
56             resp, err := http.Get(server.URL)
57             if err != nil {
58                 t.Fatal(\"\\t\\tShould be able to make the Get call.\",
59                     ballotX, err)
60             }
61             t.Log(\"\\t\\tShould be able to make the Get call.\",
62                 checkMark)
63
64             defer resp.Body.Close()
65
66             if resp.StatusCode != statusCode {
67                 t.Fatalf(\"\\t\\tShould receive a \\\"%d\\\" status. %v %v\",
68                     statusCode, ballotX, resp.StatusCode)
69             }
70             t.Logf(\"\\t\\tShould receive a \\\"%d\\\" status. %v\",
71                statusCode, checkMark)
72         }
73     }
74 }
      
      In listing <<9.15|5a:0>> you see the TestDownload function once more, but this time it\x{2019}s using the mock server. On lines 48 and 49 a call to the mockServer function is made, and a call to the Close method is deferred for when the test function returns. After that, the test code looks identical to the basic unit test except
         for one thing.",
          ],
          [
            1,
            '[ap 09:16] Go in Action - William Kennedy.epub (kindle_split_017.html) - 9.16',
            "Listing <<9.16|5a:0>>. listing12_test.go: line 56
      
      56             resp, err := http.Get(server.URL)
      
      This time the URL to call is provided to by the httptest.Server value. When we use the URL provided by the mocking server, the http.Get call runs as expected. The http.Get call has no idea it\x{2019}s not making a call over the internet. The call is made and our handler function is executed underneath, resulting in a response of our RSS XML document and a status of http.StatusOK.",
          ],
          [
            1,
            '[ap 09:17] Go in Action - William Kennedy.epub (kindle_split_017.html) - 9.17',
            'Listing <<9.17|5a:0>>. listing17.go
      
      01 // This sample code implement a simple web service.
02 package main
03
04 import (
05     "log"
06     "net/http"
07
08     "github.com/goinaction/code/chapter9/listing17/handlers"
09 )
10
11 // main is the entry point for the application.
12 func main() {
13     handlers.Routes()
14
15     log.Println("listener : Started : Listening on :4000")
16     http.ListenAndServe(":4000", nil)
17 }
      
      Listing <<9.17|5a:0>> shows the code file for the entry point of the web service. Inside the main function on line 13, the code calls the Routes function from the internal handlers package. This function sets up the routes for the different endpoints the web service is hosting. On lines 15 and 16 the
         main function displays the port the service is listening on and starts the web service, waiting for requests.',
          ],
          [
            1,
            '[ap 09:18] Go in Action - William Kennedy.epub (kindle_split_017.html) - 9.18',
            'Listing <<9.18|5a:0>>. handlers/handlers.go
      
      01 // Package handlers provides the endpoints for the web service.
02 package handlers
03
04 import (
05     "encoding/json"
06     "net/http"
07 )
08
09 // Routes sets the routes for the web service.
10 func Routes() {
11     http.HandleFunc("/sendjson", SendJSON)
12 }
13
14 // SendJSON returns a simple JSON document.
15 func SendJSON(rw http.ResponseWriter, r *http.Request) {
16     u := struct {
17         Name  string
18         Email string
19     }{
20         Name:  "Bill",
21         Email: "bill@ardanstudios.com",
22     }
23
24     rw.Header().Set("Content-Type", "application/json")
25     rw.WriteHeader(200)
26     json.NewEncoder(rw).Encode(&u)
27 }
      
      The code for the handlers package in listing <<9.18|5a:0>> provides the implementation of the handler function and sets up the routes for the web service. On line 10 you see the Routes function, which uses the default http.ServeMux from inside the http package to configure the routing between the URLs and the corresponding handler code. On line 11 we bind the /sendjson endpoint to the SendJSON function.',
          ],
          [
            1,
            '[ap 09:14] Go in Action - William Kennedy.epub (kindle_split_017.html) - 9.14',
            'Starting on line 15, we have the implementation of the SendJSON function. The function has the same signature as the http.HandlerFunc function type that you saw in listing <<9.14|5a:0>>. On line 16 an anonymous struct type is declared, and a variable named u is created with some values. On lines 24 and 25 the content type and status code for the response is set. Finally, on line
         26 the u value is encoded into a JSON document and sent back to the client.',
          ],
          [
            1,
            '[ap 09:19] Go in Action - William Kennedy.epub (kindle_split_017.html) - 9.19',
            'Listing <<9.19|5a:0>>. handlers/handlers_test.go
      
      01 // Sample test to show how to test the execution of an
02 // internal endpoint.
03 package handlers_test
04
05 import (
06     "encoding/json"
07     "net/http"
08     "net/http/httptest"
09     "testing"
10
11     "github.com/goinaction/code/chapter9/listing17/handlers"
12 )
13
14 const checkMark = "\\u2713"
15 const ballotX = "\\u2717"
16
17 func init() {
18     handlers.Routes()
19 }
20
21 // TestSendJSON testing the sendjson internal endpoint.
22 func TestSendJSON(t *testing.T) {
23     t.Log("Given the need to test the SendJSON endpoint.")
24     {
25         req, err := http.NewRequest("GET", "/sendjson", nil)
26         if err != nil {
27             t.Fatal("\\tShould be able to create a request.",
28                 ballotX, err)
29         }
30         t.Log("\\tShould be able to create a request.",
31             checkMark)
32
33         rw := httptest.NewRecorder()
34         http.DefaultServeMux.ServeHTTP(rw, req)
35
36         if rw.Code != 200 {
37             t.Fatal("\\tShould receive \\"200\\"", ballotX, rw.Code)
38         }
39         t.Log("\\tShould receive \\"200\\"", checkMark)
40

41         u := struct {
42             Name  string
43             Email string
44         }{}
45
46         if err := json.NewDecoder(rw.Body).Decode(&u); err != nil {
47             t.Fatal("\\tShould decode the response.", ballotX)
48         }
49         t.Log("\\tShould decode the response.", checkMark)
50
51         if u.Name == "Bill" {
52           t.Log("\\tShould have a Name.", checkMark)
53         } else {
54           t.Error("\\tShould have a Name.", ballotX, u.Name)
55         }
56
57         if u.Email == "bill@ardanstudios.com" {
58             t.Log("\\tShould have an Email.", checkMark)
59         } else {
60             t.Error("\\tShould have an Email.", ballotX, u.Email)
61         }
62     }
63 }
      
      Listing <<9.19|5a:0>> shows a unit test for the /sendjson endpoint. On line 03 you see the name of the package is different from the other tests.',
          ],
          [
            1,
            '[ap 09:20] Go in Action - William Kennedy.epub (kindle_split_017.html) - 9.20',
            "Listing <<9.20|5a:0>>. handlers/handlers_test.go: lines 01\x{2013}03
      
      01 // Sample test to show how to test the execution of an
02 // internal endpoint.
03 package handlers_test
      
      This time, as you can see in listing <<9.20|5a:0>>, the package name also ends with _test. When the package name ends like this, the test code can only access exported identifiers. This is true even if the test
         code file is in the same folder as the code being tested.",
          ],
          [
            1,
            '[ap 09:21] Go in Action - William Kennedy.epub (kindle_split_017.html) - 9.21',
            "Listing <<9.21|5a:0>>. handlers/handlers_test.go: lines 17\x{2013}19
      
      17 func init() {
18     handlers.Routes()
19 }
      
      On line 17 in listing <<9.21|5a:0>>, an init function is declared to initialize the routes. If the routes aren\x{2019}t initialized before the unit tests are run, then the tests
         will fail with an http.StatusNotFound error. Now we can look at the unit test for the /sendjson endpoint.",
          ],
          [
            1,
            '[ap 09:22] Go in Action - William Kennedy.epub (kindle_split_017.html) - 9.22',
            "Listing <<9.22|5a:0>>. handlers/handlers_test.go: lines 21\x{2013}34
      
      21 // TestSendJSON testing the sendjson internal endpoint.
22 func TestSendJSON(t *testing.T) {
23     t.Log(\"Given the need to test the SendJSON endpoint.\")
24     {
25         req, err := http.NewRequest(\"GET\", \"/sendjson\", nil)
26         if err != nil {
27             t.Fatal(\"\\tShould be able to create a request.\",
28                 ballotX, err)
29         }
30         t.Log(\"\\tShould be able to create a request.\",
31             checkMark)
32
33         rw := httptest.NewRecorder()
34         http.DefaultServeMux.ServeHTTP(rw, req)
      
      Listing <<9.22|5a:0>> shows the declaration of the TestSendJSON test function. The test starts off logging the given need of the test, and then on line 25 it creates an http.Request value. The request value is configured to be a GET call against the /sendjson endpoint. Since this is a GET call, nil is passed as the third parameter for the post data.",
          ],
          [
            1,
            '[ap 09:23] Go in Action - William Kennedy.epub (kindle_split_017.html) - 9.23',
            "Listing <<9.23|5a:0>>. handlers/handlers_test.go: lines 36\x{2013}39
      
      36         if rw.Code != 200 {
37             t.Fatal(\"\\tShould receive \\\"200\\\"\", ballotX, rw.Code)
38         }
39         t.Log(\"\\tShould receive \\\"200\\\"\", checkMark)
      
      First, the status of the response is checked on line 36. With any successful endpoint call, a status of 200 is expected. If
         the status is 200, then the JSON response is decoded into a Go value.",
          ],
          [
            1,
            '[ap 09:24] Go in Action - William Kennedy.epub (kindle_split_017.html) - 9.24',
            "Listing <<9.24|5a:0>>. handlers/handlers_test.go: lines 41\x{2013}49
      
      41         u := struct {
42             Name  string
43             Email string
44         }{}
45
46         if err := json.NewDecoder(rw.Body).Decode(&u); err != nil {
47             t.Fatal(\"\\tShould decode the response.\", ballotX)
48         }
49         t.Log(\"\\tShould decode the response.\", checkMark)
      
      On line 41 in listing <<9.24|5a:0>>, an anonymous struct type is declared, and a variable named u is created and initialized to its zero value. On line 46 the json package is used to decode the JSON document from the response into the u variable. If the decode fails, the unit test is ended; otherwise, we validate the values that were decoded.",
          ],
          [
            1,
            '[ap 09:25] Go in Action - William Kennedy.epub (kindle_split_017.html) - 9.25',
            "Listing <<9.25|5a:0>>. handlers/handlers_test.go: lines 51\x{2013}63
      
      51         if u.Name == \"Bill\" {
52           t.Log(\"\\tShould have a Name.\", checkMark)
53         } else {
54           t.Error(\"\\tShould have a Name.\", ballotX, u.Name)
55         }
56
57         if u.Email == \"bill\@ardanstudios.com\" {
58             t.Log(\"\\tShould have an Email.\", checkMark)
59         } else {
60             t.Error(\"\\tShould have an Email.\", ballotX, u.Email)
61         }
62     }
63 }
      
      Listing <<9.25|5a:0>> shows both checks for each value we expect to receive. On line 51 we check that the value of the Name field is \"Bill\", and then on line 57 the value of the Email field is checked for \"bill\@ardanstudios.com\". If these values match, then the unit test passes; otherwise, the unit test fails. These two checks use the Error method to report failure, so all the fields are checked.",
          ],
          [
            1,
            '[ap 09:26] Go in Action - William Kennedy.epub (kindle_split_017.html) - 9.26',
            'Listing <<9.26|5a:0>>. handlers_example_test.go
      
      01 // Sample test to show how to write a basic example.
02 package handlers_test
03
04 import (
05     "encoding/json"
06     "fmt"
07     "log"

08     "net/http"
09     "net/http/httptest"
10 )
11
12 // ExampleSendJSON provides a basic example.
13 func ExampleSendJSON() {
14     r, _ := http.NewRequest("GET", "/sendjson", nil)
15     rw := httptest.NewRecorder()
16     http.DefaultServeMux.ServeHTTP(rw, r)
17
18     var u struct {
19         Name  string
20         Email string
21     }
22
23     if err := json.NewDecoder(w.Body).Decode(&u); err != nil {
24         log.Println("ERROR:", err)
25     }
26
27     // Use fmt to write to stdout to check the output.
28     fmt.Println(u)
29     // Output:
30     // {Bill bill@ardanstudios.com}
31 }
      
      Examples are based on existing functions or methods. Instead of starting the function with the word Test, we need to use the word Example. On line 13 in listing <<9.26|5a:0>>, the name of the example is ExampleSendJSON.',
          ],
          [
            1,
            '[ap 09:27] Go in Action - William Kennedy.epub (kindle_split_017.html) - 9.27',
            "Listing <<9.27|5a:0>>. handlers_example_test.go: lines 27\x{2013}31
      
      27     // Use fmt to write to stdout to check the output.
28     fmt.Println(u)
29     // Output:
30     // {Bill bill\@ardanstudios.com}
31 }
      
      On line 28 in listing <<9.27|5a:0>>, the code uses fmt.Println to write the value of u to stdout. The value of u is initialized from making a call to the /sendjson endpoint earlier in the function. On line 29 we have a comment with the word Output:.",
          ],
          [
            1,
            '[ap 09:28] Go in Action - William Kennedy.epub (kindle_split_017.html) - 9.28',
            "Listing <<9.28|5a:0>>. listing28_test.go: lines 01\x{2013}10
      
      01 // Sample benchmarks to test which function is better for converting
02 // an integer into a string. First using the fmt.Sprintf function,
03 // then the strconv.FormatInt function and then strconv.Itoa.

04 package listing28_test
05
06 import (
07     \"fmt\"
08     \"strconv\"
09     \"testing\"
10 )
      
      Listing <<9.28|5a:0>> shows the initial code for the listing28_test.go benchmarks. As with unit test files, the file name must end in _test.go.
         The testing package must also be imported. Next, let\x{2019}s look at one of the benchmark functions.",
          ],
          [
            1,
            '[ap 09:29] Go in Action - William Kennedy.epub (kindle_split_017.html) - 9.29',
            "Listing <<9.29|5a:0>>. listing28_test.go: lines 12\x{2013}22
      
      12 // BenchmarkSprintf provides performance numbers for the
13 // fmt.Sprintf function.
14 func BenchmarkSprintf(b *testing.B) {
15     number := 10
16
17     b.ResetTimer()
18
19     for i := 0; i < b.N; i++ {
20         fmt.Sprintf(\"%d\", number)
21     }
22 }
      
      On line 14 in listing <<9.29|5a:0>>, you see the first benchmark, named BenchmarkSprintf. Benchmark functions begin with the word Benchmark and take as their only parameter a pointer of type testing.B. In order for the benchmarking framework to calculate performance, it must run the code over and over again for a period
         of time. This is where the for loop comes in.",
          ],
          [
            1,
            '[ap 09:30] Go in Action - William Kennedy.epub (kindle_split_017.html) - 9.30',
            "Listing <<9.30|5a:0>>. listing28_test.go: lines 19\x{2013}22
      
      19     for i := 0; i < b.N; i++ {
20         fmt.Sprintf(\"%d\", number)
21     }
22 }
      
      The for loop on line 19 in listing <<9.30|5a:0>> shows how to use the b.N value. On line 20 we have the call to the Sprintf function from the fmt package. This is the function we\x{2019}re benchmarking to convert an integer value into a string.",
          ],
          [
            1,
            '[ap 09:31] Go in Action - William Kennedy.epub (kindle_split_017.html) - 9.31',
            "Listing <<9.31|5a:0>>. Running the benchmark test
      
      go test -v -run=\"none\" -bench=\"BenchmarkSprintf\"
      
      In our call to go test, we specified the -run option passing the string \"none\" to make sure no unit tests are run prior to running the specified benchmark function. Both of these options take a regular
         expression to filter the tests to run. Since there\x{2019}s no unit test function that has none in its name, none eliminates any unit tests from running. When we issue this command, we get the output shown in figure 9.14.",
          ],
          [
            1,
            '[ap 09:32] Go in Action - William Kennedy.epub (kindle_split_017.html) - 9.32',
            "Listing <<9.32|5a:0>>. listing28_test.go: lines 24\x{2013}46
      
      24 // BenchmarkFormat provides performance numbers for the
25 // strconv.FormatInt function.
26 func BenchmarkFormat(b *testing.B) {
27     number := int64(10)
28
29     b.ResetTimer()
30
31     for i := 0; i < b.N; i++ {
32         strconv.FormatInt(number, 10)
33     }
34 }
35
36 // BenchmarkItoa provides performance numbers for the
37 // strconv.Itoa function.
38 func BenchmarkItoa(b *testing.B) {
39     number := 10
40
41     b.ResetTimer()
42
43     for i := 0; i < b.N; i++ {
44         strconv.Itoa(number)
45     }
46 }
      
      Listing <<9.32|5a:0>> shows the other two benchmark functions. The BenchmarkFormat function benchmarks the use of the FormatInt function from the strconv package. The BenchmarkItoa function benchmarks the use of the Itoa function from the same strconv package. You can see the same pattern in these two other benchmark functions as in the BenchmarkSprintf function. The call is inside the for loop using b.N to control the number of iterations for each call.",
          ],
          [
            1,
            '[ap 02:10] Go in Action - William Kennedy.epub (kindle_split_020.html) - 2.10',
            "Listing\x{a0}2.9. GOROOT and GOPATH environmental variables
Listing\x{a0}<<2.10|5a:0>>. search/search.go: lines 08\x{2013}09
Listing\x{a0}<<2.11|5a:0>>. Making a map",
          ],
          [
            1,
            '[ap 02:10] Go in Action - William Kennedy.epub (kindle_split_020.html) - 2.10',
            "Listing\x{a0}<<2.10|5a:0>>. search/search.go: lines 08\x{2013}09
Listing\x{a0}<<2.11|5a:0>>. Making a map
Listing\x{a0}<<2.12|5a:0>>. search/search.go: lines 11\x{2013}57",
          ],
          [
            1,
            '[ap 02:11] Go in Action - William Kennedy.epub (kindle_split_020.html) - 2.11',
            "Listing\x{a0}<<2.11|5a:0>>. Making a map
Listing\x{a0}<<2.12|5a:0>>. search/search.go: lines 11\x{2013}57
Listing\x{a0}<<2.13|5a:0>>. search/search.go: lines 11\x{2013}12",
          ],
          [
            1,
            '[ap 02:12] Go in Action - William Kennedy.epub (kindle_split_020.html) - 2.12',
            "Listing\x{a0}<<2.12|5a:0>>. search/search.go: lines 11\x{2013}57
Listing\x{a0}<<2.13|5a:0>>. search/search.go: lines 11\x{2013}12
Listing\x{a0}<<2.14|5a:0>>. main.go: lines 17\x{2013}21",
          ],
          [
            1,
            '[ap 02:13] Go in Action - William Kennedy.epub (kindle_split_020.html) - 2.13',
            "Listing\x{a0}<<2.13|5a:0>>. search/search.go: lines 11\x{2013}12
Listing\x{a0}<<2.14|5a:0>>. main.go: lines 17\x{2013}21
Listing\x{a0}<<2.15|5a:0>>. search/search.go: lines 13\x{2013}17",
          ],
          [
            1,
            '[ap 02:14] Go in Action - William Kennedy.epub (kindle_split_020.html) - 2.14',
            "Listing\x{a0}<<2.14|5a:0>>. main.go: lines 17\x{2013}21
Listing\x{a0}<<2.15|5a:0>>. search/search.go: lines 13\x{2013}17
Listing\x{a0}<<2.16|5a:0>>. search/search.go: lines 13\x{2013}14",
          ],
          [
            1,
            '[ap 02:15] Go in Action - William Kennedy.epub (kindle_split_020.html) - 2.15',
            "Listing\x{a0}<<2.15|5a:0>>. search/search.go: lines 13\x{2013}17
Listing\x{a0}<<2.16|5a:0>>. search/search.go: lines 13\x{2013}14
Listing\x{a0}<<2.17|5a:0>>. search/search.go: lines 19\x{2013}20",
          ],
          [
            1,
            '[ap 02:16] Go in Action - William Kennedy.epub (kindle_split_020.html) - 2.16',
            "Listing\x{a0}<<2.16|5a:0>>. search/search.go: lines 13\x{2013}14
Listing\x{a0}<<2.17|5a:0>>. search/search.go: lines 19\x{2013}20
Listing\x{a0}<<2.18|5a:0>>. search/search.go: lines 22\x{2013}27",
          ],
          [
            1,
            '[ap 02:17] Go in Action - William Kennedy.epub (kindle_split_020.html) - 2.17',
            "Listing\x{a0}<<2.17|5a:0>>. search/search.go: lines 19\x{2013}20
Listing\x{a0}<<2.18|5a:0>>. search/search.go: lines 22\x{2013}27
Listing\x{a0}<<2.19|5a:0>>. search/search.go: lines 29\x{2013}42",
          ],
          [
            1,
            '[ap 02:18] Go in Action - William Kennedy.epub (kindle_split_020.html) - 2.18',
            "Listing\x{a0}<<2.18|5a:0>>. search/search.go: lines 22\x{2013}27
Listing\x{a0}<<2.19|5a:0>>. search/search.go: lines 29\x{2013}42
Listing\x{a0}<<2.20|5a:0>>. search/search.go: lines 29\x{2013}30",
          ],
          [
            1,
            '[ap 02:19] Go in Action - William Kennedy.epub (kindle_split_020.html) - 2.19',
            "Listing\x{a0}<<2.19|5a:0>>. search/search.go: lines 29\x{2013}42
Listing\x{a0}<<2.20|5a:0>>. search/search.go: lines 29\x{2013}30
Listing\x{a0}<<2.21|5a:0>>. search/search.go: lines 31\x{2013}35",
          ],
          [
            1,
            '[ap 02:20] Go in Action - William Kennedy.epub (kindle_split_020.html) - 2.20',
            "Listing\x{a0}<<2.20|5a:0>>. search/search.go: lines 29\x{2013}30
Listing\x{a0}<<2.21|5a:0>>. search/search.go: lines 31\x{2013}35
Listing\x{a0}<<2.22|5a:0>>. search/search.go: lines 37\x{2013}41",
          ],
          [
            1,
            '[ap 02:21] Go in Action - William Kennedy.epub (kindle_split_020.html) - 2.21',
            "Listing\x{a0}<<2.21|5a:0>>. search/search.go: lines 31\x{2013}35
Listing\x{a0}<<2.22|5a:0>>. search/search.go: lines 37\x{2013}41
Listing\x{a0}<<2.23|5a:0>>. search/search.go: lines 39\x{2013}40",
          ],
          [
            1,
            '[ap 02:22] Go in Action - William Kennedy.epub (kindle_split_020.html) - 2.22',
            "Listing\x{a0}<<2.22|5a:0>>. search/search.go: lines 37\x{2013}41
Listing\x{a0}<<2.23|5a:0>>. search/search.go: lines 39\x{2013}40
Listing\x{a0}<<2.24|5a:0>>. search/search.go: lines 29\x{2013}32",
          ],
          [
            1,
            '[ap 02:23] Go in Action - William Kennedy.epub (kindle_split_020.html) - 2.23',
            "Listing\x{a0}<<2.23|5a:0>>. search/search.go: lines 39\x{2013}40
Listing\x{a0}<<2.24|5a:0>>. search/search.go: lines 29\x{2013}32
Listing\x{a0}<<2.25|5a:0>>. search/search.go: lines 44\x{2013}57",
          ],
          [
            1,
            '[ap 02:24] Go in Action - William Kennedy.epub (kindle_split_020.html) - 2.24',
            "Listing\x{a0}<<2.24|5a:0>>. search/search.go: lines 29\x{2013}32
Listing\x{a0}<<2.25|5a:0>>. search/search.go: lines 44\x{2013}57
Listing\x{a0}<<2.26|5a:0>>. feed.go: lines 01\x{2013}08",
          ],
          [
            1,
            '[ap 02:25] Go in Action - William Kennedy.epub (kindle_split_020.html) - 2.25',
            "Listing\x{a0}<<2.25|5a:0>>. search/search.go: lines 44\x{2013}57
Listing\x{a0}<<2.26|5a:0>>. feed.go: lines 01\x{2013}08
Listing\x{a0}<<2.27|5a:0>>. data.json",
          ],
          [
            1,
            '[ap 02:26] Go in Action - William Kennedy.epub (kindle_split_020.html) - 2.26',
            "Listing\x{a0}<<2.26|5a:0>>. feed.go: lines 01\x{2013}08
Listing\x{a0}<<2.27|5a:0>>. data.json
Listing\x{a0}<<2.28|5a:0>>. feed.go: lines 10\x{2013}15",
          ],
          [
            1,
            '[ap 02:27] Go in Action - William Kennedy.epub (kindle_split_020.html) - 2.27',
            "Listing\x{a0}<<2.27|5a:0>>. data.json
Listing\x{a0}<<2.28|5a:0>>. feed.go: lines 10\x{2013}15
Listing\x{a0}<<2.29|5a:0>>. feed.go: lines 17\x{2013}36",
          ],
          [
            1,
            '[ap 02:28] Go in Action - William Kennedy.epub (kindle_split_020.html) - 2.28',
            "Listing\x{a0}<<2.28|5a:0>>. feed.go: lines 10\x{2013}15
Listing\x{a0}<<2.29|5a:0>>. feed.go: lines 17\x{2013}36
Listing\x{a0}<<2.30|5a:0>>. feed.go: lines 25\x{2013}27",
          ],
          [
            1,
            '[ap 02:29] Go in Action - William Kennedy.epub (kindle_split_020.html) - 2.29',
            "Listing\x{a0}<<2.29|5a:0>>. feed.go: lines 17\x{2013}36
Listing\x{a0}<<2.30|5a:0>>. feed.go: lines 25\x{2013}27
Listing\x{a0}<<2.31|5a:0>>. feed.go: lines 29\x{2013}36",
          ],
          [
            1,
            '[ap 02:30] Go in Action - William Kennedy.epub (kindle_split_020.html) - 2.30',
            "Listing\x{a0}<<2.30|5a:0>>. feed.go: lines 25\x{2013}27
Listing\x{a0}<<2.31|5a:0>>. feed.go: lines 29\x{2013}36
Listing\x{a0}<<2.32|5a:0>>. Using the empty interface",
          ],
          [
            1,
            '[ap 02:31] Go in Action - William Kennedy.epub (kindle_split_020.html) - 2.31',
            "Listing\x{a0}<<2.31|5a:0>>. feed.go: lines 29\x{2013}36
Listing\x{a0}<<2.32|5a:0>>. Using the empty interface
Listing\x{a0}<<2.33|5a:0>>. search/search.go : lines 29 - 42",
          ],
          [
            1,
            '[ap 02:32] Go in Action - William Kennedy.epub (kindle_split_020.html) - 2.32',
            "Listing\x{a0}<<2.32|5a:0>>. Using the empty interface
Listing\x{a0}<<2.33|5a:0>>. search/search.go : lines 29 - 42
Listing\x{a0}<<2.34|5a:0>>. search/match.go: lines 01\x{2013}17",
          ],
          [
            1,
            '[ap 02:33] Go in Action - William Kennedy.epub (kindle_split_020.html) - 2.33',
            "Listing\x{a0}<<2.33|5a:0>>. search/search.go : lines 29 - 42
Listing\x{a0}<<2.34|5a:0>>. search/match.go: lines 01\x{2013}17
Listing\x{a0}<<2.35|5a:0>>. search/default.go: lines 01\x{2013}15",
          ],
          [
            1,
            '[ap 02:34] Go in Action - William Kennedy.epub (kindle_split_020.html) - 2.34',
            "Listing\x{a0}<<2.34|5a:0>>. search/match.go: lines 01\x{2013}17
Listing\x{a0}<<2.35|5a:0>>. search/default.go: lines 01\x{2013}15
Listing\x{a0}<<2.36|5a:0>>. search/default.go: line 13",
          ],
          [
            1,
            '[ap 02:35] Go in Action - William Kennedy.epub (kindle_split_020.html) - 2.35',
            "Listing\x{a0}<<2.35|5a:0>>. search/default.go: lines 01\x{2013}15
Listing\x{a0}<<2.36|5a:0>>. search/default.go: line 13
Listing\x{a0}<<2.37|5a:0>>. Example of method calls",
          ],
          [
            1,
            '[ap 02:36] Go in Action - William Kennedy.epub (kindle_split_020.html) - 2.36',
            "Listing\x{a0}<<2.36|5a:0>>. search/default.go: line 13
Listing\x{a0}<<2.37|5a:0>>. Example of method calls
Listing\x{a0}<<2.38|5a:0>>. Example of interface method call restrictions",
          ],
          [
            1,
            '[ap 02:37] Go in Action - William Kennedy.epub (kindle_split_020.html) - 2.37',
            "Listing\x{a0}<<2.37|5a:0>>. Example of method calls
Listing\x{a0}<<2.38|5a:0>>. Example of interface method call restrictions
Listing\x{a0}<<2.39|5a:0>>. search/match.go: lines 19\x{2013}33",
          ],
          [
            1,
            '[ap 02:38] Go in Action - William Kennedy.epub (kindle_split_020.html) - 2.38',
            "Listing\x{a0}<<2.38|5a:0>>. Example of interface method call restrictions
Listing\x{a0}<<2.39|5a:0>>. search/match.go: lines 19\x{2013}33
Listing\x{a0}<<2.40|5a:0>>. search/match.go: lines 35\x{2013}43",
          ],
          [
            1,
            '[ap 02:39] Go in Action - William Kennedy.epub (kindle_split_020.html) - 2.39',
            "Listing\x{a0}<<2.39|5a:0>>. search/match.go: lines 19\x{2013}33
Listing\x{a0}<<2.40|5a:0>>. search/match.go: lines 35\x{2013}43
Listing\x{a0}<<2.41|5a:0>>. search/search.go: lines 44\x{2013}57",
          ],
          [
            1,
            '[ap 02:40] Go in Action - William Kennedy.epub (kindle_split_020.html) - 2.40',
            "Listing\x{a0}<<2.40|5a:0>>. search/match.go: lines 35\x{2013}43
Listing\x{a0}<<2.41|5a:0>>. search/search.go: lines 44\x{2013}57
Listing\x{a0}<<2.42|5a:0>>. search/match.go: lines 29\x{2013}32",
          ],
          [
            1,
            '[ap 02:41] Go in Action - William Kennedy.epub (kindle_split_020.html) - 2.41',
            "Listing\x{a0}<<2.41|5a:0>>. search/search.go: lines 44\x{2013}57
Listing\x{a0}<<2.42|5a:0>>. search/match.go: lines 29\x{2013}32
Listing\x{a0}<<2.43|5a:0>>. search/match.go: lines 38\x{2013}42",
          ],
          [
            1,
            '[ap 02:42] Go in Action - William Kennedy.epub (kindle_split_020.html) - 2.42',
            "Listing\x{a0}<<2.42|5a:0>>. search/match.go: lines 29\x{2013}32
Listing\x{a0}<<2.43|5a:0>>. search/match.go: lines 38\x{2013}42
Listing\x{a0}<<2.44|5a:0>>. search/default.go: lines 06\x{2013}10",
          ],
          [
            1,
            '[ap 02:43] Go in Action - William Kennedy.epub (kindle_split_020.html) - 2.43',
            "Listing\x{a0}<<2.43|5a:0>>. search/match.go: lines 38\x{2013}42
Listing\x{a0}<<2.44|5a:0>>. search/default.go: lines 06\x{2013}10
Listing\x{a0}<<2.45|5a:0>>. main.go: lines 07\x{2013}08",
          ],
          [
            1,
            '[ap 02:44] Go in Action - William Kennedy.epub (kindle_split_020.html) - 2.44',
            "Listing\x{a0}<<2.44|5a:0>>. search/default.go: lines 06\x{2013}10
Listing\x{a0}<<2.45|5a:0>>. main.go: lines 07\x{2013}08
Listing\x{a0}<<2.46|5a:0>>. search/search.go: lines 59\x{2013}67",
          ],
          [
            1,
            '[ap 02:45] Go in Action - William Kennedy.epub (kindle_split_020.html) - 2.45',
            "Listing\x{a0}<<2.45|5a:0>>. main.go: lines 07\x{2013}08
Listing\x{a0}<<2.46|5a:0>>. search/search.go: lines 59\x{2013}67
Listing\x{a0}<<2.47|5a:0>>. Expected RSS feed document",
          ],
          [
            1,
            '[ap 02:46] Go in Action - William Kennedy.epub (kindle_split_020.html) - 2.46',
            "Listing\x{a0}<<2.46|5a:0>>. search/search.go: lines 59\x{2013}67
Listing\x{a0}<<2.47|5a:0>>. Expected RSS feed document
Listing\x{a0}<<2.48|5a:0>>. matchers/rss.go: lines 01\x{2013}12",
          ],
          [
            1,
            '[ap 02:47] Go in Action - William Kennedy.epub (kindle_split_020.html) - 2.47',
            "Listing\x{a0}<<2.47|5a:0>>. Expected RSS feed document
Listing\x{a0}<<2.48|5a:0>>. matchers/rss.go: lines 01\x{2013}12
Listing\x{a0}<<2.49|5a:0>>. matchers/rss.go: lines 14\x{2013}58",
          ],
          [
            1,
            '[ap 02:48] Go in Action - William Kennedy.epub (kindle_split_020.html) - 2.48',
            "Listing\x{a0}<<2.48|5a:0>>. matchers/rss.go: lines 01\x{2013}12
Listing\x{a0}<<2.49|5a:0>>. matchers/rss.go: lines 14\x{2013}58
Listing\x{a0}<<2.50|5a:0>>. matchers/rss.go: lines 60\x{2013}61",
          ],
          [
            1,
            '[ap 02:49] Go in Action - William Kennedy.epub (kindle_split_020.html) - 2.49',
            "Listing\x{a0}<<2.49|5a:0>>. matchers/rss.go: lines 14\x{2013}58
Listing\x{a0}<<2.50|5a:0>>. matchers/rss.go: lines 60\x{2013}61
Listing\x{a0}<<2.51|5a:0>>. matchers/rss.go: lines 63\x{2013}67",
          ],
          [
            1,
            '[ap 02:50] Go in Action - William Kennedy.epub (kindle_split_020.html) - 2.50',
            "Listing\x{a0}<<2.50|5a:0>>. matchers/rss.go: lines 60\x{2013}61
Listing\x{a0}<<2.51|5a:0>>. matchers/rss.go: lines 63\x{2013}67
Listing\x{a0}<<2.52|5a:0>>. main.go: lines 07\x{2013}08",
          ],
          [
            1,
            '[ap 02:51] Go in Action - William Kennedy.epub (kindle_split_020.html) - 2.51',
            "Listing\x{a0}<<2.51|5a:0>>. matchers/rss.go: lines 63\x{2013}67
Listing\x{a0}<<2.52|5a:0>>. main.go: lines 07\x{2013}08
Listing\x{a0}<<2.53|5a:0>>. matchers/rss.go: lines 114\x{2013}140",
          ],
          [
            1,
            '[ap 02:52] Go in Action - William Kennedy.epub (kindle_split_020.html) - 2.52',
            "Listing\x{a0}<<2.52|5a:0>>. main.go: lines 07\x{2013}08
Listing\x{a0}<<2.53|5a:0>>. matchers/rss.go: lines 114\x{2013}140
Listing\x{a0}<<2.54|5a:0>>. matchers/rss.go: lines 69\x{2013}112",
          ],
          [
            1,
            '[ap 02:53] Go in Action - William Kennedy.epub (kindle_split_020.html) - 2.53',
            "Listing\x{a0}<<2.53|5a:0>>. matchers/rss.go: lines 114\x{2013}140
Listing\x{a0}<<2.54|5a:0>>. matchers/rss.go: lines 69\x{2013}112
Listing\x{a0}<<2.55|5a:0>>. matchers/rss.go: line 71",
          ],
          [
            1,
            '[ap 02:54] Go in Action - William Kennedy.epub (kindle_split_020.html) - 2.54',
            "Listing\x{a0}<<2.54|5a:0>>. matchers/rss.go: lines 69\x{2013}112
Listing\x{a0}<<2.55|5a:0>>. matchers/rss.go: line 71
Listing\x{a0}<<2.56|5a:0>>. matchers/rss.go: lines 75\x{2013}79",
          ],
          [
            1,
            '[ap 02:55] Go in Action - William Kennedy.epub (kindle_split_020.html) - 2.55',
            "Listing\x{a0}<<2.55|5a:0>>. matchers/rss.go: line 71
Listing\x{a0}<<2.56|5a:0>>. matchers/rss.go: lines 75\x{2013}79
Listing\x{a0}<<2.57|5a:0>>. matchers/rss.go: lines 81\x{2013}86",
          ],
          [
            1,
            '[ap 02:56] Go in Action - William Kennedy.epub (kindle_split_020.html) - 2.56',
            "Listing\x{a0}<<2.56|5a:0>>. matchers/rss.go: lines 75\x{2013}79
Listing\x{a0}<<2.57|5a:0>>. matchers/rss.go: lines 81\x{2013}86
Listing\x{a0}<<2.58|5a:0>>. matchers/rss.go: lines 88\x{2013}94",
          ],
          [
            1,
            '[ap 02:57] Go in Action - William Kennedy.epub (kindle_split_020.html) - 2.57',
            "Listing\x{a0}<<2.57|5a:0>>. matchers/rss.go: lines 81\x{2013}86
Listing\x{a0}<<2.58|5a:0>>. matchers/rss.go: lines 88\x{2013}94
Chapter 3. Packaging and tooling",
          ],
          [
            1,
            '[ap 03:10] Go in Action - William Kennedy.epub (kindle_split_020.html) - 3.10',
            "Listing\x{a0}3.9. Project using godep
Listing\x{a0}<<3.10|5a:0>>. Before vendoring
Listing\x{a0}<<3.11|5a:0>>. After vendoring",
          ],
          [
            1,
            '[ap 03:10] Go in Action - William Kennedy.epub (kindle_split_020.html) - 3.10',
            "Listing\x{a0}<<3.10|5a:0>>. Before vendoring
Listing\x{a0}<<3.11|5a:0>>. After vendoring
Listing\x{a0}<<3.12|5a:0>>. Example of a gb project",
          ],
          [
            1,
            '[ap 03:11] Go in Action - William Kennedy.epub (kindle_split_020.html) - 3.11',
            "Listing\x{a0}<<3.11|5a:0>>. After vendoring
Listing\x{a0}<<3.12|5a:0>>. Example of a gb project
Listing\x{a0}<<3.13|5a:0>>. The location for the code you write for the project",
          ],
          [
            1,
            '[ap 03:12] Go in Action - William Kennedy.epub (kindle_split_020.html) - 3.12',
            "Listing\x{a0}<<3.12|5a:0>>. Example of a gb project
Listing\x{a0}<<3.13|5a:0>>. The location for the code you write for the project
Listing\x{a0}<<3.14|5a:0>>. The location of vendored code",
          ],
          [
            1,
            '[ap 03:13] Go in Action - William Kennedy.epub (kindle_split_020.html) - 3.13',
            "Listing\x{a0}<<3.13|5a:0>>. The location for the code you write for the project
Listing\x{a0}<<3.14|5a:0>>. The location of vendored code
Listing\x{a0}<<3.15|5a:0>>. Import paths for gb projects",
          ],
          [
            1,
            '[ap 03:14] Go in Action - William Kennedy.epub (kindle_split_020.html) - 3.14',
            "Listing\x{a0}<<3.14|5a:0>>. The location of vendored code
Listing\x{a0}<<3.15|5a:0>>. Import paths for gb projects
Listing\x{a0}<<3.16|5a:0>>. Building a gb project",
          ],
          [
            1,
            '[ap 03:15] Go in Action - William Kennedy.epub (kindle_split_020.html) - 3.15',
            "Listing\x{a0}<<3.15|5a:0>>. Import paths for gb projects
Listing\x{a0}<<3.16|5a:0>>. Building a gb project
Chapter 4. Arrays, slices, and maps",
          ],
          [
            1,
            '[ap 04:10] Go in Action - William Kennedy.epub (kindle_split_020.html) - 4.10',
            "Listing\x{a0}4.9. Assigning one array of pointers to another
Listing\x{a0}<<4.10|5a:0>>. Declaring two-dimensional arrays
Listing\x{a0}<<4.11|5a:0>>. Accessing elements of a two-dimensional array",
          ],
          [
            1,
            '[ap 04:10] Go in Action - William Kennedy.epub (kindle_split_020.html) - 4.10',
            "Listing\x{a0}<<4.10|5a:0>>. Declaring two-dimensional arrays
Listing\x{a0}<<4.11|5a:0>>. Accessing elements of a two-dimensional array
Listing\x{a0}<<4.12|5a:0>>. Assigning multidimensional arrays of the same type",
          ],
          [
            1,
            '[ap 04:11] Go in Action - William Kennedy.epub (kindle_split_020.html) - 4.11',
            "Listing\x{a0}<<4.11|5a:0>>. Accessing elements of a two-dimensional array
Listing\x{a0}<<4.12|5a:0>>. Assigning multidimensional arrays of the same type
Listing\x{a0}<<4.13|5a:0>>. Assigning multidimensional arrays by index",
          ],
          [
            1,
            '[ap 04:12] Go in Action - William Kennedy.epub (kindle_split_020.html) - 4.12',
            "Listing\x{a0}<<4.12|5a:0>>. Assigning multidimensional arrays of the same type
Listing\x{a0}<<4.13|5a:0>>. Assigning multidimensional arrays by index
Listing\x{a0}<<4.14|5a:0>>. Passing a large array by value between functions",
          ],
          [
            1,
            '[ap 04:13] Go in Action - William Kennedy.epub (kindle_split_020.html) - 4.13',
            "Listing\x{a0}<<4.13|5a:0>>. Assigning multidimensional arrays by index
Listing\x{a0}<<4.14|5a:0>>. Passing a large array by value between functions
Listing\x{a0}<<4.15|5a:0>>. Passing a large array by pointer between functions",
          ],
          [
            1,
            '[ap 04:14] Go in Action - William Kennedy.epub (kindle_split_020.html) - 4.14',
            "Listing\x{a0}<<4.14|5a:0>>. Passing a large array by value between functions
Listing\x{a0}<<4.15|5a:0>>. Passing a large array by pointer between functions
Listing\x{a0}<<4.16|5a:0>>. Declaring a slice of strings by length",
          ],
          [
            1,
            '[ap 04:15] Go in Action - William Kennedy.epub (kindle_split_020.html) - 4.15',
            "Listing\x{a0}<<4.15|5a:0>>. Passing a large array by pointer between functions
Listing\x{a0}<<4.16|5a:0>>. Declaring a slice of strings by length
Listing\x{a0}<<4.17|5a:0>>. Declaring a slice of integers by length and capacity",
          ],
          [
            1,
            '[ap 04:16] Go in Action - William Kennedy.epub (kindle_split_020.html) - 4.16',
            "Listing\x{a0}<<4.16|5a:0>>. Declaring a slice of strings by length
Listing\x{a0}<<4.17|5a:0>>. Declaring a slice of integers by length and capacity
Listing\x{a0}<<4.18|5a:0>>. Compiler error setting capacity less than length",
          ],
          [
            1,
            '[ap 04:17] Go in Action - William Kennedy.epub (kindle_split_020.html) - 4.17',
            "Listing\x{a0}<<4.17|5a:0>>. Declaring a slice of integers by length and capacity
Listing\x{a0}<<4.18|5a:0>>. Compiler error setting capacity less than length
Listing\x{a0}<<4.19|5a:0>>. Declaring a slice with a slice literal",
          ],
          [
            1,
            '[ap 04:18] Go in Action - William Kennedy.epub (kindle_split_020.html) - 4.18',
            "Listing\x{a0}<<4.18|5a:0>>. Compiler error setting capacity less than length
Listing\x{a0}<<4.19|5a:0>>. Declaring a slice with a slice literal
Listing\x{a0}<<4.20|5a:0>>. Declaring a slice with index positions",
          ],
          [
            1,
            '[ap 04:19] Go in Action - William Kennedy.epub (kindle_split_020.html) - 4.19',
            "Listing\x{a0}<<4.19|5a:0>>. Declaring a slice with a slice literal
Listing\x{a0}<<4.20|5a:0>>. Declaring a slice with index positions
Listing\x{a0}<<4.21|5a:0>>. Declaration differences between arrays and slices",
          ],
          [
            1,
            '[ap 04:20] Go in Action - William Kennedy.epub (kindle_split_020.html) - 4.20',
            "Listing\x{a0}<<4.20|5a:0>>. Declaring a slice with index positions
Listing\x{a0}<<4.21|5a:0>>. Declaration differences between arrays and slices
Listing\x{a0}<<4.22|5a:0>>. Declaring a nil slice",
          ],
          [
            1,
            '[ap 04:21] Go in Action - William Kennedy.epub (kindle_split_020.html) - 4.21',
            "Listing\x{a0}<<4.21|5a:0>>. Declaration differences between arrays and slices
Listing\x{a0}<<4.22|5a:0>>. Declaring a nil slice
Listing\x{a0}<<4.23|5a:0>>. Declaring an empty slice",
          ],
          [
            1,
            '[ap 04:22] Go in Action - William Kennedy.epub (kindle_split_020.html) - 4.22',
            "Listing\x{a0}<<4.22|5a:0>>. Declaring a nil slice
Listing\x{a0}<<4.23|5a:0>>. Declaring an empty slice
Listing\x{a0}<<4.24|5a:0>>. Declaring an array using an array literal",
          ],
          [
            1,
            '[ap 04:23] Go in Action - William Kennedy.epub (kindle_split_020.html) - 4.23',
            "Listing\x{a0}<<4.23|5a:0>>. Declaring an empty slice
Listing\x{a0}<<4.24|5a:0>>. Declaring an array using an array literal
Listing\x{a0}<<4.25|5a:0>>. Taking the slice of a slice",
          ],
          [
            1,
            '[ap 04:24] Go in Action - William Kennedy.epub (kindle_split_020.html) - 4.24',
            "Listing\x{a0}<<4.24|5a:0>>. Declaring an array using an array literal
Listing\x{a0}<<4.25|5a:0>>. Taking the slice of a slice
Listing\x{a0}<<4.26|5a:0>>. How length and capacity are calculated",
          ],
          [
            1,
            '[ap 04:25] Go in Action - William Kennedy.epub (kindle_split_020.html) - 4.25',
            "Listing\x{a0}<<4.25|5a:0>>. Taking the slice of a slice
Listing\x{a0}<<4.26|5a:0>>. How length and capacity are calculated
Listing\x{a0}<<4.27|5a:0>>. Calculating the new length and capacity",
          ],
          [
            1,
            '[ap 04:26] Go in Action - William Kennedy.epub (kindle_split_020.html) - 4.26',
            "Listing\x{a0}<<4.26|5a:0>>. How length and capacity are calculated
Listing\x{a0}<<4.27|5a:0>>. Calculating the new length and capacity
Listing\x{a0}<<4.28|5a:0>>. Potential consequence of making changes to a slice",
          ],
          [
            1,
            '[ap 04:27] Go in Action - William Kennedy.epub (kindle_split_020.html) - 4.27',
            "Listing\x{a0}<<4.27|5a:0>>. Calculating the new length and capacity
Listing\x{a0}<<4.28|5a:0>>. Potential consequence of making changes to a slice
Listing\x{a0}<<4.29|5a:0>>. Runtime error showing index out of range",
          ],
          [
            1,
            '[ap 04:28] Go in Action - William Kennedy.epub (kindle_split_020.html) - 4.28',
            "Listing\x{a0}<<4.28|5a:0>>. Potential consequence of making changes to a slice
Listing\x{a0}<<4.29|5a:0>>. Runtime error showing index out of range
Listing\x{a0}<<4.30|5a:0>>. Using append to add an element to a slice",
          ],
          [
            1,
            '[ap 04:29] Go in Action - William Kennedy.epub (kindle_split_020.html) - 4.29',
            "Listing\x{a0}<<4.29|5a:0>>. Runtime error showing index out of range
Listing\x{a0}<<4.30|5a:0>>. Using append to add an element to a slice
Listing\x{a0}<<4.31|5a:0>>. Using append to increase the length and capacity of a slice",
          ],
          [
            1,
            '[ap 04:31] Go in Action - William Kennedy.epub (kindle_split_020.html) - 4.31',
            "Listing\x{a0}<<4.31|5a:0>>. Using append to increase the length and capacity of a slice",
          ],
          [
            1,
            '[ap 04:31] Go in Action - William Kennedy.epub (kindle_split_020.html) - 4.31',
            "Listing\x{a0}<<4.31|5a:0>>. Using append to increase the length and capacity of a slice
Listing\x{a0}<<4.32|5a:0>>. Declaring a slice of string using a slice literal
Listing\x{a0}<<4.33|5a:0>>. Performing a three-index slice",
          ],
          [
            1,
            '[ap 04:32] Go in Action - William Kennedy.epub (kindle_split_020.html) - 4.32',
            "Listing\x{a0}<<4.32|5a:0>>. Declaring a slice of string using a slice literal
Listing\x{a0}<<4.33|5a:0>>. Performing a three-index slice
Listing\x{a0}<<4.34|5a:0>>. How length and capacity are calculated",
          ],
          [
            1,
            '[ap 04:33] Go in Action - William Kennedy.epub (kindle_split_020.html) - 4.33',
            "Listing\x{a0}<<4.33|5a:0>>. Performing a three-index slice
Listing\x{a0}<<4.34|5a:0>>. How length and capacity are calculated
Listing\x{a0}<<4.35|5a:0>>. Runtime error setting capacity larger than existing capacity",
          ],
          [
            1,
            '[ap 04:35] Go in Action - William Kennedy.epub (kindle_split_020.html) - 4.35',
            "Listing\x{a0}<<4.35|5a:0>>. Runtime error setting capacity larger than existing capacity",
          ],
          [
            1,
            '[ap 04:35] Go in Action - William Kennedy.epub (kindle_split_020.html) - 4.35',
            "Listing\x{a0}<<4.35|5a:0>>. Runtime error setting capacity larger than existing capacity
Listing\x{a0}<<4.36|5a:0>>. Benefits of setting length and capacity to be the same
Listing\x{a0}<<4.37|5a:0>>. Appending to a slice from another slice",
          ],
          [
            1,
            '[ap 04:36] Go in Action - William Kennedy.epub (kindle_split_020.html) - 4.36',
            "Listing\x{a0}<<4.36|5a:0>>. Benefits of setting length and capacity to be the same
Listing\x{a0}<<4.37|5a:0>>. Appending to a slice from another slice
Listing\x{a0}<<4.38|5a:0>>. Iterating over a slice using for range",
          ],
          [
            1,
            '[ap 04:37] Go in Action - William Kennedy.epub (kindle_split_020.html) - 4.37',
            "Listing\x{a0}<<4.37|5a:0>>. Appending to a slice from another slice
Listing\x{a0}<<4.38|5a:0>>. Iterating over a slice using for range
Listing\x{a0}<<4.39|5a:0>>. range provides a copy of each element",
          ],
          [
            1,
            '[ap 04:38] Go in Action - William Kennedy.epub (kindle_split_020.html) - 4.38',
            "Listing\x{a0}<<4.38|5a:0>>. Iterating over a slice using for range
Listing\x{a0}<<4.39|5a:0>>. range provides a copy of each element
Listing\x{a0}<<4.40|5a:0>>. Using the blank identifier to ignore the index value",
          ],
          [
            1,
            '[ap 04:39] Go in Action - William Kennedy.epub (kindle_split_020.html) - 4.39',
            "Listing\x{a0}<<4.39|5a:0>>. range provides a copy of each element
Listing\x{a0}<<4.40|5a:0>>. Using the blank identifier to ignore the index value
Listing\x{a0}<<4.41|5a:0>>. Iterating over a slice using a traditional for loop",
          ],
          [
            1,
            '[ap 04:40] Go in Action - William Kennedy.epub (kindle_split_020.html) - 4.40',
            "Listing\x{a0}<<4.40|5a:0>>. Using the blank identifier to ignore the index value
Listing\x{a0}<<4.41|5a:0>>. Iterating over a slice using a traditional for loop
Listing\x{a0}<<4.42|5a:0>>. Declaring a multidimensional slice",
          ],
          [
            1,
            '[ap 04:41] Go in Action - William Kennedy.epub (kindle_split_020.html) - 4.41',
            "Listing\x{a0}<<4.41|5a:0>>. Iterating over a slice using a traditional for loop
Listing\x{a0}<<4.42|5a:0>>. Declaring a multidimensional slice
Listing\x{a0}<<4.43|5a:0>>. Composing slices of slices",
          ],
          [
            1,
            '[ap 04:42] Go in Action - William Kennedy.epub (kindle_split_020.html) - 4.42',
            "Listing\x{a0}<<4.42|5a:0>>. Declaring a multidimensional slice
Listing\x{a0}<<4.43|5a:0>>. Composing slices of slices
Listing\x{a0}<<4.44|5a:0>>. Passing slices between functions",
          ],
          [
            1,
            '[ap 04:43] Go in Action - William Kennedy.epub (kindle_split_020.html) - 4.43',
            "Listing\x{a0}<<4.43|5a:0>>. Composing slices of slices
Listing\x{a0}<<4.44|5a:0>>. Passing slices between functions
Listing\x{a0}<<4.45|5a:0>>. Declaring a map using make",
          ],
          [
            1,
            '[ap 04:44] Go in Action - William Kennedy.epub (kindle_split_020.html) - 4.44',
            "Listing\x{a0}<<4.44|5a:0>>. Passing slices between functions
Listing\x{a0}<<4.45|5a:0>>. Declaring a map using make
Listing\x{a0}<<4.46|5a:0>>. Declaring an empty map using a map literal",
          ],
          [
            1,
            '[ap 04:45] Go in Action - William Kennedy.epub (kindle_split_020.html) - 4.45',
            "Listing\x{a0}<<4.45|5a:0>>. Declaring a map using make
Listing\x{a0}<<4.46|5a:0>>. Declaring an empty map using a map literal
Listing\x{a0}<<4.47|5a:0>>. Declaring a map that stores slices of strings",
          ],
          [
            1,
            '[ap 04:46] Go in Action - William Kennedy.epub (kindle_split_020.html) - 4.46',
            "Listing\x{a0}<<4.46|5a:0>>. Declaring an empty map using a map literal
Listing\x{a0}<<4.47|5a:0>>. Declaring a map that stores slices of strings
Listing\x{a0}<<4.48|5a:0>>. Assigning values to a map",
          ],
          [
            1,
            '[ap 04:47] Go in Action - William Kennedy.epub (kindle_split_020.html) - 4.47',
            "Listing\x{a0}<<4.47|5a:0>>. Declaring a map that stores slices of strings
Listing\x{a0}<<4.48|5a:0>>. Assigning values to a map
Listing\x{a0}<<4.49|5a:0>>. Runtime error assigned to a nil map",
          ],
          [
            1,
            '[ap 04:48] Go in Action - William Kennedy.epub (kindle_split_020.html) - 4.48',
            "Listing\x{a0}<<4.48|5a:0>>. Assigning values to a map
Listing\x{a0}<<4.49|5a:0>>. Runtime error assigned to a nil map
Listing\x{a0}<<4.50|5a:0>>. Retrieving a value from a map and testing existence.",
          ],
          [
            1,
            '[ap 04:49] Go in Action - William Kennedy.epub (kindle_split_020.html) - 4.49',
            "Listing\x{a0}<<4.49|5a:0>>. Runtime error assigned to a nil map
Listing\x{a0}<<4.50|5a:0>>. Retrieving a value from a map and testing existence.
Listing\x{a0}<<4.51|5a:0>>. Retrieving a value from a map testing the value for existence",
          ],
          [
            1,
            '[ap 04:51] Go in Action - William Kennedy.epub (kindle_split_020.html) - 4.51',
            "Listing\x{a0}<<4.51|5a:0>>. Retrieving a value from a map testing the value for existence",
          ],
          [
            1,
            '[ap 04:51] Go in Action - William Kennedy.epub (kindle_split_020.html) - 4.51',
            "Listing\x{a0}<<4.51|5a:0>>. Retrieving a value from a map testing the value for existence
Listing\x{a0}<<4.52|5a:0>>. Iterating over a map using for range
Listing\x{a0}<<4.53|5a:0>>. Removing an item from a map",
          ],
          [
            1,
            '[ap 04:52] Go in Action - William Kennedy.epub (kindle_split_020.html) - 4.52',
            "Listing\x{a0}<<4.52|5a:0>>. Iterating over a map using for range
Listing\x{a0}<<4.53|5a:0>>. Removing an item from a map
Listing\x{a0}<<4.54|5a:0>>. Passing maps between functions",
          ],
          [
            1,
            '[ap 04:53] Go in Action - William Kennedy.epub (kindle_split_020.html) - 4.53',
            "Listing\x{a0}<<4.53|5a:0>>. Removing an item from a map
Listing\x{a0}<<4.54|5a:0>>. Passing maps between functions
Listing\x{a0}<<4.55|5a:0>>. Output for listing <<4.54|5a:0>>",
          ],
          [
            1,
            '[ap 04:54] Go in Action - William Kennedy.epub (kindle_split_020.html) - 4.54',
            "Listing\x{a0}<<4.54|5a:0>>. Passing maps between functions
Listing\x{a0}<<4.55|5a:0>>. Output for listing <<4.54|5a:0>>
Chapter 5. Go\x{2019}s type system",
          ],
          [
            1,
            '[ap 05:10] Go in Action - William Kennedy.epub (kindle_split_020.html) - 5.10',
            "Listing\x{a0}5.9. Compiler error assigning value of different types
Listing\x{a0}<<5.10|5a:0>>. Actual compiler error
Listing\x{a0}<<5.11|5a:0>>. listing11.go",
          ],
          [
            1,
            '[ap 05:10] Go in Action - William Kennedy.epub (kindle_split_020.html) - 5.10',
            "Listing\x{a0}<<5.10|5a:0>>. Actual compiler error
Listing\x{a0}<<5.11|5a:0>>. listing11.go
Listing\x{a0}<<5.12|5a:0>>. Output for listing11.go",
          ],
          [
            1,
            '[ap 05:11] Go in Action - William Kennedy.epub (kindle_split_020.html) - 5.11',
            "Listing\x{a0}<<5.11|5a:0>>. listing11.go
Listing\x{a0}<<5.12|5a:0>>. Output for listing11.go
Listing\x{a0}<<5.13|5a:0>>. listing11.go: lines 09\x{2013}20",
          ],
          [
            1,
            '[ap 05:12] Go in Action - William Kennedy.epub (kindle_split_020.html) - 5.12',
            "Listing\x{a0}<<5.12|5a:0>>. Output for listing11.go
Listing\x{a0}<<5.13|5a:0>>. listing11.go: lines 09\x{2013}20
Listing\x{a0}<<5.14|5a:0>>. Declaration of a method with a value receiver",
          ],
          [
            1,
            '[ap 05:13] Go in Action - William Kennedy.epub (kindle_split_020.html) - 5.13',
            "Listing\x{a0}<<5.13|5a:0>>. listing11.go: lines 09\x{2013}20
Listing\x{a0}<<5.14|5a:0>>. Declaration of a method with a value receiver
Listing\x{a0}<<5.15|5a:0>>. listing11.go: lines 29\x{2013}32",
          ],
          [
            1,
            '[ap 05:14] Go in Action - William Kennedy.epub (kindle_split_020.html) - 5.14',
            "Listing\x{a0}<<5.14|5a:0>>. Declaration of a method with a value receiver
Listing\x{a0}<<5.15|5a:0>>. listing11.go: lines 29\x{2013}32
Listing\x{a0}<<5.16|5a:0>>. Calling a method from a variable",
          ],
          [
            1,
            '[ap 05:15] Go in Action - William Kennedy.epub (kindle_split_020.html) - 5.15',
            "Listing\x{a0}<<5.15|5a:0>>. listing11.go: lines 29\x{2013}32
Listing\x{a0}<<5.16|5a:0>>. Calling a method from a variable
Listing\x{a0}<<5.17|5a:0>>. listing11.go: lines 34\x{2013}37",
          ],
          [
            1,
            '[ap 05:16] Go in Action - William Kennedy.epub (kindle_split_020.html) - 5.16',
            "Listing\x{a0}<<5.16|5a:0>>. Calling a method from a variable
Listing\x{a0}<<5.17|5a:0>>. listing11.go: lines 34\x{2013}37
Listing\x{a0}<<5.18|5a:0>>. What Go is doing underneath the code",
          ],
          [
            1,
            '[ap 05:17] Go in Action - William Kennedy.epub (kindle_split_020.html) - 5.17',
            "Listing\x{a0}<<5.17|5a:0>>. listing11.go: lines 34\x{2013}37
Listing\x{a0}<<5.18|5a:0>>. What Go is doing underneath the code
Listing\x{a0}<<5.19|5a:0>>. listing11.go: lines 22\x{2013}25",
          ],
          [
            1,
            '[ap 05:18] Go in Action - William Kennedy.epub (kindle_split_020.html) - 5.18',
            "Listing\x{a0}<<5.18|5a:0>>. What Go is doing underneath the code
Listing\x{a0}<<5.19|5a:0>>. listing11.go: lines 22\x{2013}25
Listing\x{a0}<<5.20|5a:0>>. listing11.go: lines 36, 44\x{2013}46",
          ],
          [
            1,
            '[ap 05:19] Go in Action - William Kennedy.epub (kindle_split_020.html) - 5.19',
            "Listing\x{a0}<<5.19|5a:0>>. listing11.go: lines 22\x{2013}25
Listing\x{a0}<<5.20|5a:0>>. listing11.go: lines 36, 44\x{2013}46
Listing\x{a0}<<5.21|5a:0>>. listing11.go: line 31",
          ],
          [
            1,
            '[ap 05:20] Go in Action - William Kennedy.epub (kindle_split_020.html) - 5.20',
            "Listing\x{a0}<<5.20|5a:0>>. listing11.go: lines 36, 44\x{2013}46
Listing\x{a0}<<5.21|5a:0>>. listing11.go: line 31
Listing\x{a0}<<5.22|5a:0>>. What Go is doing underneath the code",
          ],
          [
            1,
            '[ap 05:21] Go in Action - William Kennedy.epub (kindle_split_020.html) - 5.21',
            "Listing\x{a0}<<5.21|5a:0>>. listing11.go: line 31
Listing\x{a0}<<5.22|5a:0>>. What Go is doing underneath the code
Listing\x{a0}<<5.23|5a:0>>. golang.org/src/strings/strings.go: lines 620\x{2013}625",
          ],
          [
            1,
            '[ap 05:22] Go in Action - William Kennedy.epub (kindle_split_020.html) - 5.22',
            "Listing\x{a0}<<5.22|5a:0>>. What Go is doing underneath the code
Listing\x{a0}<<5.23|5a:0>>. golang.org/src/strings/strings.go: lines 620\x{2013}625
Listing\x{a0}<<5.24|5a:0>>. golang.org/src/os/env.go: lines 38\x{2013}44",
          ],
          [
            1,
            '[ap 05:23] Go in Action - William Kennedy.epub (kindle_split_020.html) - 5.23',
            "Listing\x{a0}<<5.23|5a:0>>. golang.org/src/strings/strings.go: lines 620\x{2013}625
Listing\x{a0}<<5.24|5a:0>>. golang.org/src/os/env.go: lines 38\x{2013}44
Listing\x{a0}<<5.25|5a:0>>. golang.org/src/net/ip.go: line 32",
          ],
          [
            1,
            '[ap 05:24] Go in Action - William Kennedy.epub (kindle_split_020.html) - 5.24',
            "Listing\x{a0}<<5.24|5a:0>>. golang.org/src/os/env.go: lines 38\x{2013}44
Listing\x{a0}<<5.25|5a:0>>. golang.org/src/net/ip.go: line 32
Listing\x{a0}<<5.26|5a:0>>. golang.org/src/net/ip.go: lines 329\x{2013}337",
          ],
          [
            1,
            '[ap 05:25] Go in Action - William Kennedy.epub (kindle_split_020.html) - 5.25',
            "Listing\x{a0}<<5.25|5a:0>>. golang.org/src/net/ip.go: line 32
Listing\x{a0}<<5.26|5a:0>>. golang.org/src/net/ip.go: lines 329\x{2013}337
Listing\x{a0}<<5.27|5a:0>>. golang.org/src/net/ip.go: lines 318\x{2013}325",
          ],
          [
            1,
            '[ap 05:26] Go in Action - William Kennedy.epub (kindle_split_020.html) - 5.26',
            "Listing\x{a0}<<5.26|5a:0>>. golang.org/src/net/ip.go: lines 329\x{2013}337
Listing\x{a0}<<5.27|5a:0>>. golang.org/src/net/ip.go: lines 318\x{2013}325
Listing\x{a0}<<5.28|5a:0>>. golang.org/src/time/time.go: lines 39\x{2013}55",
          ],
          [
            1,
            '[ap 05:27] Go in Action - William Kennedy.epub (kindle_split_020.html) - 5.27',
            "Listing\x{a0}<<5.27|5a:0>>. golang.org/src/net/ip.go: lines 318\x{2013}325
Listing\x{a0}<<5.28|5a:0>>. golang.org/src/time/time.go: lines 39\x{2013}55
Listing\x{a0}<<5.29|5a:0>>. golang.org/src/time/time.go: lines 781\x{2013}784",
          ],
          [
            1,
            '[ap 05:28] Go in Action - William Kennedy.epub (kindle_split_020.html) - 5.28',
            "Listing\x{a0}<<5.28|5a:0>>. golang.org/src/time/time.go: lines 39\x{2013}55
Listing\x{a0}<<5.29|5a:0>>. golang.org/src/time/time.go: lines 781\x{2013}784
Listing\x{a0}<<5.30|5a:0>>. golang.org/src/time/time.go: lines 610\x{2013}622",
          ],
          [
            1,
            '[ap 05:29] Go in Action - William Kennedy.epub (kindle_split_020.html) - 5.29',
            "Listing\x{a0}<<5.29|5a:0>>. golang.org/src/time/time.go: lines 781\x{2013}784
Listing\x{a0}<<5.30|5a:0>>. golang.org/src/time/time.go: lines 610\x{2013}622
Listing\x{a0}<<5.31|5a:0>>. golang.org/src/os/file_unix.go: lines 15\x{2013}29",
          ],
          [
            1,
            '[ap 05:30] Go in Action - William Kennedy.epub (kindle_split_020.html) - 5.30',
            "Listing\x{a0}<<5.30|5a:0>>. golang.org/src/time/time.go: lines 610\x{2013}622
Listing\x{a0}<<5.31|5a:0>>. golang.org/src/os/file_unix.go: lines 15\x{2013}29
Listing\x{a0}<<5.32|5a:0>>. golang.org/src/os/file.go: lines 238\x{2013}240",
          ],
          [
            1,
            '[ap 05:31] Go in Action - William Kennedy.epub (kindle_split_020.html) - 5.31',
            "Listing\x{a0}<<5.31|5a:0>>. golang.org/src/os/file_unix.go: lines 15\x{2013}29
Listing\x{a0}<<5.32|5a:0>>. golang.org/src/os/file.go: lines 238\x{2013}240
Listing\x{a0}<<5.33|5a:0>>. golang.org/src/os/file.go: lines 224\x{2013}232",
          ],
          [
            1,
            '[ap 05:32] Go in Action - William Kennedy.epub (kindle_split_020.html) - 5.32',
            "Listing\x{a0}<<5.32|5a:0>>. golang.org/src/os/file.go: lines 238\x{2013}240
Listing\x{a0}<<5.33|5a:0>>. golang.org/src/os/file.go: lines 224\x{2013}232
Listing\x{a0}<<5.34|5a:0>>. listing34.go",
          ],
          [
            1,
            '[ap 05:33] Go in Action - William Kennedy.epub (kindle_split_020.html) - 5.33',
            "Listing\x{a0}<<5.33|5a:0>>. golang.org/src/os/file.go: lines 224\x{2013}232
Listing\x{a0}<<5.34|5a:0>>. listing34.go
Listing\x{a0}<<5.35|5a:0>>. listing35.go",
          ],
          [
            1,
            '[ap 05:34] Go in Action - William Kennedy.epub (kindle_split_020.html) - 5.34',
            "Listing\x{a0}<<5.34|5a:0>>. listing34.go
Listing\x{a0}<<5.35|5a:0>>. listing35.go
Listing\x{a0}<<5.36|5a:0>>. listing36.go",
          ],
          [
            1,
            '[ap 05:35] Go in Action - William Kennedy.epub (kindle_split_020.html) - 5.35',
            "Listing\x{a0}<<5.35|5a:0>>. listing35.go
Listing\x{a0}<<5.36|5a:0>>. listing36.go
Listing\x{a0}<<5.37|5a:0>>. listing36.go: lines 40\x{2013}44",
          ],
          [
            1,
            '[ap 05:36] Go in Action - William Kennedy.epub (kindle_split_020.html) - 5.36',
            "Listing\x{a0}<<5.36|5a:0>>. listing36.go
Listing\x{a0}<<5.37|5a:0>>. listing36.go: lines 40\x{2013}44
Listing\x{a0}<<5.38|5a:0>>. listing36.go: lines 28\x{2013}38",
          ],
          [
            1,
            '[ap 05:37] Go in Action - William Kennedy.epub (kindle_split_020.html) - 5.37',
            "Listing\x{a0}<<5.37|5a:0>>. listing36.go: lines 40\x{2013}44
Listing\x{a0}<<5.38|5a:0>>. listing36.go: lines 28\x{2013}38
Listing\x{a0}<<5.39|5a:0>>. Compiler error storing a value of type user to the interface value",
          ],
          [
            1,
            '[ap 05:39] Go in Action - William Kennedy.epub (kindle_split_020.html) - 5.39',
            "Listing\x{a0}<<5.39|5a:0>>. Compiler error storing a value of type user to the interface value",
          ],
          [
            1,
            '[ap 05:39] Go in Action - William Kennedy.epub (kindle_split_020.html) - 5.39',
            "Listing\x{a0}<<5.39|5a:0>>. Compiler error storing a value of type user to the interface value
Listing\x{a0}<<5.40|5a:0>>. listing36.go: lines 08\x{2013}12, 21\x{2013}25
Listing\x{a0}<<5.41|5a:0>>. Closer look at compiler error",
          ],
          [
            1,
            '[ap 05:40] Go in Action - William Kennedy.epub (kindle_split_020.html) - 5.40',
            "Listing\x{a0}<<5.40|5a:0>>. listing36.go: lines 08\x{2013}12, 21\x{2013}25
Listing\x{a0}<<5.41|5a:0>>. Closer look at compiler error
Listing\x{a0}<<5.42|5a:0>>. Method sets as described by the specification",
          ],
          [
            1,
            '[ap 05:41] Go in Action - William Kennedy.epub (kindle_split_020.html) - 5.41',
            "Listing\x{a0}<<5.41|5a:0>>. Closer look at compiler error
Listing\x{a0}<<5.42|5a:0>>. Method sets as described by the specification
Listing\x{a0}<<5.43|5a:0>>. Method sets from the perspective of the receiver type",
          ],
          [
            1,
            '[ap 05:42] Go in Action - William Kennedy.epub (kindle_split_020.html) - 5.42',
            "Listing\x{a0}<<5.42|5a:0>>. Method sets as described by the specification
Listing\x{a0}<<5.43|5a:0>>. Method sets from the perspective of the receiver type
Listing\x{a0}<<5.44|5a:0>>. listing36.go: lines 28\x{2013}38",
          ],
          [
            1,
            '[ap 05:43] Go in Action - William Kennedy.epub (kindle_split_020.html) - 5.43',
            "Listing\x{a0}<<5.43|5a:0>>. Method sets from the perspective of the receiver type
Listing\x{a0}<<5.44|5a:0>>. listing36.go: lines 28\x{2013}38
Listing\x{a0}<<5.45|5a:0>>. listing36.go: lines 28\x{2013}35",
          ],
          [
            1,
            '[ap 05:44] Go in Action - William Kennedy.epub (kindle_split_020.html) - 5.44',
            "Listing\x{a0}<<5.44|5a:0>>. listing36.go: lines 28\x{2013}38
Listing\x{a0}<<5.45|5a:0>>. listing36.go: lines 28\x{2013}35
Listing\x{a0}<<5.46|5a:0>>. listing46.go",
          ],
          [
            1,
            '[ap 05:45] Go in Action - William Kennedy.epub (kindle_split_020.html) - 5.45',
            "Listing\x{a0}<<5.45|5a:0>>. listing36.go: lines 28\x{2013}35
Listing\x{a0}<<5.46|5a:0>>. listing46.go
Listing\x{a0}<<5.47|5a:0>>. Second look at the method set rules",
          ],
          [
            1,
            '[ap 05:46] Go in Action - William Kennedy.epub (kindle_split_020.html) - 5.46',
            "Listing\x{a0}<<5.46|5a:0>>. listing46.go
Listing\x{a0}<<5.47|5a:0>>. Second look at the method set rules
Listing\x{a0}<<5.48|5a:0>>. listing48.go",
          ],
          [
            1,
            '[ap 05:47] Go in Action - William Kennedy.epub (kindle_split_020.html) - 5.47',
            "Listing\x{a0}<<5.47|5a:0>>. Second look at the method set rules
Listing\x{a0}<<5.48|5a:0>>. listing48.go
Listing\x{a0}<<5.49|5a:0>>. listing48.go: lines 40\x{2013}49",
          ],
          [
            1,
            '[ap 05:48] Go in Action - William Kennedy.epub (kindle_split_020.html) - 5.48',
            "Listing\x{a0}<<5.48|5a:0>>. listing48.go
Listing\x{a0}<<5.49|5a:0>>. listing48.go: lines 40\x{2013}49
Listing\x{a0}<<5.50|5a:0>>. listing50.go",
          ],
          [
            1,
            '[ap 05:49] Go in Action - William Kennedy.epub (kindle_split_020.html) - 5.49',
            "Listing\x{a0}<<5.49|5a:0>>. listing48.go: lines 40\x{2013}49
Listing\x{a0}<<5.50|5a:0>>. listing50.go
Listing\x{a0}<<5.51|5a:0>>. listing50.go: lines 09\x{2013}13, 23\x{2013}27",
          ],
          [
            1,
            '[ap 05:50] Go in Action - William Kennedy.epub (kindle_split_020.html) - 5.50',
            "Listing\x{a0}<<5.50|5a:0>>. listing50.go
Listing\x{a0}<<5.51|5a:0>>. listing50.go: lines 09\x{2013}13, 23\x{2013}27
Listing\x{a0}<<5.52|5a:0>>. listing50.go: lines 15\x{2013}21",
          ],
          [
            1,
            '[ap 05:51] Go in Action - William Kennedy.epub (kindle_split_020.html) - 5.51',
            "Listing\x{a0}<<5.51|5a:0>>. listing50.go: lines 09\x{2013}13, 23\x{2013}27
Listing\x{a0}<<5.52|5a:0>>. listing50.go: lines 15\x{2013}21
Listing\x{a0}<<5.53|5a:0>>. listing50.go: lines 30\x{2013}45",
          ],
          [
            1,
            '[ap 05:52] Go in Action - William Kennedy.epub (kindle_split_020.html) - 5.52',
            "Listing\x{a0}<<5.52|5a:0>>. listing50.go: lines 15\x{2013}21
Listing\x{a0}<<5.53|5a:0>>. listing50.go: lines 30\x{2013}45
Listing\x{a0}<<5.54|5a:0>>. listing50.go: lines 40\x{2013}41",
          ],
          [
            1,
            '[ap 05:53] Go in Action - William Kennedy.epub (kindle_split_020.html) - 5.53',
            "Listing\x{a0}<<5.53|5a:0>>. listing50.go: lines 30\x{2013}45
Listing\x{a0}<<5.54|5a:0>>. listing50.go: lines 40\x{2013}41
Listing\x{a0}<<5.55|5a:0>>. listing50.go: lines 43\x{2013}45",
          ],
          [
            1,
            '[ap 05:54] Go in Action - William Kennedy.epub (kindle_split_020.html) - 5.54',
            "Listing\x{a0}<<5.54|5a:0>>. listing50.go: lines 40\x{2013}41
Listing\x{a0}<<5.55|5a:0>>. listing50.go: lines 43\x{2013}45
Listing\x{a0}<<5.56|5a:0>>. listing56.go",
          ],
          [
            1,
            '[ap 05:55] Go in Action - William Kennedy.epub (kindle_split_020.html) - 5.55',
            "Listing\x{a0}<<5.55|5a:0>>. listing50.go: lines 43\x{2013}45
Listing\x{a0}<<5.56|5a:0>>. listing56.go
Listing\x{a0}<<5.57|5a:0>>. listing56.go: lines 08\x{2013}12, 51\x{2013}55",
          ],
          [
            1,
            '[ap 05:56] Go in Action - William Kennedy.epub (kindle_split_020.html) - 5.56',
            "Listing\x{a0}<<5.56|5a:0>>. listing56.go
Listing\x{a0}<<5.57|5a:0>>. listing56.go: lines 08\x{2013}12, 51\x{2013}55
Listing\x{a0}<<5.58|5a:0>>. listing56.go: lines 35\x{2013}49",
          ],
          [
            1,
            '[ap 05:57] Go in Action - William Kennedy.epub (kindle_split_020.html) - 5.57',
            "Listing\x{a0}<<5.57|5a:0>>. listing56.go: lines 08\x{2013}12, 51\x{2013}55
Listing\x{a0}<<5.58|5a:0>>. listing56.go: lines 35\x{2013}49
Listing\x{a0}<<5.59|5a:0>>. Output for listing56.go",
          ],
          [
            1,
            '[ap 05:58] Go in Action - William Kennedy.epub (kindle_split_020.html) - 5.58',
            "Listing\x{a0}<<5.58|5a:0>>. listing56.go: lines 35\x{2013}49
Listing\x{a0}<<5.59|5a:0>>. Output for listing56.go
Listing\x{a0}<<5.60|5a:0>>. listing60.go",
          ],
          [
            1,
            '[ap 05:59] Go in Action - William Kennedy.epub (kindle_split_020.html) - 5.59',
            "Listing\x{a0}<<5.59|5a:0>>. Output for listing56.go
Listing\x{a0}<<5.60|5a:0>>. listing60.go
Listing\x{a0}5.61. listing60.go: lines 35\x{2013}41",
          ],
          [
            1,
            '[ap 06:10] Go in Action - William Kennedy.epub (kindle_split_020.html) - 6.10',
            "Listing\x{a0}6.9. listing09.go
Listing\x{a0}<<6.10|5a:0>>. Output for listing09.go
Listing\x{a0}<<6.11|5a:0>>. Building and running listing09 with the race detector",
          ],
          [
            1,
            '[ap 06:10] Go in Action - William Kennedy.epub (kindle_split_020.html) - 6.10',
            "Listing\x{a0}<<6.10|5a:0>>. Output for listing09.go
Listing\x{a0}<<6.11|5a:0>>. Building and running listing09 with the race detector
Listing\x{a0}<<6.12|5a:0>>. Lines of code called out by the race detector",
          ],
          [
            1,
            '[ap 06:11] Go in Action - William Kennedy.epub (kindle_split_020.html) - 6.11',
            "Listing\x{a0}<<6.11|5a:0>>. Building and running listing09 with the race detector
Listing\x{a0}<<6.12|5a:0>>. Lines of code called out by the race detector
Listing\x{a0}<<6.13|5a:0>>. listing13.go",
          ],
          [
            1,
            '[ap 06:12] Go in Action - William Kennedy.epub (kindle_split_020.html) - 6.12',
            "Listing\x{a0}<<6.12|5a:0>>. Lines of code called out by the race detector
Listing\x{a0}<<6.13|5a:0>>. listing13.go
Listing\x{a0}<<6.14|5a:0>>. Output for listing13.go",
          ],
          [
            1,
            '[ap 06:13] Go in Action - William Kennedy.epub (kindle_split_020.html) - 6.13',
            "Listing\x{a0}<<6.13|5a:0>>. listing13.go
Listing\x{a0}<<6.14|5a:0>>. Output for listing13.go
Listing\x{a0}<<6.15|5a:0>>. listing15.go",
          ],
          [
            1,
            '[ap 06:14] Go in Action - William Kennedy.epub (kindle_split_020.html) - 6.14',
            "Listing\x{a0}<<6.14|5a:0>>. Output for listing13.go
Listing\x{a0}<<6.15|5a:0>>. listing15.go
Listing\x{a0}<<6.16|5a:0>>. listing16.go",
          ],
          [
            1,
            '[ap 06:15] Go in Action - William Kennedy.epub (kindle_split_020.html) - 6.15',
            "Listing\x{a0}<<6.15|5a:0>>. listing15.go
Listing\x{a0}<<6.16|5a:0>>. listing16.go
Listing\x{a0}<<6.17|5a:0>>. Using make to create a channel",
          ],
          [
            1,
            '[ap 06:16] Go in Action - William Kennedy.epub (kindle_split_020.html) - 6.16',
            "Listing\x{a0}<<6.16|5a:0>>. listing16.go
Listing\x{a0}<<6.17|5a:0>>. Using make to create a channel
Listing\x{a0}<<6.18|5a:0>>. Sending values into a channel",
          ],
          [
            1,
            '[ap 06:17] Go in Action - William Kennedy.epub (kindle_split_020.html) - 6.17',
            "Listing\x{a0}<<6.17|5a:0>>. Using make to create a channel
Listing\x{a0}<<6.18|5a:0>>. Sending values into a channel
Listing\x{a0}<<6.19|5a:0>>. Receiving values from a channel",
          ],
          [
            1,
            '[ap 06:18] Go in Action - William Kennedy.epub (kindle_split_020.html) - 6.18',
            "Listing\x{a0}<<6.18|5a:0>>. Sending values into a channel
Listing\x{a0}<<6.19|5a:0>>. Receiving values from a channel
Listing\x{a0}<<6.20|5a:0>>. listing20.go",
          ],
          [
            1,
            '[ap 06:19] Go in Action - William Kennedy.epub (kindle_split_020.html) - 6.19',
            "Listing\x{a0}<<6.19|5a:0>>. Receiving values from a channel
Listing\x{a0}<<6.20|5a:0>>. listing20.go
Listing\x{a0}<<6.21|5a:0>>. Output for listing20.go",
          ],
          [
            1,
            '[ap 06:20] Go in Action - William Kennedy.epub (kindle_split_020.html) - 6.20',
            "Listing\x{a0}<<6.20|5a:0>>. listing20.go
Listing\x{a0}<<6.21|5a:0>>. Output for listing20.go
Listing\x{a0}<<6.22|5a:0>>. listing22.go",
          ],
          [
            1,
            '[ap 06:21] Go in Action - William Kennedy.epub (kindle_split_020.html) - 6.21',
            "Listing\x{a0}<<6.21|5a:0>>. Output for listing20.go
Listing\x{a0}<<6.22|5a:0>>. listing22.go
Listing\x{a0}<<6.23|5a:0>>. Output for listing22.go",
          ],
          [
            1,
            '[ap 06:22] Go in Action - William Kennedy.epub (kindle_split_020.html) - 6.22',
            "Listing\x{a0}<<6.22|5a:0>>. listing22.go
Listing\x{a0}<<6.23|5a:0>>. Output for listing22.go
Listing\x{a0}<<6.24|5a:0>>. listing24.go",
          ],
          [
            1,
            '[ap 06:23] Go in Action - William Kennedy.epub (kindle_split_020.html) - 6.23',
            "Listing\x{a0}<<6.23|5a:0>>. Output for listing22.go
Listing\x{a0}<<6.24|5a:0>>. listing24.go
Listing\x{a0}<<6.25|5a:0>>. Output for listing24.go",
          ],
          [
            1,
            '[ap 06:24] Go in Action - William Kennedy.epub (kindle_split_020.html) - 6.24',
            "Listing\x{a0}<<6.24|5a:0>>. listing24.go
Listing\x{a0}<<6.25|5a:0>>. Output for listing24.go
Chapter 7. Concurrency patterns",
          ],
          [
            1,
            '[ap 07:10] Go in Action - William Kennedy.epub (kindle_split_020.html) - 7.10',
            "Listing\x{a0}7.9. runner/runner.go: lines 45\x{2013}49
Listing\x{a0}<<7.10|5a:0>>. runner/runner.go: lines 72\x{2013}85
Listing\x{a0}<<7.11|5a:0>>. runner/runner.go: lines 87\x{2013}101",
          ],
          [
            1,
            '[ap 07:10] Go in Action - William Kennedy.epub (kindle_split_020.html) - 7.10',
            "Listing\x{a0}<<7.10|5a:0>>. runner/runner.go: lines 72\x{2013}85
Listing\x{a0}<<7.11|5a:0>>. runner/runner.go: lines 87\x{2013}101
Listing\x{a0}<<7.12|5a:0>>. runner/runner.go: lines 51\x{2013}70",
          ],
          [
            1,
            '[ap 07:11] Go in Action - William Kennedy.epub (kindle_split_020.html) - 7.11',
            "Listing\x{a0}<<7.11|5a:0>>. runner/runner.go: lines 87\x{2013}101
Listing\x{a0}<<7.12|5a:0>>. runner/runner.go: lines 51\x{2013}70
Listing\x{a0}<<7.13|5a:0>>. runner/main/main.go",
          ],
          [
            1,
            '[ap 07:12] Go in Action - William Kennedy.epub (kindle_split_020.html) - 7.12',
            "Listing\x{a0}<<7.12|5a:0>>. runner/runner.go: lines 51\x{2013}70
Listing\x{a0}<<7.13|5a:0>>. runner/main/main.go
Listing\x{a0}<<7.14|5a:0>>. pool/pool.go",
          ],
          [
            1,
            '[ap 07:13] Go in Action - William Kennedy.epub (kindle_split_020.html) - 7.13',
            "Listing\x{a0}<<7.13|5a:0>>. runner/main/main.go
Listing\x{a0}<<7.14|5a:0>>. pool/pool.go
Listing\x{a0}<<7.15|5a:0>>. pool/pool.go: lines 12\x{2013}20",
          ],
          [
            1,
            '[ap 07:14] Go in Action - William Kennedy.epub (kindle_split_020.html) - 7.14',
            "Listing\x{a0}<<7.14|5a:0>>. pool/pool.go
Listing\x{a0}<<7.15|5a:0>>. pool/pool.go: lines 12\x{2013}20
Listing\x{a0}<<7.16|5a:0>>. pool/pool.go: lines 22\x{2013}24",
          ],
          [
            1,
            '[ap 07:15] Go in Action - William Kennedy.epub (kindle_split_020.html) - 7.15',
            "Listing\x{a0}<<7.15|5a:0>>. pool/pool.go: lines 12\x{2013}20
Listing\x{a0}<<7.16|5a:0>>. pool/pool.go: lines 22\x{2013}24
Listing\x{a0}<<7.17|5a:0>>. pool/pool.go: lines 26\x{2013}38",
          ],
          [
            1,
            '[ap 07:16] Go in Action - William Kennedy.epub (kindle_split_020.html) - 7.16',
            "Listing\x{a0}<<7.16|5a:0>>. pool/pool.go: lines 22\x{2013}24
Listing\x{a0}<<7.17|5a:0>>. pool/pool.go: lines 26\x{2013}38
Listing\x{a0}<<7.18|5a:0>>. pool/pool.go: lines 40\x{2013}56",
          ],
          [
            1,
            '[ap 07:17] Go in Action - William Kennedy.epub (kindle_split_020.html) - 7.17',
            "Listing\x{a0}<<7.17|5a:0>>. pool/pool.go: lines 26\x{2013}38
Listing\x{a0}<<7.18|5a:0>>. pool/pool.go: lines 40\x{2013}56
Listing\x{a0}<<7.19|5a:0>>. pool/pool.go: lines 82\x{2013}104",
          ],
          [
            1,
            '[ap 07:18] Go in Action - William Kennedy.epub (kindle_split_020.html) - 7.18',
            "Listing\x{a0}<<7.18|5a:0>>. pool/pool.go: lines 40\x{2013}56
Listing\x{a0}<<7.19|5a:0>>. pool/pool.go: lines 82\x{2013}104
Listing\x{a0}<<7.20|5a:0>>. pool/pool.go: lines 58\x{2013}80",
          ],
          [
            1,
            '[ap 07:19] Go in Action - William Kennedy.epub (kindle_split_020.html) - 7.19',
            "Listing\x{a0}<<7.19|5a:0>>. pool/pool.go: lines 82\x{2013}104
Listing\x{a0}<<7.20|5a:0>>. pool/pool.go: lines 58\x{2013}80
Listing\x{a0}<<7.21|5a:0>>. pool/main/main.go",
          ],
          [
            1,
            '[ap 07:20] Go in Action - William Kennedy.epub (kindle_split_020.html) - 7.20',
            "Listing\x{a0}<<7.20|5a:0>>. pool/pool.go: lines 58\x{2013}80
Listing\x{a0}<<7.21|5a:0>>. pool/main/main.go
Listing\x{a0}<<7.22|5a:0>>. pool/main/main.go: lines 21\x{2013}32",
          ],
          [
            1,
            '[ap 07:21] Go in Action - William Kennedy.epub (kindle_split_020.html) - 7.21',
            "Listing\x{a0}<<7.21|5a:0>>. pool/main/main.go
Listing\x{a0}<<7.22|5a:0>>. pool/main/main.go: lines 21\x{2013}32
Listing\x{a0}<<7.23|5a:0>>. pool/main/main.go: lines 34\x{2013}44",
          ],
          [
            1,
            '[ap 07:22] Go in Action - William Kennedy.epub (kindle_split_020.html) - 7.22',
            "Listing\x{a0}<<7.22|5a:0>>. pool/main/main.go: lines 21\x{2013}32
Listing\x{a0}<<7.23|5a:0>>. pool/main/main.go: lines 34\x{2013}44
Listing\x{a0}<<7.24|5a:0>>. pool/main/main.go: lines 48\x{2013}55",
          ],
          [
            1,
            '[ap 07:23] Go in Action - William Kennedy.epub (kindle_split_020.html) - 7.23',
            "Listing\x{a0}<<7.23|5a:0>>. pool/main/main.go: lines 34\x{2013}44
Listing\x{a0}<<7.24|5a:0>>. pool/main/main.go: lines 48\x{2013}55
Listing\x{a0}<<7.25|5a:0>>. pool/main/main.go: lines 57\x{2013}66",
          ],
          [
            1,
            '[ap 07:24] Go in Action - William Kennedy.epub (kindle_split_020.html) - 7.24',
            "Listing\x{a0}<<7.24|5a:0>>. pool/main/main.go: lines 48\x{2013}55
Listing\x{a0}<<7.25|5a:0>>. pool/main/main.go: lines 57\x{2013}66
Listing\x{a0}<<7.26|5a:0>>. pool/main/main.go: lines 68\x{2013}73",
          ],
          [
            1,
            '[ap 07:25] Go in Action - William Kennedy.epub (kindle_split_020.html) - 7.25',
            "Listing\x{a0}<<7.25|5a:0>>. pool/main/main.go: lines 57\x{2013}66
Listing\x{a0}<<7.26|5a:0>>. pool/main/main.go: lines 68\x{2013}73
Listing\x{a0}<<7.27|5a:0>>. pool/main/main.go: lines 76\x{2013}91",
          ],
          [
            1,
            '[ap 07:26] Go in Action - William Kennedy.epub (kindle_split_020.html) - 7.26',
            "Listing\x{a0}<<7.26|5a:0>>. pool/main/main.go: lines 68\x{2013}73
Listing\x{a0}<<7.27|5a:0>>. pool/main/main.go: lines 76\x{2013}91
Listing\x{a0}<<7.28|5a:0>>. work/work.go",
          ],
          [
            1,
            '[ap 07:27] Go in Action - William Kennedy.epub (kindle_split_020.html) - 7.27',
            "Listing\x{a0}<<7.27|5a:0>>. pool/main/main.go: lines 76\x{2013}91
Listing\x{a0}<<7.28|5a:0>>. work/work.go
Listing\x{a0}<<7.29|5a:0>>. work/work.go: lines 07\x{2013}18",
          ],
          [
            1,
            '[ap 07:28] Go in Action - William Kennedy.epub (kindle_split_020.html) - 7.28',
            "Listing\x{a0}<<7.28|5a:0>>. work/work.go
Listing\x{a0}<<7.29|5a:0>>. work/work.go: lines 07\x{2013}18
Listing\x{a0}<<7.30|5a:0>>. work/work.go: lines 20\x{2013}37",
          ],
          [
            1,
            '[ap 07:29] Go in Action - William Kennedy.epub (kindle_split_020.html) - 7.29',
            "Listing\x{a0}<<7.29|5a:0>>. work/work.go: lines 07\x{2013}18
Listing\x{a0}<<7.30|5a:0>>. work/work.go: lines 20\x{2013}37
Listing\x{a0}<<7.31|5a:0>>. work/work.go: lines 28\x{2013}33",
          ],
          [
            1,
            '[ap 07:30] Go in Action - William Kennedy.epub (kindle_split_020.html) - 7.30',
            "Listing\x{a0}<<7.30|5a:0>>. work/work.go: lines 20\x{2013}37
Listing\x{a0}<<7.31|5a:0>>. work/work.go: lines 28\x{2013}33
Listing\x{a0}<<7.32|5a:0>>. work/work.go: lines 39\x{2013}42",
          ],
          [
            1,
            '[ap 07:31] Go in Action - William Kennedy.epub (kindle_split_020.html) - 7.31',
            "Listing\x{a0}<<7.31|5a:0>>. work/work.go: lines 28\x{2013}33
Listing\x{a0}<<7.32|5a:0>>. work/work.go: lines 39\x{2013}42
Listing\x{a0}<<7.33|5a:0>>. work/work.go: lines 44\x{2013}48",
          ],
          [
            1,
            '[ap 07:32] Go in Action - William Kennedy.epub (kindle_split_020.html) - 7.32',
            "Listing\x{a0}<<7.32|5a:0>>. work/work.go: lines 39\x{2013}42
Listing\x{a0}<<7.33|5a:0>>. work/work.go: lines 44\x{2013}48
Listing\x{a0}<<7.34|5a:0>>. work/main/main.go",
          ],
          [
            1,
            '[ap 07:33] Go in Action - William Kennedy.epub (kindle_split_020.html) - 7.33',
            "Listing\x{a0}<<7.33|5a:0>>. work/work.go: lines 44\x{2013}48
Listing\x{a0}<<7.34|5a:0>>. work/main/main.go
Listing\x{a0}<<7.35|5a:0>>. work/main/main.go: lines 22\x{2013}31",
          ],
          [
            1,
            '[ap 07:34] Go in Action - William Kennedy.epub (kindle_split_020.html) - 7.34',
            "Listing\x{a0}<<7.34|5a:0>>. work/main/main.go
Listing\x{a0}<<7.35|5a:0>>. work/main/main.go: lines 22\x{2013}31
Listing\x{a0}<<7.36|5a:0>>. work/main/main.go: lines 33\x{2013}64",
          ],
          [
            1,
            '[ap 07:35] Go in Action - William Kennedy.epub (kindle_split_020.html) - 7.35',
            "Listing\x{a0}<<7.35|5a:0>>. work/main/main.go: lines 22\x{2013}31
Listing\x{a0}<<7.36|5a:0>>. work/main/main.go: lines 33\x{2013}64
Chapter 8. Standard library",
          ],
          [
            1,
            '[ap 08:10] Go in Action - William Kennedy.epub (kindle_split_020.html) - 8.10',
            "Listing\x{a0}8.9. listing03.go: lines 08\x{2013}11
Listing\x{a0}<<8.10|5a:0>>. listing03.go: lines 13\x{2013}22
Listing\x{a0}<<8.11|5a:0>>. listing11.go",
          ],
          [
            1,
            '[ap 08:10] Go in Action - William Kennedy.epub (kindle_split_020.html) - 8.10',
            "Listing\x{a0}<<8.10|5a:0>>. listing03.go: lines 13\x{2013}22
Listing\x{a0}<<8.11|5a:0>>. listing11.go
Listing\x{a0}<<8.12|5a:0>>. listing11.go: lines 11\x{2013}16",
          ],
          [
            1,
            '[ap 08:11] Go in Action - William Kennedy.epub (kindle_split_020.html) - 8.11',
            "Listing\x{a0}<<8.11|5a:0>>. listing11.go
Listing\x{a0}<<8.12|5a:0>>. listing11.go: lines 11\x{2013}16
Listing\x{a0}<<8.13|5a:0>>. listing11.go: lines 25\x{2013}39",
          ],
          [
            1,
            '[ap 08:12] Go in Action - William Kennedy.epub (kindle_split_020.html) - 8.12',
            "Listing\x{a0}<<8.12|5a:0>>. listing11.go: lines 11\x{2013}16
Listing\x{a0}<<8.13|5a:0>>. listing11.go: lines 25\x{2013}39
Listing\x{a0}<<8.14|5a:0>>. golang.org/src/log/log.go",
          ],
          [
            1,
            '[ap 08:13] Go in Action - William Kennedy.epub (kindle_split_020.html) - 8.13',
            "Listing\x{a0}<<8.13|5a:0>>. listing11.go: lines 25\x{2013}39
Listing\x{a0}<<8.14|5a:0>>. golang.org/src/log/log.go
Listing\x{a0}<<8.15|5a:0>>. listing11.go: lines 25\x{2013}27",
          ],
          [
            1,
            '[ap 08:14] Go in Action - William Kennedy.epub (kindle_split_020.html) - 8.14',
            "Listing\x{a0}<<8.14|5a:0>>. golang.org/src/log/log.go
Listing\x{a0}<<8.15|5a:0>>. listing11.go: lines 25\x{2013}27
Listing\x{a0}<<8.16|5a:0>>. golang.org/src/io/ioutil/ioutil.go",
          ],
          [
            1,
            '[ap 08:15] Go in Action - William Kennedy.epub (kindle_split_020.html) - 8.15',
            "Listing\x{a0}<<8.15|5a:0>>. listing11.go: lines 25\x{2013}27
Listing\x{a0}<<8.16|5a:0>>. golang.org/src/io/ioutil/ioutil.go
Listing\x{a0}<<8.17|5a:0>>. listing11.go: lines 29\x{2013}35",
          ],
          [
            1,
            '[ap 08:16] Go in Action - William Kennedy.epub (kindle_split_020.html) - 8.16',
            "Listing\x{a0}<<8.16|5a:0>>. golang.org/src/io/ioutil/ioutil.go
Listing\x{a0}<<8.17|5a:0>>. listing11.go: lines 29\x{2013}35
Listing\x{a0}<<8.18|5a:0>>. golang.org/src/os/file.go",
          ],
          [
            1,
            '[ap 08:17] Go in Action - William Kennedy.epub (kindle_split_020.html) - 8.17',
            "Listing\x{a0}<<8.17|5a:0>>. listing11.go: lines 29\x{2013}35
Listing\x{a0}<<8.18|5a:0>>. golang.org/src/os/file.go
Listing\x{a0}<<8.19|5a:0>>. listing11.go: lines 37\x{2013}39",
          ],
          [
            1,
            '[ap 08:18] Go in Action - William Kennedy.epub (kindle_split_020.html) - 8.18',
            "Listing\x{a0}<<8.18|5a:0>>. golang.org/src/os/file.go
Listing\x{a0}<<8.19|5a:0>>. listing11.go: lines 37\x{2013}39
Listing\x{a0}<<8.20|5a:0>>. Declaration of the MultiWriter function in the io package",
          ],
          [
            1,
            '[ap 08:20] Go in Action - William Kennedy.epub (kindle_split_020.html) - 8.20',
            "Listing\x{a0}<<8.20|5a:0>>. Declaration of the MultiWriter function in the io package",
          ],
          [
            1,
            '[ap 08:20] Go in Action - William Kennedy.epub (kindle_split_020.html) - 8.20',
            "Listing\x{a0}<<8.20|5a:0>>. Declaration of the MultiWriter function in the io package
Listing\x{a0}<<8.21|5a:0>>. listing11.go: lines 42\x{2013}47
Listing\x{a0}<<8.22|5a:0>>. Declarations of the different logging methods",
          ],
          [
            1,
            '[ap 08:21] Go in Action - William Kennedy.epub (kindle_split_020.html) - 8.21',
            "Listing\x{a0}<<8.21|5a:0>>. listing11.go: lines 42\x{2013}47
Listing\x{a0}<<8.22|5a:0>>. Declarations of the different logging methods
Listing\x{a0}<<8.23|5a:0>>. Google search API sample JSON response",
          ],
          [
            1,
            '[ap 08:22] Go in Action - William Kennedy.epub (kindle_split_020.html) - 8.22',
            "Listing\x{a0}<<8.22|5a:0>>. Declarations of the different logging methods
Listing\x{a0}<<8.23|5a:0>>. Google search API sample JSON response
Listing\x{a0}<<8.24|5a:0>>. listing24.go",
          ],
          [
            1,
            '[ap 08:23] Go in Action - William Kennedy.epub (kindle_split_020.html) - 8.23',
            "Listing\x{a0}<<8.23|5a:0>>. Google search API sample JSON response
Listing\x{a0}<<8.24|5a:0>>. listing24.go
Listing\x{a0}<<8.25|5a:0>>. golang.org/src/encoding/json/stream.go",
          ],
          [
            1,
            '[ap 08:24] Go in Action - William Kennedy.epub (kindle_split_020.html) - 8.24',
            "Listing\x{a0}<<8.24|5a:0>>. listing24.go
Listing\x{a0}<<8.25|5a:0>>. golang.org/src/encoding/json/stream.go
Listing\x{a0}<<8.26|5a:0>>. Use of the Decode method",
          ],
          [
            1,
            '[ap 08:25] Go in Action - William Kennedy.epub (kindle_split_020.html) - 8.25',
            "Listing\x{a0}<<8.25|5a:0>>. golang.org/src/encoding/json/stream.go
Listing\x{a0}<<8.26|5a:0>>. Use of the Decode method
Listing\x{a0}<<8.27|5a:0>>. listing27.go",
          ],
          [
            1,
            '[ap 08:26] Go in Action - William Kennedy.epub (kindle_split_020.html) - 8.26',
            "Listing\x{a0}<<8.26|5a:0>>. Use of the Decode method
Listing\x{a0}<<8.27|5a:0>>. listing27.go
Listing\x{a0}<<8.28|5a:0>>. Output for listing27.go",
          ],
          [
            1,
            '[ap 08:27] Go in Action - William Kennedy.epub (kindle_split_020.html) - 8.27',
            "Listing\x{a0}<<8.27|5a:0>>. listing27.go
Listing\x{a0}<<8.28|5a:0>>. Output for listing27.go
Listing\x{a0}<<8.29|5a:0>>. listing29.go",
          ],
          [
            1,
            '[ap 08:28] Go in Action - William Kennedy.epub (kindle_split_020.html) - 8.28',
            "Listing\x{a0}<<8.28|5a:0>>. Output for listing27.go
Listing\x{a0}<<8.29|5a:0>>. listing29.go
Listing\x{a0}<<8.30|5a:0>>. Syntax for accessing a field from an unmarshaled map",
          ],
          [
            1,
            '[ap 08:29] Go in Action - William Kennedy.epub (kindle_split_020.html) - 8.29',
            "Listing\x{a0}<<8.29|5a:0>>. listing29.go
Listing\x{a0}<<8.30|5a:0>>. Syntax for accessing a field from an unmarshaled map
Listing\x{a0}<<8.31|5a:0>>. listing31.go",
          ],
          [
            1,
            '[ap 08:30] Go in Action - William Kennedy.epub (kindle_split_020.html) - 8.30',
            "Listing\x{a0}<<8.30|5a:0>>. Syntax for accessing a field from an unmarshaled map
Listing\x{a0}<<8.31|5a:0>>. listing31.go
Listing\x{a0}<<8.32|5a:0>>. golang.org/src/encoding/json/encode.go",
          ],
          [
            1,
            '[ap 08:31] Go in Action - William Kennedy.epub (kindle_split_020.html) - 8.31',
            "Listing\x{a0}<<8.31|5a:0>>. listing31.go
Listing\x{a0}<<8.32|5a:0>>. golang.org/src/encoding/json/encode.go
Listing\x{a0}<<8.33|5a:0>>. Declaration of the io.Writer interface",
          ],
          [
            1,
            '[ap 08:32] Go in Action - William Kennedy.epub (kindle_split_020.html) - 8.32',
            "Listing\x{a0}<<8.32|5a:0>>. golang.org/src/encoding/json/encode.go
Listing\x{a0}<<8.33|5a:0>>. Declaration of the io.Writer interface
Listing\x{a0}<<8.34|5a:0>>. Documentation for the io.Writer interface",
          ],
          [
            1,
            '[ap 08:33] Go in Action - William Kennedy.epub (kindle_split_020.html) - 8.33',
            "Listing\x{a0}<<8.33|5a:0>>. Declaration of the io.Writer interface
Listing\x{a0}<<8.34|5a:0>>. Documentation for the io.Writer interface
Listing\x{a0}<<8.35|5a:0>>. Declaration of the io.Reader interface",
          ],
          [
            1,
            '[ap 08:34] Go in Action - William Kennedy.epub (kindle_split_020.html) - 8.34',
            "Listing\x{a0}<<8.34|5a:0>>. Documentation for the io.Writer interface
Listing\x{a0}<<8.35|5a:0>>. Declaration of the io.Reader interface
Listing\x{a0}<<8.36|5a:0>>. Documentation for the io.Reader interface",
          ],
          [
            1,
            '[ap 08:35] Go in Action - William Kennedy.epub (kindle_split_020.html) - 8.35',
            "Listing\x{a0}<<8.35|5a:0>>. Declaration of the io.Reader interface
Listing\x{a0}<<8.36|5a:0>>. Documentation for the io.Reader interface
Listing\x{a0}<<8.37|5a:0>>. listing37.go",
          ],
          [
            1,
            '[ap 08:36] Go in Action - William Kennedy.epub (kindle_split_020.html) - 8.36',
            "Listing\x{a0}<<8.36|5a:0>>. Documentation for the io.Reader interface
Listing\x{a0}<<8.37|5a:0>>. listing37.go
Listing\x{a0}<<8.38|5a:0>>. Output for listing37.go",
          ],
          [
            1,
            '[ap 08:37] Go in Action - William Kennedy.epub (kindle_split_020.html) - 8.37',
            "Listing\x{a0}<<8.37|5a:0>>. listing37.go
Listing\x{a0}<<8.38|5a:0>>. Output for listing37.go
Listing\x{a0}<<8.39|5a:0>>. golang.org/src/fmt/print.go",
          ],
          [
            1,
            '[ap 08:38] Go in Action - William Kennedy.epub (kindle_split_020.html) - 8.38',
            "Listing\x{a0}<<8.38|5a:0>>. Output for listing37.go
Listing\x{a0}<<8.39|5a:0>>. golang.org/src/fmt/print.go
Listing\x{a0}<<8.40|5a:0>>. golang.org/src/bytes/buffer.go",
          ],
          [
            1,
            '[ap 08:39] Go in Action - William Kennedy.epub (kindle_split_020.html) - 8.39',
            "Listing\x{a0}<<8.39|5a:0>>. golang.org/src/fmt/print.go
Listing\x{a0}<<8.40|5a:0>>. golang.org/src/bytes/buffer.go
Listing\x{a0}<<8.41|5a:0>>. listing37.go: lines 22\x{2013}25",
          ],
          [
            1,
            '[ap 08:40] Go in Action - William Kennedy.epub (kindle_split_020.html) - 8.40',
            "Listing\x{a0}<<8.40|5a:0>>. golang.org/src/bytes/buffer.go
Listing\x{a0}<<8.41|5a:0>>. listing37.go: lines 22\x{2013}25
Listing\x{a0}<<8.42|5a:0>>. golang.org/src/os/file.go",
          ],
          [
            1,
            '[ap 08:41] Go in Action - William Kennedy.epub (kindle_split_020.html) - 8.41',
            "Listing\x{a0}<<8.41|5a:0>>. listing37.go: lines 22\x{2013}25
Listing\x{a0}<<8.42|5a:0>>. golang.org/src/os/file.go
Listing\x{a0}<<8.43|5a:0>>. golang.org/src/os/file_unix.go",
          ],
          [
            1,
            '[ap 08:42] Go in Action - William Kennedy.epub (kindle_split_020.html) - 8.42',
            "Listing\x{a0}<<8.42|5a:0>>. golang.org/src/os/file.go
Listing\x{a0}<<8.43|5a:0>>. golang.org/src/os/file_unix.go
Listing\x{a0}<<8.44|5a:0>>. golang.org/src/os/file.go",
          ],
          [
            1,
            '[ap 08:43] Go in Action - William Kennedy.epub (kindle_split_020.html) - 8.43',
            "Listing\x{a0}<<8.43|5a:0>>. golang.org/src/os/file_unix.go
Listing\x{a0}<<8.44|5a:0>>. golang.org/src/os/file.go
Listing\x{a0}<<8.45|5a:0>>. listing37.go: lines 22\x{2013}25",
          ],
          [
            1,
            '[ap 08:44] Go in Action - William Kennedy.epub (kindle_split_020.html) - 8.44',
            "Listing\x{a0}<<8.44|5a:0>>. golang.org/src/os/file.go
Listing\x{a0}<<8.45|5a:0>>. listing37.go: lines 22\x{2013}25
Listing\x{a0}<<8.46|5a:0>>. listing46.go",
          ],
          [
            1,
            '[ap 08:45] Go in Action - William Kennedy.epub (kindle_split_020.html) - 8.45',
            "Listing\x{a0}<<8.45|5a:0>>. listing37.go: lines 22\x{2013}25
Listing\x{a0}<<8.46|5a:0>>. listing46.go
Chapter 9. Testing and benchmarking",
          ],
          [
            1,
            '[ap 09:10] Go in Action - William Kennedy.epub (kindle_split_020.html) - 9.10',
            "Listing\x{a0}9.9. listing08_test.go: lines 12\x{2013}27
Listing\x{a0}<<9.10|5a:0>>. listing08_test.go: lines 29\x{2013}34
Listing\x{a0}<<9.11|5a:0>>. listing08_test.go: lines 35\x{2013}55",
          ],
          [
            1,
            '[ap 09:10] Go in Action - William Kennedy.epub (kindle_split_020.html) - 9.10',
            "Listing\x{a0}<<9.10|5a:0>>. listing08_test.go: lines 29\x{2013}34
Listing\x{a0}<<9.11|5a:0>>. listing08_test.go: lines 35\x{2013}55
Listing\x{a0}<<9.12|5a:0>>. listing12_test.go: lines 01\x{2013}41",
          ],
          [
            1,
            '[ap 09:11] Go in Action - William Kennedy.epub (kindle_split_020.html) - 9.11',
            "Listing\x{a0}<<9.11|5a:0>>. listing08_test.go: lines 35\x{2013}55
Listing\x{a0}<<9.12|5a:0>>. listing12_test.go: lines 01\x{2013}41
Listing\x{a0}<<9.13|5a:0>>. listing12_test.go: lines 32\x{2013}40",
          ],
          [
            1,
            '[ap 09:12] Go in Action - William Kennedy.epub (kindle_split_020.html) - 9.12',
            "Listing\x{a0}<<9.12|5a:0>>. listing12_test.go: lines 01\x{2013}41
Listing\x{a0}<<9.13|5a:0>>. listing12_test.go: lines 32\x{2013}40
Listing\x{a0}<<9.14|5a:0>>. golang.org/pkg/net/http/#HandlerFunc",
          ],
          [
            1,
            '[ap 09:13] Go in Action - William Kennedy.epub (kindle_split_020.html) - 9.13',
            "Listing\x{a0}<<9.13|5a:0>>. listing12_test.go: lines 32\x{2013}40
Listing\x{a0}<<9.14|5a:0>>. golang.org/pkg/net/http/#HandlerFunc
Listing\x{a0}<<9.15|5a:0>>. listing12_test.go: lines 43\x{2013}74",
          ],
          [
            1,
            '[ap 09:14] Go in Action - William Kennedy.epub (kindle_split_020.html) - 9.14',
            "Listing\x{a0}<<9.14|5a:0>>. golang.org/pkg/net/http/#HandlerFunc
Listing\x{a0}<<9.15|5a:0>>. listing12_test.go: lines 43\x{2013}74
Listing\x{a0}<<9.16|5a:0>>. listing12_test.go: line 56",
          ],
          [
            1,
            '[ap 09:15] Go in Action - William Kennedy.epub (kindle_split_020.html) - 9.15',
            "Listing\x{a0}<<9.15|5a:0>>. listing12_test.go: lines 43\x{2013}74
Listing\x{a0}<<9.16|5a:0>>. listing12_test.go: line 56
Listing\x{a0}<<9.17|5a:0>>. listing17.go",
          ],
          [
            1,
            '[ap 09:16] Go in Action - William Kennedy.epub (kindle_split_020.html) - 9.16',
            "Listing\x{a0}<<9.16|5a:0>>. listing12_test.go: line 56
Listing\x{a0}<<9.17|5a:0>>. listing17.go
Listing\x{a0}<<9.18|5a:0>>. handlers/handlers.go",
          ],
          [
            1,
            '[ap 09:17] Go in Action - William Kennedy.epub (kindle_split_020.html) - 9.17',
            "Listing\x{a0}<<9.17|5a:0>>. listing17.go
Listing\x{a0}<<9.18|5a:0>>. handlers/handlers.go
Listing\x{a0}<<9.19|5a:0>>. handlers/handlers_test.go",
          ],
          [
            1,
            '[ap 09:18] Go in Action - William Kennedy.epub (kindle_split_020.html) - 9.18',
            "Listing\x{a0}<<9.18|5a:0>>. handlers/handlers.go
Listing\x{a0}<<9.19|5a:0>>. handlers/handlers_test.go
Listing\x{a0}<<9.20|5a:0>>. handlers/handlers_test.go: lines 01\x{2013}03",
          ],
          [
            1,
            '[ap 09:19] Go in Action - William Kennedy.epub (kindle_split_020.html) - 9.19',
            "Listing\x{a0}<<9.19|5a:0>>. handlers/handlers_test.go
Listing\x{a0}<<9.20|5a:0>>. handlers/handlers_test.go: lines 01\x{2013}03
Listing\x{a0}<<9.21|5a:0>>. handlers/handlers_test.go: lines 17\x{2013}19",
          ],
          [
            1,
            '[ap 09:20] Go in Action - William Kennedy.epub (kindle_split_020.html) - 9.20',
            "Listing\x{a0}<<9.20|5a:0>>. handlers/handlers_test.go: lines 01\x{2013}03
Listing\x{a0}<<9.21|5a:0>>. handlers/handlers_test.go: lines 17\x{2013}19
Listing\x{a0}<<9.22|5a:0>>. handlers/handlers_test.go: lines 21\x{2013}34",
          ],
          [
            1,
            '[ap 09:21] Go in Action - William Kennedy.epub (kindle_split_020.html) - 9.21',
            "Listing\x{a0}<<9.21|5a:0>>. handlers/handlers_test.go: lines 17\x{2013}19
Listing\x{a0}<<9.22|5a:0>>. handlers/handlers_test.go: lines 21\x{2013}34
Listing\x{a0}<<9.23|5a:0>>. handlers/handlers_test.go: lines 36\x{2013}39",
          ],
          [
            1,
            '[ap 09:22] Go in Action - William Kennedy.epub (kindle_split_020.html) - 9.22',
            "Listing\x{a0}<<9.22|5a:0>>. handlers/handlers_test.go: lines 21\x{2013}34
Listing\x{a0}<<9.23|5a:0>>. handlers/handlers_test.go: lines 36\x{2013}39
Listing\x{a0}<<9.24|5a:0>>. handlers/handlers_test.go: lines 41\x{2013}49",
          ],
          [
            1,
            '[ap 09:23] Go in Action - William Kennedy.epub (kindle_split_020.html) - 9.23',
            "Listing\x{a0}<<9.23|5a:0>>. handlers/handlers_test.go: lines 36\x{2013}39
Listing\x{a0}<<9.24|5a:0>>. handlers/handlers_test.go: lines 41\x{2013}49
Listing\x{a0}<<9.25|5a:0>>. handlers/handlers_test.go: lines 51\x{2013}63",
          ],
          [
            1,
            '[ap 09:24] Go in Action - William Kennedy.epub (kindle_split_020.html) - 9.24',
            "Listing\x{a0}<<9.24|5a:0>>. handlers/handlers_test.go: lines 41\x{2013}49
Listing\x{a0}<<9.25|5a:0>>. handlers/handlers_test.go: lines 51\x{2013}63
Listing\x{a0}<<9.26|5a:0>>. handlers_example_test.go",
          ],
          [
            1,
            '[ap 09:25] Go in Action - William Kennedy.epub (kindle_split_020.html) - 9.25',
            "Listing\x{a0}<<9.25|5a:0>>. handlers/handlers_test.go: lines 51\x{2013}63
Listing\x{a0}<<9.26|5a:0>>. handlers_example_test.go
Listing\x{a0}<<9.27|5a:0>>. handlers_example_test.go: lines 27\x{2013}31",
          ],
          [
            1,
            '[ap 09:26] Go in Action - William Kennedy.epub (kindle_split_020.html) - 9.26',
            "Listing\x{a0}<<9.26|5a:0>>. handlers_example_test.go
Listing\x{a0}<<9.27|5a:0>>. handlers_example_test.go: lines 27\x{2013}31
Listing\x{a0}<<9.28|5a:0>>. listing28_test.go: lines 01\x{2013}10",
          ],
          [
            1,
            '[ap 09:27] Go in Action - William Kennedy.epub (kindle_split_020.html) - 9.27',
            "Listing\x{a0}<<9.27|5a:0>>. handlers_example_test.go: lines 27\x{2013}31
Listing\x{a0}<<9.28|5a:0>>. listing28_test.go: lines 01\x{2013}10
Listing\x{a0}<<9.29|5a:0>>. listing28_test.go: lines 12\x{2013}22",
          ],
          [
            1,
            '[ap 09:28] Go in Action - William Kennedy.epub (kindle_split_020.html) - 9.28',
            "Listing\x{a0}<<9.28|5a:0>>. listing28_test.go: lines 01\x{2013}10
Listing\x{a0}<<9.29|5a:0>>. listing28_test.go: lines 12\x{2013}22
Listing\x{a0}<<9.30|5a:0>>. listing28_test.go: lines 19\x{2013}22",
          ],
          [
            1,
            '[ap 09:29] Go in Action - William Kennedy.epub (kindle_split_020.html) - 9.29',
            "Listing\x{a0}<<9.29|5a:0>>. listing28_test.go: lines 12\x{2013}22
Listing\x{a0}<<9.30|5a:0>>. listing28_test.go: lines 19\x{2013}22
Listing\x{a0}<<9.31|5a:0>>. Running the benchmark test",
          ],
          [
            1,
            '[ap 09:30] Go in Action - William Kennedy.epub (kindle_split_020.html) - 9.30',
            "Listing\x{a0}<<9.30|5a:0>>. listing28_test.go: lines 19\x{2013}22
Listing\x{a0}<<9.31|5a:0>>. Running the benchmark test
Listing\x{a0}<<9.32|5a:0>>. listing28_test.go: lines 24\x{2013}46",
          ],
          [
            1,
            '[ap 09:31] Go in Action - William Kennedy.epub (kindle_split_020.html) - 9.31',
            "Listing\x{a0}<<9.31|5a:0>>. Running the benchmark test
Listing\x{a0}<<9.32|5a:0>>. listing28_test.go: lines 24\x{2013}46
",
          ],
        ];
